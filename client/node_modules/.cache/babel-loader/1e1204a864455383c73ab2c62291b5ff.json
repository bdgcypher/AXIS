{"ast":null,"code":"'use strict';\n\nconst StringScanner = require('./StringScanner');\n\nconst syntax = require('./syntax');\n\nconst XmlCdata = require('./XmlCdata');\n\nconst XmlComment = require('./XmlComment');\n\nconst XmlDocument = require('./XmlDocument');\n\nconst XmlElement = require('./XmlElement');\n\nconst XmlProcessingInstruction = require('./XmlProcessingInstruction');\n\nconst XmlText = require('./XmlText');\n\nconst emptyString = '';\n/**\r\nParses an XML string into an `XmlDocument`.\r\n\r\n@private\r\n*/\n\nclass Parser {\n  /**\r\n  @param {string} xml\r\n    XML string to parse.\r\n    @param {object} [options]\r\n    Parsing options.\r\n      @param {boolean} [options.ignoreUndefinedEntities=false]\r\n    @param {boolean} [options.preserveCdata=false]\r\n    @param {boolean} [options.preserveComments=false]\r\n    @param {(entity: string) => string?} [options.resolveUndefinedEntity]\r\n    @param {boolean} [options.sortAttributes=false]\r\n  */\n  constructor(xml, options = {}) {\n    /** @type {XmlDocument} */\n    this.document = new XmlDocument();\n    /** @type {XmlDocument|XmlElement} */\n\n    this.currentNode = this.document;\n    this.options = options;\n    this.scanner = new StringScanner(normalizeXmlString(xml));\n    this.consumeProlog();\n\n    if (!this.consumeElement()) {\n      this.error('Root element is missing or invalid');\n    }\n\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n\n    if (!this.scanner.isEnd) {\n      this.error('Extra content at the end of the document');\n    }\n  }\n  /**\r\n  Adds the given `XmlNode` as a child of `this.currentNode`.\r\n    @param {XmlNode} node\r\n  */\n\n\n  addNode(node) {\n    node.parent = this.currentNode; // @ts-ignore\n\n    this.currentNode.children.push(node);\n  }\n  /**\r\n  Adds the given _text_ to the document, either by appending it to a preceding\r\n  `XmlText` node (if possible) or by creating a new `XmlText` node.\r\n    @param {string} text\r\n  */\n\n\n  addText(text) {\n    let {\n      children\n    } = this.currentNode;\n\n    if (children.length > 0) {\n      let prevNode = children[children.length - 1];\n\n      if (prevNode instanceof XmlText) {\n        // The previous node is a text node, so we can append to it and avoid\n        // creating another node.\n        prevNode.text += text;\n        return;\n      }\n    }\n\n    this.addNode(new XmlText(text));\n  }\n  /**\r\n  Consumes an `AttValue` (attribute value) if possible.\r\n    @returns {string|false}\r\n    Contents of the `AttValue` minus quotes, or `false` if nothing was consumed.\r\n    An empty string indicates that an `AttValue` was consumed but was empty.\r\n    @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue\r\n  */\n\n\n  consumeAttributeValue() {\n    let {\n      scanner\n    } = this;\n    let quote = scanner.peek();\n\n    if (quote !== '\"' && quote !== \"'\") {\n      return false;\n    }\n\n    scanner.advance();\n    let chars;\n    let isClosed = false;\n    let value = emptyString;\n    let regex = quote === '\"' ? /[^\"&<]+/y : /[^'&<]+/y;\n\n    matchLoop: while (!scanner.isEnd) {\n      chars = scanner.consumeMatch(regex);\n\n      if (chars) {\n        this.validateChars(chars);\n        value += chars.replace(/[\\t\\r\\n]/g, ' ');\n      }\n\n      let nextChar = scanner.peek();\n\n      switch (nextChar) {\n        case quote:\n          isClosed = true;\n          break matchLoop;\n\n        case '&':\n          value += this.consumeReference();\n          continue;\n\n        case '<':\n          this.error('Unescaped `<` is not allowed in an attribute value');\n          /* istanbul ignore next */\n\n          break;\n\n        case emptyString:\n          this.error('Unclosed attribute');\n          /* istanbul ignore next */\n\n          break;\n      }\n    }\n\n    if (!isClosed) {\n      this.error('Unclosed attribute');\n    }\n\n    scanner.advance();\n    return value;\n  }\n  /**\r\n  Consumes a CDATA section if possible.\r\n    @returns {boolean}\r\n    Whether a CDATA section was consumed.\r\n    @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-cdata-sect\r\n  */\n\n\n  consumeCdataSection() {\n    let {\n      scanner\n    } = this;\n\n    if (!scanner.consumeStringFast('<![CDATA[')) {\n      return false;\n    }\n\n    let text = scanner.consumeUntilString(']]>');\n    this.validateChars(text);\n\n    if (!scanner.consumeStringFast(']]>')) {\n      this.error('Unclosed CDATA section');\n    }\n\n    if (this.options.preserveCdata) {\n      this.addNode(new XmlCdata(text));\n    } else {\n      this.addText(text);\n    }\n\n    return true;\n  }\n  /**\r\n  Consumes character data if possible.\r\n    @returns {boolean}\r\n    Whether character data was consumed.\r\n    @see https://www.w3.org/TR/2008/REC-xml-20081126/#dt-chardata\r\n  */\n\n\n  consumeCharData() {\n    let {\n      scanner\n    } = this;\n    let charData = scanner.consumeUntilMatch(/<|&|]]>/g);\n\n    if (!charData) {\n      return false;\n    }\n\n    this.validateChars(charData);\n\n    if (scanner.peek() === ']' && scanner.peek(3) === ']]>') {\n      this.error('Element content may not contain the CDATA section close delimiter `]]>`');\n    }\n\n    this.addText(charData);\n    return true;\n  }\n  /**\r\n  Consumes a comment if possible.\r\n    @returns {boolean}\r\n    Whether a comment was consumed.\r\n    @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Comment\r\n  */\n\n\n  consumeComment() {\n    let {\n      scanner\n    } = this;\n\n    if (!scanner.consumeStringFast('<!--')) {\n      return false;\n    }\n\n    let content = scanner.consumeUntilString('--');\n    this.validateChars(content);\n\n    if (!scanner.consumeStringFast('-->')) {\n      if (scanner.peek(2) === '--') {\n        this.error(\"The string `--` isn't allowed inside a comment\");\n      } else {\n        this.error('Unclosed comment');\n      }\n    }\n\n    if (this.options.preserveComments) {\n      this.addNode(new XmlComment(content.trim()));\n    }\n\n    return true;\n  }\n  /**\r\n  Consumes a reference in a content context if possible.\r\n    This differs from `consumeReference()` in that a consumed reference will be\r\n  added to the document as a text node instead of returned.\r\n    @returns {boolean}\r\n    Whether a reference was consumed.\r\n    @see https://www.w3.org/TR/2008/REC-xml-20081126/#entproc\r\n  */\n\n\n  consumeContentReference() {\n    let ref = this.consumeReference();\n\n    if (ref) {\n      this.addText(ref);\n      return true;\n    }\n\n    return false;\n  }\n  /**\r\n  Consumes a doctype declaration if possible.\r\n    This is a loose implementation since doctype declarations are currently\r\n  discarded without further parsing.\r\n    @returns {boolean}\r\n    Whether a doctype declaration was consumed.\r\n    @see https://www.w3.org/TR/2008/REC-xml-20081126/#dtd\r\n  */\n\n\n  consumeDoctypeDeclaration() {\n    let {\n      scanner\n    } = this;\n\n    if (!scanner.consumeStringFast('<!DOCTYPE') || !this.consumeWhitespace()) {\n      return false;\n    }\n\n    scanner.consumeMatch(/[^[>]+/y);\n\n    if (scanner.consumeMatch(/\\[[\\s\\S]+?\\][\\x20\\t\\r\\n]*>/y)) {\n      return true;\n    }\n\n    if (!scanner.consumeStringFast('>')) {\n      this.error('Unclosed doctype declaration');\n    }\n\n    return true;\n  }\n  /**\r\n  Consumes an element if possible.\r\n    @returns {boolean}\r\n    Whether an element was consumed.\r\n    @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-element\r\n  */\n\n\n  consumeElement() {\n    let {\n      scanner\n    } = this;\n    let mark = scanner.charIndex;\n\n    if (scanner.peek() !== '<') {\n      return false;\n    }\n\n    scanner.advance();\n    let name = this.consumeName();\n\n    if (!name) {\n      scanner.reset(mark);\n      return false;\n    }\n\n    let attributes = Object.create(null);\n\n    while (this.consumeWhitespace()) {\n      let attrName = this.consumeName();\n\n      if (!attrName) {\n        continue;\n      }\n\n      let attrValue = this.consumeEqual() && this.consumeAttributeValue();\n\n      if (attrValue === false) {\n        this.error('Attribute value expected');\n      }\n\n      if (attrName in attributes) {\n        this.error(`Duplicate attribute: ${attrName}`);\n      }\n\n      if (attrName === 'xml:space' && attrValue !== 'default' && attrValue !== 'preserve') {\n        this.error('Value of the `xml:space` attribute must be \"default\" or \"preserve\"');\n      }\n\n      attributes[attrName] = attrValue;\n    }\n\n    if (this.options.sortAttributes) {\n      let attrNames = Object.keys(attributes).sort();\n      let sortedAttributes = Object.create(null);\n\n      for (let i = 0; i < attrNames.length; ++i) {\n        let attrName = attrNames[i];\n        sortedAttributes[attrName] = attributes[attrName];\n      }\n\n      attributes = sortedAttributes;\n    }\n\n    let isEmpty = Boolean(scanner.consumeStringFast('/>'));\n    let element = new XmlElement(name, attributes);\n    element.parent = this.currentNode;\n\n    if (!isEmpty) {\n      if (!scanner.consumeStringFast('>')) {\n        this.error(`Unclosed start tag for element \\`${name}\\``);\n      }\n\n      this.currentNode = element;\n      this.consumeCharData();\n\n      while (this.consumeElement() || this.consumeContentReference() || this.consumeCdataSection() || this.consumeProcessingInstruction() || this.consumeComment()) {\n        this.consumeCharData();\n      }\n\n      let endTagMark = scanner.charIndex;\n      let endTagName;\n\n      if (!scanner.consumeStringFast('</') || !(endTagName = this.consumeName()) || endTagName !== name) {\n        scanner.reset(endTagMark);\n        this.error(`Missing end tag for element ${name}`);\n      }\n\n      this.consumeWhitespace();\n\n      if (!scanner.consumeStringFast('>')) {\n        this.error(`Unclosed end tag for element ${name}`);\n      }\n\n      this.currentNode = element.parent;\n    }\n\n    this.addNode(element);\n    return true;\n  }\n  /**\r\n  Consumes an `Eq` production if possible.\r\n    @returns {boolean}\r\n    Whether an `Eq` production was consumed.\r\n    @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Eq\r\n  */\n\n\n  consumeEqual() {\n    this.consumeWhitespace();\n\n    if (this.scanner.consumeStringFast('=')) {\n      this.consumeWhitespace();\n      return true;\n    }\n\n    return false;\n  }\n  /**\r\n  Consumes `Misc` content if possible.\r\n    @returns {boolean}\r\n    Whether anything was consumed.\r\n    @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Misc\r\n  */\n\n\n  consumeMisc() {\n    return this.consumeComment() || this.consumeProcessingInstruction() || this.consumeWhitespace();\n  }\n  /**\r\n  Consumes one or more `Name` characters if possible.\r\n    @returns {string}\r\n    `Name` characters, or an empty string if none were consumed.\r\n    @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Name\r\n  */\n\n\n  consumeName() {\n    return syntax.isNameStartChar(this.scanner.peek()) ? this.scanner.consumeMatchFn(syntax.isNameChar) : emptyString;\n  }\n  /**\r\n  Consumes a processing instruction if possible.\r\n    @returns {boolean}\r\n    Whether a processing instruction was consumed.\r\n    @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-pi\r\n  */\n\n\n  consumeProcessingInstruction() {\n    let {\n      scanner\n    } = this;\n    let mark = scanner.charIndex;\n\n    if (!scanner.consumeStringFast('<?')) {\n      return false;\n    }\n\n    let name = this.consumeName();\n\n    if (name) {\n      if (name.toLowerCase() === 'xml') {\n        scanner.reset(mark);\n        this.error(\"XML declaration isn't allowed here\");\n      }\n    } else {\n      this.error('Invalid processing instruction');\n    }\n\n    if (!this.consumeWhitespace()) {\n      if (scanner.consumeStringFast('?>')) {\n        this.addNode(new XmlProcessingInstruction(name));\n        return true;\n      }\n\n      this.error('Whitespace is required after a processing instruction name');\n    }\n\n    let content = scanner.consumeUntilString('?>');\n    this.validateChars(content);\n\n    if (!scanner.consumeStringFast('?>')) {\n      this.error('Unterminated processing instruction');\n    }\n\n    this.addNode(new XmlProcessingInstruction(name, content));\n    return true;\n  }\n  /**\r\n  Consumes a prolog if possible.\r\n    @returns {boolean}\r\n    Whether a prolog was consumed.\r\n    @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-prolog-dtd\r\n  */\n\n\n  consumeProlog() {\n    let {\n      scanner\n    } = this;\n    let mark = scanner.charIndex;\n    this.consumeXmlDeclaration();\n\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n\n    if (this.consumeDoctypeDeclaration()) {\n      while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n    }\n\n    return mark < scanner.charIndex;\n  }\n  /**\r\n  Consumes a reference if possible.\r\n    This differs from `consumeContentReference()` in that a consumed reference\r\n  will be returned rather than added to the document.\r\n    @returns {string|false}\r\n    Parsed reference value, or `false` if nothing was consumed (to distinguish\r\n    from a reference that resolves to an empty string).\r\n    @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Reference\r\n  */\n\n\n  consumeReference() {\n    let {\n      scanner\n    } = this;\n\n    if (scanner.peek() !== '&') {\n      return false;\n    }\n\n    scanner.advance();\n    let ref = scanner.consumeMatchFn(syntax.isReferenceChar);\n\n    if (scanner.consume() !== ';') {\n      this.error('Unterminated reference (a reference must end with `;`)');\n    }\n\n    let parsedValue;\n\n    if (ref[0] === '#') {\n      // This is a character reference.\n      let codePoint = ref[1] === 'x' ? parseInt(ref.slice(2), 16) // Hex codepoint.\n      : parseInt(ref.slice(1), 10); // Decimal codepoint.\n\n      if (isNaN(codePoint)) {\n        this.error('Invalid character reference');\n      }\n\n      parsedValue = String.fromCodePoint(codePoint);\n\n      if (!syntax.isXmlChar(parsedValue)) {\n        this.error('Character reference resolves to an invalid character');\n      }\n    } else {\n      // This is an entity reference.\n      parsedValue = syntax.predefinedEntities[ref];\n\n      if (parsedValue === undefined) {\n        let {\n          ignoreUndefinedEntities,\n          resolveUndefinedEntity\n        } = this.options;\n        let wrappedRef = `&${ref};`; // for backcompat with <= 2.x\n\n        if (resolveUndefinedEntity) {\n          let resolvedValue = resolveUndefinedEntity(wrappedRef);\n\n          if (resolvedValue !== null && resolvedValue !== undefined) {\n            let type = typeof resolvedValue;\n\n            if (type !== 'string') {\n              throw new TypeError(`\\`resolveUndefinedEntity()\\` must return a string, \\`null\\`, or \\`undefined\\`, but returned a value of type ${type}`);\n            }\n\n            return resolvedValue;\n          }\n        }\n\n        if (ignoreUndefinedEntities) {\n          return wrappedRef;\n        }\n\n        scanner.reset(-wrappedRef.length);\n        this.error(`Named entity isn't defined: ${wrappedRef}`);\n      }\n    }\n\n    return parsedValue;\n  }\n  /**\r\n  Consumes a `SystemLiteral` if possible.\r\n    A `SystemLiteral` is similar to an attribute value, but allows the characters\r\n  `<` and `&` and doesn't replace references.\r\n    @returns {string|false}\r\n    Value of the `SystemLiteral` minus quotes, or `false` if nothing was\r\n    consumed. An empty string indicates that a `SystemLiteral` was consumed but\r\n    was empty.\r\n    @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-SystemLiteral\r\n  */\n\n\n  consumeSystemLiteral() {\n    let {\n      scanner\n    } = this;\n    let quote = scanner.consumeStringFast('\"') || scanner.consumeStringFast(\"'\");\n\n    if (!quote) {\n      return false;\n    }\n\n    let value = scanner.consumeUntilString(quote);\n    this.validateChars(value);\n\n    if (!scanner.consumeStringFast(quote)) {\n      this.error('Missing end quote');\n    }\n\n    return value;\n  }\n  /**\r\n  Consumes one or more whitespace characters if possible.\r\n    @returns {boolean}\r\n    Whether any whitespace characters were consumed.\r\n    @see https://www.w3.org/TR/2008/REC-xml-20081126/#white\r\n  */\n\n\n  consumeWhitespace() {\n    return Boolean(this.scanner.consumeMatchFn(syntax.isWhitespace));\n  }\n  /**\r\n  Consumes an XML declaration if possible.\r\n    @returns {boolean}\r\n    Whether an XML declaration was consumed.\r\n    @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-XMLDecl\r\n  */\n\n\n  consumeXmlDeclaration() {\n    let {\n      scanner\n    } = this;\n\n    if (!scanner.consumeStringFast('<?xml')) {\n      return false;\n    }\n\n    if (!this.consumeWhitespace()) {\n      this.error('Invalid XML declaration');\n    }\n\n    let version = Boolean(scanner.consumeStringFast('version')) && this.consumeEqual() && this.consumeSystemLiteral();\n\n    if (version === false) {\n      this.error('XML version is missing or invalid');\n    } else if (!/^1\\.[0-9]+$/.test(version)) {\n      this.error('Invalid character in version number');\n    }\n\n    if (this.consumeWhitespace()) {\n      let encoding = Boolean(scanner.consumeStringFast('encoding')) && this.consumeEqual() && this.consumeSystemLiteral();\n\n      if (encoding) {\n        this.consumeWhitespace();\n      }\n\n      let standalone = Boolean(scanner.consumeStringFast('standalone')) && this.consumeEqual() && this.consumeSystemLiteral();\n\n      if (standalone) {\n        if (standalone !== 'yes' && standalone !== 'no') {\n          this.error('Only \"yes\" and \"no\" are permitted as values of `standalone`');\n        }\n\n        this.consumeWhitespace();\n      }\n    }\n\n    if (!scanner.consumeStringFast('?>')) {\n      this.error('Invalid or unclosed XML declaration');\n    }\n\n    return true;\n  }\n  /**\r\n  Throws an error at the current scanner position.\r\n    @param {string} message\r\n  */\n\n\n  error(message) {\n    let {\n      charIndex,\n      string: xml\n    } = this.scanner;\n    let column = 1;\n    let excerpt = '';\n    let line = 1; // Find the line and column where the error occurred.\n\n    for (let i = 0; i < charIndex; ++i) {\n      let char = xml[i];\n\n      if (char === '\\n') {\n        column = 1;\n        excerpt = '';\n        line += 1;\n      } else {\n        column += 1;\n        excerpt += char;\n      }\n    }\n\n    let eol = xml.indexOf('\\n', charIndex);\n    excerpt += eol === -1 ? xml.slice(charIndex) : xml.slice(charIndex, eol);\n    let excerptStart = 0; // Keep the excerpt below 50 chars, but always keep the error position in\n    // view.\n\n    if (excerpt.length > 50) {\n      if (column < 40) {\n        excerpt = excerpt.slice(0, 50);\n      } else {\n        excerptStart = column - 20;\n        excerpt = excerpt.slice(excerptStart, column + 30);\n      }\n    }\n\n    let err = new Error(`${message} (line ${line}, column ${column})\\n` + `  ${excerpt}\\n` + ' '.repeat(column - excerptStart + 1) + '^\\n');\n    Object.assign(err, {\n      column,\n      excerpt,\n      line,\n      pos: charIndex\n    });\n    throw err;\n  }\n  /**\r\n  Throws an invalid character error if any character in the given _string_ isn't\r\n  a valid XML character.\r\n    @param {string} string\r\n  */\n\n\n  validateChars(string) {\n    let charIndex = 0;\n\n    for (let char of string) {\n      if (syntax.isNotXmlChar(char)) {\n        this.scanner.reset(-([...string].length - charIndex));\n        this.error('Invalid character');\n      }\n\n      charIndex += 1;\n    }\n  }\n\n}\n\nmodule.exports = Parser; // -- Private Functions --------------------------------------------------------\n\n/**\r\nNormalizes the given XML string by stripping a byte order mark (if present) and\r\nreplacing CRLF sequences and lone CR characters with LF characters.\r\n\r\n@param {string} xml\r\n@returns {string}\r\n*/\n\nfunction normalizeXmlString(xml) {\n  if (xml[0] === '\\uFEFF') {\n    xml = xml.slice(1);\n  }\n\n  return xml.replace(/\\r\\n?/g, '\\n');\n}\n/** @typedef {import('./XmlNode')} XmlNode */","map":{"version":3,"sources":["C:/Users/bdgcy/Axis/client/node_modules/@rgrove/parse-xml/src/lib/Parser.js"],"names":["StringScanner","require","syntax","XmlCdata","XmlComment","XmlDocument","XmlElement","XmlProcessingInstruction","XmlText","emptyString","Parser","constructor","xml","options","document","currentNode","scanner","normalizeXmlString","consumeProlog","consumeElement","error","consumeMisc","isEnd","addNode","node","parent","children","push","addText","text","length","prevNode","consumeAttributeValue","quote","peek","advance","chars","isClosed","value","regex","matchLoop","consumeMatch","validateChars","replace","nextChar","consumeReference","consumeCdataSection","consumeStringFast","consumeUntilString","preserveCdata","consumeCharData","charData","consumeUntilMatch","consumeComment","content","preserveComments","trim","consumeContentReference","ref","consumeDoctypeDeclaration","consumeWhitespace","mark","charIndex","name","consumeName","reset","attributes","Object","create","attrName","attrValue","consumeEqual","sortAttributes","attrNames","keys","sort","sortedAttributes","i","isEmpty","Boolean","element","consumeProcessingInstruction","endTagMark","endTagName","isNameStartChar","consumeMatchFn","isNameChar","toLowerCase","consumeXmlDeclaration","isReferenceChar","consume","parsedValue","codePoint","parseInt","slice","isNaN","String","fromCodePoint","isXmlChar","predefinedEntities","undefined","ignoreUndefinedEntities","resolveUndefinedEntity","wrappedRef","resolvedValue","type","TypeError","consumeSystemLiteral","isWhitespace","version","test","encoding","standalone","message","string","column","excerpt","line","char","eol","indexOf","excerptStart","err","Error","repeat","assign","pos","isNotXmlChar","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst StringScanner = require('./StringScanner');\r\nconst syntax = require('./syntax');\r\nconst XmlCdata = require('./XmlCdata');\r\nconst XmlComment = require('./XmlComment');\r\nconst XmlDocument = require('./XmlDocument');\r\nconst XmlElement = require('./XmlElement');\r\nconst XmlProcessingInstruction = require('./XmlProcessingInstruction');\r\nconst XmlText = require('./XmlText');\r\n\r\nconst emptyString = '';\r\n\r\n/**\r\nParses an XML string into an `XmlDocument`.\r\n\r\n@private\r\n*/\r\nclass Parser {\r\n  /**\r\n  @param {string} xml\r\n    XML string to parse.\r\n\r\n  @param {object} [options]\r\n    Parsing options.\r\n\r\n    @param {boolean} [options.ignoreUndefinedEntities=false]\r\n    @param {boolean} [options.preserveCdata=false]\r\n    @param {boolean} [options.preserveComments=false]\r\n    @param {(entity: string) => string?} [options.resolveUndefinedEntity]\r\n    @param {boolean} [options.sortAttributes=false]\r\n  */\r\n  constructor(xml, options = {}) {\r\n    /** @type {XmlDocument} */\r\n    this.document = new XmlDocument();\r\n\r\n    /** @type {XmlDocument|XmlElement} */\r\n    this.currentNode = this.document;\r\n\r\n    this.options = options;\r\n    this.scanner = new StringScanner(normalizeXmlString(xml));\r\n\r\n    this.consumeProlog();\r\n\r\n    if (!this.consumeElement()) {\r\n      this.error('Root element is missing or invalid');\r\n    }\r\n\r\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\r\n\r\n    if (!this.scanner.isEnd) {\r\n      this.error('Extra content at the end of the document');\r\n    }\r\n  }\r\n\r\n  /**\r\n  Adds the given `XmlNode` as a child of `this.currentNode`.\r\n\r\n  @param {XmlNode} node\r\n  */\r\n  addNode(node) {\r\n    node.parent = this.currentNode;\r\n\r\n    // @ts-ignore\r\n    this.currentNode.children.push(node);\r\n  }\r\n\r\n  /**\r\n  Adds the given _text_ to the document, either by appending it to a preceding\r\n  `XmlText` node (if possible) or by creating a new `XmlText` node.\r\n\r\n  @param {string} text\r\n  */\r\n  addText(text) {\r\n    let { children } = this.currentNode;\r\n\r\n    if (children.length > 0) {\r\n      let prevNode = children[children.length - 1];\r\n\r\n      if (prevNode instanceof XmlText) {\r\n        // The previous node is a text node, so we can append to it and avoid\r\n        // creating another node.\r\n        prevNode.text += text;\r\n        return;\r\n      }\r\n    }\r\n\r\n    this.addNode(new XmlText(text));\r\n  }\r\n\r\n  /**\r\n  Consumes an `AttValue` (attribute value) if possible.\r\n\r\n  @returns {string|false}\r\n    Contents of the `AttValue` minus quotes, or `false` if nothing was consumed.\r\n    An empty string indicates that an `AttValue` was consumed but was empty.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue\r\n  */\r\n  consumeAttributeValue() {\r\n    let { scanner } = this;\r\n    let quote = scanner.peek();\r\n\r\n    if (quote !== '\"' && quote !== \"'\") {\r\n      return false;\r\n    }\r\n\r\n    scanner.advance();\r\n\r\n    let chars;\r\n    let isClosed = false;\r\n    let value = emptyString;\r\n    let regex = quote === '\"'\r\n      ? /[^\"&<]+/y\r\n      : /[^'&<]+/y;\r\n\r\n    matchLoop: while (!scanner.isEnd) {\r\n      chars = scanner.consumeMatch(regex);\r\n\r\n      if (chars) {\r\n        this.validateChars(chars);\r\n        value += chars.replace(/[\\t\\r\\n]/g, ' ');\r\n      }\r\n\r\n      let nextChar = scanner.peek();\r\n\r\n      switch (nextChar) {\r\n        case quote:\r\n          isClosed = true;\r\n          break matchLoop;\r\n\r\n        case '&':\r\n          value += this.consumeReference();\r\n          continue;\r\n\r\n        case '<':\r\n          this.error('Unescaped `<` is not allowed in an attribute value'); /* istanbul ignore next */\r\n          break;\r\n\r\n        case emptyString:\r\n          this.error('Unclosed attribute'); /* istanbul ignore next */\r\n          break;\r\n\r\n      }\r\n    }\r\n\r\n    if (!isClosed) {\r\n      this.error('Unclosed attribute');\r\n    }\r\n\r\n    scanner.advance();\r\n    return value;\r\n  }\r\n\r\n  /**\r\n  Consumes a CDATA section if possible.\r\n\r\n  @returns {boolean}\r\n    Whether a CDATA section was consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-cdata-sect\r\n  */\r\n  consumeCdataSection() {\r\n    let { scanner } = this;\r\n\r\n    if (!scanner.consumeStringFast('<![CDATA[')) {\r\n      return false;\r\n    }\r\n\r\n    let text = scanner.consumeUntilString(']]>');\r\n    this.validateChars(text);\r\n\r\n    if (!scanner.consumeStringFast(']]>')) {\r\n      this.error('Unclosed CDATA section');\r\n    }\r\n\r\n    if (this.options.preserveCdata) {\r\n      this.addNode(new XmlCdata(text));\r\n    } else {\r\n      this.addText(text);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  Consumes character data if possible.\r\n\r\n  @returns {boolean}\r\n    Whether character data was consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#dt-chardata\r\n  */\r\n  consumeCharData() {\r\n    let { scanner } = this;\r\n    let charData = scanner.consumeUntilMatch(/<|&|]]>/g);\r\n\r\n    if (!charData) {\r\n      return false;\r\n    }\r\n\r\n    this.validateChars(charData);\r\n\r\n    if (scanner.peek() === ']' && scanner.peek(3) === ']]>') {\r\n      this.error('Element content may not contain the CDATA section close delimiter `]]>`');\r\n    }\r\n\r\n    this.addText(charData);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  Consumes a comment if possible.\r\n\r\n  @returns {boolean}\r\n    Whether a comment was consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Comment\r\n  */\r\n  consumeComment() {\r\n    let { scanner } = this;\r\n\r\n    if (!scanner.consumeStringFast('<!--')) {\r\n      return false;\r\n    }\r\n\r\n    let content = scanner.consumeUntilString('--');\r\n    this.validateChars(content);\r\n\r\n    if (!scanner.consumeStringFast('-->')) {\r\n      if (scanner.peek(2) === '--') {\r\n        this.error(\"The string `--` isn't allowed inside a comment\");\r\n      } else {\r\n        this.error('Unclosed comment');\r\n      }\r\n    }\r\n\r\n    if (this.options.preserveComments) {\r\n      this.addNode(new XmlComment(content.trim()));\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  Consumes a reference in a content context if possible.\r\n\r\n  This differs from `consumeReference()` in that a consumed reference will be\r\n  added to the document as a text node instead of returned.\r\n\r\n  @returns {boolean}\r\n    Whether a reference was consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#entproc\r\n  */\r\n  consumeContentReference() {\r\n    let ref = this.consumeReference();\r\n\r\n    if (ref) {\r\n      this.addText(ref);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n  Consumes a doctype declaration if possible.\r\n\r\n  This is a loose implementation since doctype declarations are currently\r\n  discarded without further parsing.\r\n\r\n  @returns {boolean}\r\n    Whether a doctype declaration was consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#dtd\r\n  */\r\n  consumeDoctypeDeclaration() {\r\n    let { scanner } = this;\r\n\r\n    if (!scanner.consumeStringFast('<!DOCTYPE')\r\n        || !this.consumeWhitespace()) {\r\n\r\n      return false;\r\n    }\r\n\r\n    scanner.consumeMatch(/[^[>]+/y);\r\n\r\n    if (scanner.consumeMatch(/\\[[\\s\\S]+?\\][\\x20\\t\\r\\n]*>/y)) {\r\n      return true;\r\n    }\r\n\r\n    if (!scanner.consumeStringFast('>')) {\r\n      this.error('Unclosed doctype declaration');\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  Consumes an element if possible.\r\n\r\n  @returns {boolean}\r\n    Whether an element was consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-element\r\n  */\r\n  consumeElement() {\r\n    let { scanner } = this;\r\n    let mark = scanner.charIndex;\r\n\r\n    if (scanner.peek() !== '<') {\r\n      return false;\r\n    }\r\n\r\n    scanner.advance();\r\n    let name = this.consumeName();\r\n\r\n    if (!name) {\r\n      scanner.reset(mark);\r\n      return false;\r\n    }\r\n\r\n    let attributes = Object.create(null);\r\n\r\n    while (this.consumeWhitespace()) {\r\n      let attrName = this.consumeName();\r\n\r\n      if (!attrName) {\r\n        continue;\r\n      }\r\n\r\n      let attrValue = this.consumeEqual()\r\n        && this.consumeAttributeValue();\r\n\r\n      if (attrValue === false) {\r\n        this.error('Attribute value expected');\r\n      }\r\n\r\n      if (attrName in attributes) {\r\n        this.error(`Duplicate attribute: ${attrName}`);\r\n      }\r\n\r\n      if (attrName === 'xml:space'\r\n          && attrValue !== 'default'\r\n          && attrValue !== 'preserve') {\r\n\r\n        this.error('Value of the `xml:space` attribute must be \"default\" or \"preserve\"');\r\n      }\r\n\r\n      attributes[attrName] = attrValue;\r\n    }\r\n\r\n    if (this.options.sortAttributes) {\r\n      let attrNames = Object.keys(attributes).sort();\r\n      let sortedAttributes = Object.create(null);\r\n\r\n      for (let i = 0; i < attrNames.length; ++i) {\r\n        let attrName = attrNames[i];\r\n        sortedAttributes[attrName] = attributes[attrName];\r\n      }\r\n\r\n      attributes = sortedAttributes;\r\n    }\r\n\r\n    let isEmpty = Boolean(scanner.consumeStringFast('/>'));\r\n    let element = new XmlElement(name, attributes);\r\n\r\n    element.parent = this.currentNode;\r\n\r\n    if (!isEmpty) {\r\n      if (!scanner.consumeStringFast('>')) {\r\n        this.error(`Unclosed start tag for element \\`${name}\\``);\r\n      }\r\n\r\n      this.currentNode = element;\r\n      this.consumeCharData();\r\n\r\n      while (\r\n        this.consumeElement()\r\n          || this.consumeContentReference()\r\n          || this.consumeCdataSection()\r\n          || this.consumeProcessingInstruction()\r\n          || this.consumeComment()\r\n      ) {\r\n        this.consumeCharData();\r\n      }\r\n\r\n      let endTagMark = scanner.charIndex;\r\n      let endTagName;\r\n\r\n      if (!scanner.consumeStringFast('</')\r\n          || !(endTagName = this.consumeName())\r\n          || endTagName !== name) {\r\n\r\n        scanner.reset(endTagMark);\r\n        this.error(`Missing end tag for element ${name}`);\r\n      }\r\n\r\n      this.consumeWhitespace();\r\n\r\n      if (!scanner.consumeStringFast('>')) {\r\n        this.error(`Unclosed end tag for element ${name}`);\r\n      }\r\n\r\n      this.currentNode = element.parent;\r\n    }\r\n\r\n    this.addNode(element);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  Consumes an `Eq` production if possible.\r\n\r\n  @returns {boolean}\r\n    Whether an `Eq` production was consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Eq\r\n  */\r\n  consumeEqual() {\r\n    this.consumeWhitespace();\r\n\r\n    if (this.scanner.consumeStringFast('=')) {\r\n      this.consumeWhitespace();\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n  Consumes `Misc` content if possible.\r\n\r\n  @returns {boolean}\r\n    Whether anything was consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Misc\r\n  */\r\n  consumeMisc() {\r\n    return this.consumeComment()\r\n      || this.consumeProcessingInstruction()\r\n      || this.consumeWhitespace();\r\n  }\r\n\r\n  /**\r\n  Consumes one or more `Name` characters if possible.\r\n\r\n  @returns {string}\r\n    `Name` characters, or an empty string if none were consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Name\r\n  */\r\n  consumeName() {\r\n    return syntax.isNameStartChar(this.scanner.peek())\r\n      ? this.scanner.consumeMatchFn(syntax.isNameChar)\r\n      : emptyString;\r\n  }\r\n\r\n  /**\r\n  Consumes a processing instruction if possible.\r\n\r\n  @returns {boolean}\r\n    Whether a processing instruction was consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-pi\r\n  */\r\n  consumeProcessingInstruction() {\r\n    let { scanner } = this;\r\n    let mark = scanner.charIndex;\r\n\r\n    if (!scanner.consumeStringFast('<?')) {\r\n      return false;\r\n    }\r\n\r\n    let name = this.consumeName();\r\n\r\n    if (name) {\r\n      if (name.toLowerCase() === 'xml') {\r\n        scanner.reset(mark);\r\n        this.error(\"XML declaration isn't allowed here\");\r\n      }\r\n    } else {\r\n      this.error('Invalid processing instruction');\r\n    }\r\n\r\n    if (!this.consumeWhitespace()) {\r\n      if (scanner.consumeStringFast('?>')) {\r\n        this.addNode(new XmlProcessingInstruction(name));\r\n        return true;\r\n      }\r\n\r\n      this.error('Whitespace is required after a processing instruction name');\r\n    }\r\n\r\n    let content = scanner.consumeUntilString('?>');\r\n    this.validateChars(content);\r\n\r\n    if (!scanner.consumeStringFast('?>')) {\r\n      this.error('Unterminated processing instruction');\r\n    }\r\n\r\n    this.addNode(new XmlProcessingInstruction(name, content));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  Consumes a prolog if possible.\r\n\r\n  @returns {boolean}\r\n    Whether a prolog was consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-prolog-dtd\r\n  */\r\n  consumeProlog() {\r\n    let { scanner } = this;\r\n    let mark = scanner.charIndex;\r\n\r\n    this.consumeXmlDeclaration();\r\n\r\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\r\n\r\n    if (this.consumeDoctypeDeclaration()) {\r\n      while (this.consumeMisc()) {} // eslint-disable-line no-empty\r\n    }\r\n\r\n    return mark < scanner.charIndex;\r\n  }\r\n\r\n  /**\r\n  Consumes a reference if possible.\r\n\r\n  This differs from `consumeContentReference()` in that a consumed reference\r\n  will be returned rather than added to the document.\r\n\r\n  @returns {string|false}\r\n    Parsed reference value, or `false` if nothing was consumed (to distinguish\r\n    from a reference that resolves to an empty string).\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Reference\r\n  */\r\n  consumeReference() {\r\n    let { scanner } = this;\r\n\r\n    if (scanner.peek() !== '&') {\r\n      return false;\r\n    }\r\n\r\n    scanner.advance();\r\n\r\n    let ref = scanner.consumeMatchFn(syntax.isReferenceChar);\r\n\r\n    if (scanner.consume() !== ';') {\r\n      this.error('Unterminated reference (a reference must end with `;`)');\r\n    }\r\n\r\n    let parsedValue;\r\n\r\n    if (ref[0] === '#') {\r\n      // This is a character reference.\r\n      let codePoint = ref[1] === 'x'\r\n        ? parseInt(ref.slice(2), 16) // Hex codepoint.\r\n        : parseInt(ref.slice(1), 10); // Decimal codepoint.\r\n\r\n      if (isNaN(codePoint)) {\r\n        this.error('Invalid character reference');\r\n      }\r\n\r\n      parsedValue = String.fromCodePoint(codePoint);\r\n\r\n      if (!syntax.isXmlChar(parsedValue)) {\r\n        this.error('Character reference resolves to an invalid character');\r\n      }\r\n    } else {\r\n      // This is an entity reference.\r\n      parsedValue = syntax.predefinedEntities[ref];\r\n\r\n      if (parsedValue === undefined) {\r\n        let {\r\n          ignoreUndefinedEntities,\r\n          resolveUndefinedEntity\r\n        } = this.options;\r\n\r\n        let wrappedRef = `&${ref};`; // for backcompat with <= 2.x\r\n\r\n        if (resolveUndefinedEntity) {\r\n          let resolvedValue = resolveUndefinedEntity(wrappedRef);\r\n\r\n          if (resolvedValue !== null && resolvedValue !== undefined) {\r\n            let type = typeof resolvedValue;\r\n\r\n            if (type !== 'string') {\r\n              throw new TypeError(`\\`resolveUndefinedEntity()\\` must return a string, \\`null\\`, or \\`undefined\\`, but returned a value of type ${type}`);\r\n            }\r\n\r\n            return resolvedValue;\r\n          }\r\n        }\r\n\r\n        if (ignoreUndefinedEntities) {\r\n          return wrappedRef;\r\n        }\r\n\r\n        scanner.reset(-wrappedRef.length);\r\n        this.error(`Named entity isn't defined: ${wrappedRef}`);\r\n      }\r\n    }\r\n\r\n    return parsedValue;\r\n  }\r\n\r\n  /**\r\n  Consumes a `SystemLiteral` if possible.\r\n\r\n  A `SystemLiteral` is similar to an attribute value, but allows the characters\r\n  `<` and `&` and doesn't replace references.\r\n\r\n  @returns {string|false}\r\n    Value of the `SystemLiteral` minus quotes, or `false` if nothing was\r\n    consumed. An empty string indicates that a `SystemLiteral` was consumed but\r\n    was empty.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-SystemLiteral\r\n  */\r\n  consumeSystemLiteral() {\r\n    let { scanner } = this;\r\n    let quote = scanner.consumeStringFast('\"') || scanner.consumeStringFast(\"'\");\r\n\r\n    if (!quote) {\r\n      return false;\r\n    }\r\n\r\n    let value = scanner.consumeUntilString(quote);\r\n    this.validateChars(value);\r\n\r\n    if (!scanner.consumeStringFast(quote)) {\r\n      this.error('Missing end quote');\r\n    }\r\n\r\n    return value;\r\n  }\r\n\r\n  /**\r\n  Consumes one or more whitespace characters if possible.\r\n\r\n  @returns {boolean}\r\n    Whether any whitespace characters were consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#white\r\n  */\r\n  consumeWhitespace() {\r\n    return Boolean(this.scanner.consumeMatchFn(syntax.isWhitespace));\r\n  }\r\n\r\n  /**\r\n  Consumes an XML declaration if possible.\r\n\r\n  @returns {boolean}\r\n    Whether an XML declaration was consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-XMLDecl\r\n  */\r\n  consumeXmlDeclaration() {\r\n    let { scanner } = this;\r\n\r\n    if (!scanner.consumeStringFast('<?xml')) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.consumeWhitespace()) {\r\n      this.error('Invalid XML declaration');\r\n    }\r\n\r\n    let version = Boolean(scanner.consumeStringFast('version'))\r\n      && this.consumeEqual()\r\n      && this.consumeSystemLiteral();\r\n\r\n    if (version === false) {\r\n      this.error('XML version is missing or invalid');\r\n    } else if (!/^1\\.[0-9]+$/.test(version)) {\r\n      this.error('Invalid character in version number');\r\n    }\r\n\r\n    if (this.consumeWhitespace()) {\r\n      let encoding = Boolean(scanner.consumeStringFast('encoding'))\r\n        && this.consumeEqual()\r\n        && this.consumeSystemLiteral();\r\n\r\n      if (encoding) {\r\n        this.consumeWhitespace();\r\n      }\r\n\r\n      let standalone = Boolean(scanner.consumeStringFast('standalone'))\r\n        && this.consumeEqual()\r\n        && this.consumeSystemLiteral();\r\n\r\n      if (standalone) {\r\n        if (standalone !== 'yes' && standalone !== 'no') {\r\n          this.error('Only \"yes\" and \"no\" are permitted as values of `standalone`');\r\n        }\r\n\r\n        this.consumeWhitespace();\r\n      }\r\n    }\r\n\r\n    if (!scanner.consumeStringFast('?>')) {\r\n      this.error('Invalid or unclosed XML declaration');\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  Throws an error at the current scanner position.\r\n\r\n  @param {string} message\r\n  */\r\n  error(message) {\r\n    let { charIndex, string: xml } = this.scanner;\r\n    let column = 1;\r\n    let excerpt = '';\r\n    let line = 1;\r\n\r\n    // Find the line and column where the error occurred.\r\n    for (let i = 0; i < charIndex; ++i) {\r\n      let char = xml[i];\r\n\r\n      if (char === '\\n') {\r\n        column = 1;\r\n        excerpt = '';\r\n        line += 1;\r\n      } else {\r\n        column += 1;\r\n        excerpt += char;\r\n      }\r\n    }\r\n\r\n    let eol = xml.indexOf('\\n', charIndex);\r\n\r\n    excerpt += eol === -1\r\n      ? xml.slice(charIndex)\r\n      : xml.slice(charIndex, eol);\r\n\r\n    let excerptStart = 0;\r\n\r\n    // Keep the excerpt below 50 chars, but always keep the error position in\r\n    // view.\r\n    if (excerpt.length > 50) {\r\n      if (column < 40) {\r\n        excerpt = excerpt.slice(0, 50);\r\n      } else {\r\n        excerptStart = column - 20;\r\n        excerpt = excerpt.slice(excerptStart, column + 30);\r\n      }\r\n    }\r\n\r\n    let err = new Error(\r\n      `${message} (line ${line}, column ${column})\\n`\r\n        + `  ${excerpt}\\n`\r\n        + ' '.repeat(column - excerptStart + 1) + '^\\n'\r\n    );\r\n\r\n    Object.assign(err, {\r\n      column,\r\n      excerpt,\r\n      line,\r\n      pos: charIndex\r\n    });\r\n\r\n    throw err;\r\n  }\r\n\r\n  /**\r\n  Throws an invalid character error if any character in the given _string_ isn't\r\n  a valid XML character.\r\n\r\n  @param {string} string\r\n  */\r\n  validateChars(string) {\r\n    let charIndex = 0;\r\n\r\n    for (let char of string) {\r\n      if (syntax.isNotXmlChar(char)) {\r\n        this.scanner.reset(-([ ...string ].length - charIndex));\r\n        this.error('Invalid character');\r\n      }\r\n\r\n      charIndex += 1;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Parser;\r\n\r\n// -- Private Functions --------------------------------------------------------\r\n\r\n/**\r\nNormalizes the given XML string by stripping a byte order mark (if present) and\r\nreplacing CRLF sequences and lone CR characters with LF characters.\r\n\r\n@param {string} xml\r\n@returns {string}\r\n*/\r\nfunction normalizeXmlString(xml) {\r\n  if (xml[0] === '\\uFEFF') {\r\n    xml = xml.slice(1);\r\n  }\r\n\r\n  return xml.replace(/\\r\\n?/g, '\\n');\r\n}\r\n\r\n/** @typedef {import('./XmlNode')} XmlNode */\r\n"]},"metadata":{},"sourceType":"script"}