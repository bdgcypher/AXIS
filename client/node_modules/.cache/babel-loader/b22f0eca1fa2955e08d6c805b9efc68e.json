{"ast":null,"code":"/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/* istanbul ignore next */\n\n/* jshint ignore:start */\nif (typeof module === 'object') {\n  // CommonJS, where exports may be different each time.\n  ICAL = module.exports;\n} else if (typeof ICAL !== 'object') {\n  /* istanbul ignore next */\n\n  /** @ignore */\n  this.ICAL = {};\n}\n/* jshint ignore:end */\n\n/**\r\n * The number of characters before iCalendar line folding should occur\r\n * @type {Number}\r\n * @default 75\r\n */\n\n\nICAL.foldLength = 75;\n/**\r\n * The character(s) to be used for a newline. The default value is provided by\r\n * rfc5545.\r\n * @type {String}\r\n * @default \"\\r\\n\"\r\n */\n\nICAL.newLineChar = '\\r\\n';\n/**\r\n * Helper functions used in various places within ical.js\r\n * @namespace\r\n */\n\nICAL.helpers = {\n  /**\r\n   * Compiles a list of all referenced TZIDs in all subcomponents and\r\n   * removes any extra VTIMEZONE subcomponents. In addition, if any TZIDs\r\n   * are referenced by a component, but a VTIMEZONE does not exist,\r\n   * an attempt will be made to generate a VTIMEZONE using ICAL.TimezoneService.\r\n   *\r\n   * @param {ICAL.Component} vcal     The top-level VCALENDAR component.\r\n   * @return {ICAL.Component}         The ICAL.Component that was passed in.\r\n   */\n  updateTimezones: function updateTimezones(vcal) {\n    var allsubs, properties, vtimezones, reqTzid, i, tzid;\n\n    if (!vcal || vcal.name !== \"vcalendar\") {\n      //not a top-level vcalendar component\n      return vcal;\n    } //Store vtimezone subcomponents in an object reference by tzid.\n    //Store properties from everything else in another array\n\n\n    allsubs = vcal.getAllSubcomponents();\n    properties = [];\n    vtimezones = {};\n\n    for (i = 0; i < allsubs.length; i++) {\n      if (allsubs[i].name === \"vtimezone\") {\n        tzid = allsubs[i].getFirstProperty(\"tzid\").getFirstValue();\n        vtimezones[tzid] = allsubs[i];\n      } else {\n        properties = properties.concat(allsubs[i].getAllProperties());\n      }\n    } //create an object with one entry for each required tz\n\n\n    reqTzid = {};\n\n    for (i = 0; i < properties.length; i++) {\n      if (tzid = properties[i].getParameter(\"tzid\")) {\n        reqTzid[tzid] = true;\n      }\n    } //delete any vtimezones that are not on the reqTzid list.\n\n\n    for (i in vtimezones) {\n      if (vtimezones.hasOwnProperty(i) && !reqTzid[i]) {\n        vcal.removeSubcomponent(vtimezones[i]);\n      }\n    } //create any missing, but registered timezones\n\n\n    for (i in reqTzid) {\n      if (reqTzid.hasOwnProperty(i) && !vtimezones[i] && ICAL.TimezoneService.has(i)) {\n        vcal.addSubcomponent(ICAL.TimezoneService.get(i).component);\n      }\n    }\n\n    return vcal;\n  },\n\n  /**\r\n   * Checks if the given type is of the number type and also NaN.\r\n   *\r\n   * @param {Number} number     The number to check\r\n   * @return {Boolean}          True, if the number is strictly NaN\r\n   */\n  isStrictlyNaN: function isStrictlyNaN(number) {\n    return typeof number === 'number' && isNaN(number);\n  },\n\n  /**\r\n   * Parses a string value that is expected to be an integer, when the valid is\r\n   * not an integer throws a decoration error.\r\n   *\r\n   * @param {String} string     Raw string input\r\n   * @return {Number}           Parsed integer\r\n   */\n  strictParseInt: function strictParseInt(string) {\n    var result = parseInt(string, 10);\n\n    if (ICAL.helpers.isStrictlyNaN(result)) {\n      throw new Error('Could not extract integer from \"' + string + '\"');\n    }\n\n    return result;\n  },\n\n  /**\r\n   * Creates or returns a class instance of a given type with the initialization\r\n   * data if the data is not already an instance of the given type.\r\n   *\r\n   * @example\r\n   * var time = new ICAL.Time(...);\r\n   * var result = ICAL.helpers.formatClassType(time, ICAL.Time);\r\n   *\r\n   * (result instanceof ICAL.Time)\r\n   * // => true\r\n   *\r\n   * result = ICAL.helpers.formatClassType({}, ICAL.Time);\r\n   * (result isntanceof ICAL.Time)\r\n   * // => true\r\n   *\r\n   *\r\n   * @param {Object} data       object initialization data\r\n   * @param {Object} type       object type (like ICAL.Time)\r\n   * @return {?}                An instance of the found type.\r\n   */\n  formatClassType: function formatClassType(data, type) {\n    if (typeof data === 'undefined') {\n      return undefined;\n    }\n\n    if (data instanceof type) {\n      return data;\n    }\n\n    return new type(data);\n  },\n\n  /**\r\n   * Identical to indexOf but will only match values when they are not preceded\r\n   * by a backslash character.\r\n   *\r\n   * @param {String} buffer         String to search\r\n   * @param {String} search         Value to look for\r\n   * @param {Number} pos            Start position\r\n   * @return {Number}               The position, or -1 if not found\r\n   */\n  unescapedIndexOf: function unescapedIndexOf(buffer, search, pos) {\n    while ((pos = buffer.indexOf(search, pos)) !== -1) {\n      if (pos > 0 && buffer[pos - 1] === '\\\\') {\n        pos += 1;\n      } else {\n        return pos;\n      }\n    }\n\n    return -1;\n  },\n\n  /**\r\n   * Find the index for insertion using binary search.\r\n   *\r\n   * @param {Array} list            The list to search\r\n   * @param {?} seekVal             The value to insert\r\n   * @param {function(?,?)} cmpfunc The comparison func, that can\r\n   *                                  compare two seekVals\r\n   * @return {Number}               The insert position\r\n   */\n  binsearchInsert: function binsearchInsert(list, seekVal, cmpfunc) {\n    if (!list.length) return 0;\n    var low = 0,\n        high = list.length - 1,\n        mid,\n        cmpval;\n\n    while (low <= high) {\n      mid = low + Math.floor((high - low) / 2);\n      cmpval = cmpfunc(seekVal, list[mid]);\n      if (cmpval < 0) high = mid - 1;else if (cmpval > 0) low = mid + 1;else break;\n    }\n\n    if (cmpval < 0) return mid; // insertion is displacing, so use mid outright.\n    else if (cmpval > 0) return mid + 1;else return mid;\n  },\n\n  /**\r\n   * Convenience function for debug output\r\n   * @private\r\n   */\n  dumpn:\n  /* istanbul ignore next */\n  function dumpn() {\n    if (!ICAL.debug) {\n      return;\n    }\n\n    if (typeof console !== 'undefined' && 'log' in console) {\n      ICAL.helpers.dumpn = function consoleDumpn(input) {\n        console.log(input);\n      };\n    } else {\n      ICAL.helpers.dumpn = function geckoDumpn(input) {\n        dump(input + '\\n');\n      };\n    }\n\n    ICAL.helpers.dumpn(arguments[0]);\n  },\n\n  /**\r\n   * Clone the passed object or primitive. By default a shallow clone will be\r\n   * executed.\r\n   *\r\n   * @param {*} aSrc            The thing to clone\r\n   * @param {Boolean=} aDeep    If true, a deep clone will be performed\r\n   * @return {*}                The copy of the thing\r\n   */\n  clone: function clone(aSrc, aDeep) {\n    if (!aSrc || typeof aSrc != \"object\") {\n      return aSrc;\n    } else if (aSrc instanceof Date) {\n      return new Date(aSrc.getTime());\n    } else if (\"clone\" in aSrc) {\n      return aSrc.clone();\n    } else if (Array.isArray(aSrc)) {\n      var arr = [];\n\n      for (var i = 0; i < aSrc.length; i++) {\n        arr.push(aDeep ? ICAL.helpers.clone(aSrc[i], true) : aSrc[i]);\n      }\n\n      return arr;\n    } else {\n      var obj = {};\n\n      for (var name in aSrc) {\n        // uses prototype method to allow use of Object.create(null);\n\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(aSrc, name)) {\n          if (aDeep) {\n            obj[name] = ICAL.helpers.clone(aSrc[name], true);\n          } else {\n            obj[name] = aSrc[name];\n          }\n        }\n      }\n\n      return obj;\n    }\n  },\n\n  /**\r\n   * Performs iCalendar line folding. A line ending character is inserted and\r\n   * the next line begins with a whitespace.\r\n   *\r\n   * @example\r\n   * SUMMARY:This line will be fold\r\n   *  ed right in the middle of a word.\r\n   *\r\n   * @param {String} aLine      The line to fold\r\n   * @return {String}           The folded line\r\n   */\n  foldline: function foldline(aLine) {\n    var result = \"\";\n    var line = aLine || \"\";\n\n    while (line.length) {\n      result += ICAL.newLineChar + \" \" + line.substr(0, ICAL.foldLength);\n      line = line.substr(ICAL.foldLength);\n    }\n\n    return result.substr(ICAL.newLineChar.length + 1);\n  },\n\n  /**\r\n   * Pads the given string or number with zeros so it will have at least two\r\n   * characters.\r\n   *\r\n   * @param {String|Number} data    The string or number to pad\r\n   * @return {String}               The number padded as a string\r\n   */\n  pad2: function pad(data) {\n    if (typeof data !== 'string') {\n      // handle fractions.\n      if (typeof data === 'number') {\n        data = parseInt(data);\n      }\n\n      data = String(data);\n    }\n\n    var len = data.length;\n\n    switch (len) {\n      case 0:\n        return '00';\n\n      case 1:\n        return '0' + data;\n\n      default:\n        return data;\n    }\n  },\n\n  /**\r\n   * Truncates the given number, correctly handling negative numbers.\r\n   *\r\n   * @param {Number} number     The number to truncate\r\n   * @return {Number}           The truncated number\r\n   */\n  trunc: function trunc(number) {\n    return number < 0 ? Math.ceil(number) : Math.floor(number);\n  },\n\n  /**\r\n   * Poor-man's cross-browser inheritance for JavaScript. Doesn't support all\r\n   * the features, but enough for our usage.\r\n   *\r\n   * @param {Function} base     The base class constructor function.\r\n   * @param {Function} child    The child class constructor function.\r\n   * @param {Object} extra      Extends the prototype with extra properties\r\n   *                              and methods\r\n   */\n  inherits: function inherits(base, child, extra) {\n    function F() {}\n\n    F.prototype = base.prototype;\n    child.prototype = new F();\n\n    if (extra) {\n      ICAL.helpers.extend(extra, child.prototype);\n    }\n  },\n\n  /**\r\n   * Poor-man's cross-browser object extension. Doesn't support all the\r\n   * features, but enough for our usage. Note that the target's properties are\r\n   * not overwritten with the source properties.\r\n   *\r\n   * @example\r\n   * var child = ICAL.helpers.extend(parent, {\r\n   *   \"bar\": 123\r\n   * });\r\n   *\r\n   * @param {Object} source     The object to extend\r\n   * @param {Object} target     The object to extend with\r\n   * @return {Object}           Returns the target.\r\n   */\n  extend: function extend(source, target) {\n    for (var key in source) {\n      var descr = Object.getOwnPropertyDescriptor(source, key);\n\n      if (descr && !Object.getOwnPropertyDescriptor(target, key)) {\n        Object.defineProperty(target, key, descr);\n      }\n    }\n\n    return target;\n  }\n};\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/** @namespace ICAL */\n\n/**\r\n * This symbol is further described later on\r\n * @ignore\r\n */\n\nICAL.design = function () {\n  'use strict';\n\n  var FROM_ICAL_NEWLINE = /\\\\\\\\|\\\\;|\\\\,|\\\\[Nn]/g;\n  var TO_ICAL_NEWLINE = /\\\\|;|,|\\n/g;\n  var FROM_VCARD_NEWLINE = /\\\\\\\\|\\\\,|\\\\[Nn]/g;\n  var TO_VCARD_NEWLINE = /\\\\|,|\\n/g;\n\n  function createTextType(fromNewline, toNewline) {\n    var result = {\n      matches: /.*/,\n      fromICAL: function fromICAL(aValue, structuredEscape) {\n        return replaceNewline(aValue, fromNewline, structuredEscape);\n      },\n      toICAL: function toICAL(aValue, structuredEscape) {\n        var regEx = toNewline;\n        if (structuredEscape) regEx = new RegExp(regEx.source + '|' + structuredEscape);\n        return aValue.replace(regEx, function (str) {\n          switch (str) {\n            case \"\\\\\":\n              return \"\\\\\\\\\";\n\n            case \";\":\n              return \"\\\\;\";\n\n            case \",\":\n              return \"\\\\,\";\n\n            case \"\\n\":\n              return \"\\\\n\";\n\n            /* istanbul ignore next */\n\n            default:\n              return str;\n          }\n        });\n      }\n    };\n    return result;\n  } // default types used multiple times\n\n\n  var DEFAULT_TYPE_TEXT = {\n    defaultType: \"text\"\n  };\n  var DEFAULT_TYPE_TEXT_MULTI = {\n    defaultType: \"text\",\n    multiValue: \",\"\n  };\n  var DEFAULT_TYPE_TEXT_STRUCTURED = {\n    defaultType: \"text\",\n    structuredValue: \";\"\n  };\n  var DEFAULT_TYPE_INTEGER = {\n    defaultType: \"integer\"\n  };\n  var DEFAULT_TYPE_DATETIME_DATE = {\n    defaultType: \"date-time\",\n    allowedTypes: [\"date-time\", \"date\"]\n  };\n  var DEFAULT_TYPE_DATETIME = {\n    defaultType: \"date-time\"\n  };\n  var DEFAULT_TYPE_URI = {\n    defaultType: \"uri\"\n  };\n  var DEFAULT_TYPE_UTCOFFSET = {\n    defaultType: \"utc-offset\"\n  };\n  var DEFAULT_TYPE_RECUR = {\n    defaultType: \"recur\"\n  };\n  var DEFAULT_TYPE_DATE_ANDOR_TIME = {\n    defaultType: \"date-and-or-time\",\n    allowedTypes: [\"date-time\", \"date\", \"text\"]\n  };\n\n  function replaceNewlineReplace(string) {\n    switch (string) {\n      case \"\\\\\\\\\":\n        return \"\\\\\";\n\n      case \"\\\\;\":\n        return \";\";\n\n      case \"\\\\,\":\n        return \",\";\n\n      case \"\\\\n\":\n      case \"\\\\N\":\n        return \"\\n\";\n\n      /* istanbul ignore next */\n\n      default:\n        return string;\n    }\n  }\n\n  function replaceNewline(value, newline, structuredEscape) {\n    // avoid regex when possible.\n    if (value.indexOf('\\\\') === -1) {\n      return value;\n    }\n\n    if (structuredEscape) newline = new RegExp(newline.source + '|\\\\\\\\' + structuredEscape);\n    return value.replace(newline, replaceNewlineReplace);\n  }\n\n  var commonProperties = {\n    \"categories\": DEFAULT_TYPE_TEXT_MULTI,\n    \"url\": DEFAULT_TYPE_URI,\n    \"version\": DEFAULT_TYPE_TEXT,\n    \"uid\": DEFAULT_TYPE_TEXT\n  };\n  var commonValues = {\n    \"boolean\": {\n      values: [\"TRUE\", \"FALSE\"],\n      fromICAL: function fromICAL(aValue) {\n        switch (aValue) {\n          case 'TRUE':\n            return true;\n\n          case 'FALSE':\n            return false;\n\n          default:\n            //TODO: parser warning\n            return false;\n        }\n      },\n      toICAL: function toICAL(aValue) {\n        if (aValue) {\n          return 'TRUE';\n        }\n\n        return 'FALSE';\n      }\n    },\n    float: {\n      matches: /^[+-]?\\d+\\.\\d+$/,\n      fromICAL: function fromICAL(aValue) {\n        var parsed = parseFloat(aValue);\n\n        if (ICAL.helpers.isStrictlyNaN(parsed)) {\n          // TODO: parser warning\n          return 0.0;\n        }\n\n        return parsed;\n      },\n      toICAL: function toICAL(aValue) {\n        return String(aValue);\n      }\n    },\n    integer: {\n      fromICAL: function fromICAL(aValue) {\n        var parsed = parseInt(aValue);\n\n        if (ICAL.helpers.isStrictlyNaN(parsed)) {\n          return 0;\n        }\n\n        return parsed;\n      },\n      toICAL: function toICAL(aValue) {\n        return String(aValue);\n      }\n    },\n    \"utc-offset\": {\n      toICAL: function toICAL(aValue) {\n        if (aValue.length < 7) {\n          // no seconds\n          // -0500\n          return aValue.substr(0, 3) + aValue.substr(4, 2);\n        } else {\n          // seconds\n          // -050000\n          return aValue.substr(0, 3) + aValue.substr(4, 2) + aValue.substr(7, 2);\n        }\n      },\n      fromICAL: function fromICAL(aValue) {\n        if (aValue.length < 6) {\n          // no seconds\n          // -05:00\n          return aValue.substr(0, 3) + ':' + aValue.substr(3, 2);\n        } else {\n          // seconds\n          // -05:00:00\n          return aValue.substr(0, 3) + ':' + aValue.substr(3, 2) + ':' + aValue.substr(5, 2);\n        }\n      },\n      decorate: function decorate(aValue) {\n        return ICAL.UtcOffset.fromString(aValue);\n      },\n      undecorate: function undecorate(aValue) {\n        return aValue.toString();\n      }\n    }\n  };\n  var icalParams = {\n    // Although the syntax is DQUOTE uri DQUOTE, I don't think we should\n    // enfoce anything aside from it being a valid content line.\n    //\n    // At least some params require - if multi values are used - DQUOTEs\n    // for each of its values - e.g. delegated-from=\"uri1\",\"uri2\"\n    // To indicate this, I introduced the new k/v pair\n    // multiValueSeparateDQuote: true\n    //\n    // \"ALTREP\": { ... },\n    // CN just wants a param-value\n    // \"CN\": { ... }\n    \"cutype\": {\n      values: [\"INDIVIDUAL\", \"GROUP\", \"RESOURCE\", \"ROOM\", \"UNKNOWN\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"delegated-from\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    \"delegated-to\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    // \"DIR\": { ... }, // See ALTREP\n    \"encoding\": {\n      values: [\"8BIT\", \"BASE64\"]\n    },\n    // \"FMTTYPE\": { ... }, // See ALTREP\n    \"fbtype\": {\n      values: [\"FREE\", \"BUSY\", \"BUSY-UNAVAILABLE\", \"BUSY-TENTATIVE\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    // \"LANGUAGE\": { ... }, // See ALTREP\n    \"member\": {\n      valueType: \"cal-address\",\n      multiValue: \",\",\n      multiValueSeparateDQuote: true\n    },\n    \"partstat\": {\n      // TODO These values are actually different per-component\n      values: [\"NEEDS-ACTION\", \"ACCEPTED\", \"DECLINED\", \"TENTATIVE\", \"DELEGATED\", \"COMPLETED\", \"IN-PROCESS\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"range\": {\n      values: [\"THISLANDFUTURE\"]\n    },\n    \"related\": {\n      values: [\"START\", \"END\"]\n    },\n    \"reltype\": {\n      values: [\"PARENT\", \"CHILD\", \"SIBLING\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"role\": {\n      values: [\"REQ-PARTICIPANT\", \"CHAIR\", \"OPT-PARTICIPANT\", \"NON-PARTICIPANT\"],\n      allowXName: true,\n      allowIanaToken: true\n    },\n    \"rsvp\": {\n      values: [\"TRUE\", \"FALSE\"]\n    },\n    \"sent-by\": {\n      valueType: \"cal-address\"\n    },\n    \"tzid\": {\n      matches: /^\\//\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"binary\", \"boolean\", \"cal-address\", \"date\", \"date-time\", \"duration\", \"float\", \"integer\", \"period\", \"recur\", \"text\", \"time\", \"uri\", \"utc-offset\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  }; // When adding a value here, be sure to add it to the parameter types!\n\n  var icalValues = ICAL.helpers.extend(commonValues, {\n    text: createTextType(FROM_ICAL_NEWLINE, TO_ICAL_NEWLINE),\n    uri: {// TODO\n\n      /* ... */\n    },\n    \"binary\": {\n      decorate: function decorate(aString) {\n        return ICAL.Binary.fromString(aString);\n      },\n      undecorate: function undecorate(aBinary) {\n        return aBinary.toString();\n      }\n    },\n    \"cal-address\": {// needs to be an uri\n    },\n    \"date\": {\n      decorate: function decorate(aValue, aProp) {\n        if (design.strict) {\n          return ICAL.Time.fromDateString(aValue, aProp);\n        } else {\n          return ICAL.Time.fromString(aValue, aProp);\n        }\n      },\n\n      /**\r\n       * undecorates a time object.\r\n       */\n      undecorate: function undecorate(aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function fromICAL(aValue) {\n        // from: 20120901\n        // to: 2012-09-01\n        if (!design.strict && aValue.length >= 15) {\n          // This is probably a date-time, e.g. 20120901T130000Z\n          return icalValues[\"date-time\"].fromICAL(aValue);\n        } else {\n          return aValue.substr(0, 4) + '-' + aValue.substr(4, 2) + '-' + aValue.substr(6, 2);\n        }\n      },\n      toICAL: function toICAL(aValue) {\n        // from: 2012-09-01\n        // to: 20120901\n        var len = aValue.length;\n\n        if (len == 10) {\n          return aValue.substr(0, 4) + aValue.substr(5, 2) + aValue.substr(8, 2);\n        } else if (len >= 19) {\n          return icalValues[\"date-time\"].toICAL(aValue);\n        } else {\n          //TODO: serialize warning?\n          return aValue;\n        }\n      }\n    },\n    \"date-time\": {\n      fromICAL: function fromICAL(aValue) {\n        // from: 20120901T130000\n        // to: 2012-09-01T13:00:00\n        if (!design.strict && aValue.length == 8) {\n          // This is probably a date, e.g. 20120901\n          return icalValues.date.fromICAL(aValue);\n        } else {\n          var result = aValue.substr(0, 4) + '-' + aValue.substr(4, 2) + '-' + aValue.substr(6, 2) + 'T' + aValue.substr(9, 2) + ':' + aValue.substr(11, 2) + ':' + aValue.substr(13, 2);\n\n          if (aValue[15] && aValue[15] === 'Z') {\n            result += 'Z';\n          }\n\n          return result;\n        }\n      },\n      toICAL: function toICAL(aValue) {\n        // from: 2012-09-01T13:00:00\n        // to: 20120901T130000\n        var len = aValue.length;\n\n        if (len == 10 && !design.strict) {\n          return icalValues.date.toICAL(aValue);\n        } else if (len >= 19) {\n          var result = aValue.substr(0, 4) + aValue.substr(5, 2) + // grab the (DDTHH) segment\n          aValue.substr(8, 5) + // MM\n          aValue.substr(14, 2) + // SS\n          aValue.substr(17, 2);\n\n          if (aValue[19] && aValue[19] === 'Z') {\n            result += 'Z';\n          }\n\n          return result;\n        } else {\n          // TODO: error\n          return aValue;\n        }\n      },\n      decorate: function decorate(aValue, aProp) {\n        if (design.strict) {\n          return ICAL.Time.fromDateTimeString(aValue, aProp);\n        } else {\n          return ICAL.Time.fromString(aValue, aProp);\n        }\n      },\n      undecorate: function undecorate(aValue) {\n        return aValue.toString();\n      }\n    },\n    duration: {\n      decorate: function decorate(aValue) {\n        return ICAL.Duration.fromString(aValue);\n      },\n      undecorate: function undecorate(aValue) {\n        return aValue.toString();\n      }\n    },\n    period: {\n      fromICAL: function fromICAL(string) {\n        var parts = string.split('/');\n        parts[0] = icalValues['date-time'].fromICAL(parts[0]);\n\n        if (!ICAL.Duration.isValueString(parts[1])) {\n          parts[1] = icalValues['date-time'].fromICAL(parts[1]);\n        }\n\n        return parts;\n      },\n      toICAL: function toICAL(parts) {\n        if (!design.strict && parts[0].length == 10) {\n          parts[0] = icalValues.date.toICAL(parts[0]);\n        } else {\n          parts[0] = icalValues['date-time'].toICAL(parts[0]);\n        }\n\n        if (!ICAL.Duration.isValueString(parts[1])) {\n          if (!design.strict && parts[1].length == 10) {\n            parts[1] = icalValues.date.toICAL(parts[1]);\n          } else {\n            parts[1] = icalValues['date-time'].toICAL(parts[1]);\n          }\n        }\n\n        return parts.join(\"/\");\n      },\n      decorate: function decorate(aValue, aProp) {\n        return ICAL.Period.fromJSON(aValue, aProp, !design.strict);\n      },\n      undecorate: function undecorate(aValue) {\n        return aValue.toJSON();\n      }\n    },\n    recur: {\n      fromICAL: function fromICAL(string) {\n        return ICAL.Recur._stringToData(string, true);\n      },\n      toICAL: function toICAL(data) {\n        var str = \"\";\n\n        for (var k in data) {\n          /* istanbul ignore if */\n          if (!Object.prototype.hasOwnProperty.call(data, k)) {\n            continue;\n          }\n\n          var val = data[k];\n\n          if (k == \"until\") {\n            if (val.length > 10) {\n              val = icalValues['date-time'].toICAL(val);\n            } else {\n              val = icalValues.date.toICAL(val);\n            }\n          } else if (k == \"wkst\") {\n            if (typeof val === 'number') {\n              val = ICAL.Recur.numericDayToIcalDay(val);\n            }\n          } else if (Array.isArray(val)) {\n            val = val.join(\",\");\n          }\n\n          str += k.toUpperCase() + \"=\" + val + \";\";\n        }\n\n        return str.substr(0, str.length - 1);\n      },\n      decorate: function decorate(aValue) {\n        return ICAL.Recur.fromData(aValue);\n      },\n      undecorate: function undecorate(aRecur) {\n        return aRecur.toJSON();\n      }\n    },\n    time: {\n      fromICAL: function fromICAL(aValue) {\n        // from: MMHHSS(Z)?\n        // to: HH:MM:SS(Z)?\n        if (aValue.length < 6) {\n          // TODO: parser exception?\n          return aValue;\n        } // HH::MM::SSZ?\n\n\n        var result = aValue.substr(0, 2) + ':' + aValue.substr(2, 2) + ':' + aValue.substr(4, 2);\n\n        if (aValue[6] === 'Z') {\n          result += 'Z';\n        }\n\n        return result;\n      },\n      toICAL: function toICAL(aValue) {\n        // from: HH:MM:SS(Z)?\n        // to: MMHHSS(Z)?\n        if (aValue.length < 8) {\n          //TODO: error\n          return aValue;\n        }\n\n        var result = aValue.substr(0, 2) + aValue.substr(3, 2) + aValue.substr(6, 2);\n\n        if (aValue[8] === 'Z') {\n          result += 'Z';\n        }\n\n        return result;\n      }\n    }\n  });\n  var icalProperties = ICAL.helpers.extend(commonProperties, {\n    \"action\": DEFAULT_TYPE_TEXT,\n    \"attach\": {\n      defaultType: \"uri\"\n    },\n    \"attendee\": {\n      defaultType: \"cal-address\"\n    },\n    \"calscale\": DEFAULT_TYPE_TEXT,\n    \"class\": DEFAULT_TYPE_TEXT,\n    \"comment\": DEFAULT_TYPE_TEXT,\n    \"completed\": DEFAULT_TYPE_DATETIME,\n    \"contact\": DEFAULT_TYPE_TEXT,\n    \"created\": DEFAULT_TYPE_DATETIME,\n    \"description\": DEFAULT_TYPE_TEXT,\n    \"dtend\": DEFAULT_TYPE_DATETIME_DATE,\n    \"dtstamp\": DEFAULT_TYPE_DATETIME,\n    \"dtstart\": DEFAULT_TYPE_DATETIME_DATE,\n    \"due\": DEFAULT_TYPE_DATETIME_DATE,\n    \"duration\": {\n      defaultType: \"duration\"\n    },\n    \"exdate\": {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      multiValue: ','\n    },\n    \"exrule\": DEFAULT_TYPE_RECUR,\n    \"freebusy\": {\n      defaultType: \"period\",\n      multiValue: \",\"\n    },\n    \"geo\": {\n      defaultType: \"float\",\n      structuredValue: \";\"\n    },\n    \"last-modified\": DEFAULT_TYPE_DATETIME,\n    \"location\": DEFAULT_TYPE_TEXT,\n    \"method\": DEFAULT_TYPE_TEXT,\n    \"organizer\": {\n      defaultType: \"cal-address\"\n    },\n    \"percent-complete\": DEFAULT_TYPE_INTEGER,\n    \"priority\": DEFAULT_TYPE_INTEGER,\n    \"prodid\": DEFAULT_TYPE_TEXT,\n    \"related-to\": DEFAULT_TYPE_TEXT,\n    \"repeat\": DEFAULT_TYPE_INTEGER,\n    \"rdate\": {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\", \"period\"],\n      multiValue: ',',\n      detectType: function detectType(string) {\n        if (string.indexOf('/') !== -1) {\n          return 'period';\n        }\n\n        return string.indexOf('T') === -1 ? 'date' : 'date-time';\n      }\n    },\n    \"recurrence-id\": DEFAULT_TYPE_DATETIME_DATE,\n    \"resources\": DEFAULT_TYPE_TEXT_MULTI,\n    \"request-status\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"rrule\": DEFAULT_TYPE_RECUR,\n    \"sequence\": DEFAULT_TYPE_INTEGER,\n    \"status\": DEFAULT_TYPE_TEXT,\n    \"summary\": DEFAULT_TYPE_TEXT,\n    \"transp\": DEFAULT_TYPE_TEXT,\n    \"trigger\": {\n      defaultType: \"duration\",\n      allowedTypes: [\"duration\", \"date-time\"]\n    },\n    \"tzoffsetfrom\": DEFAULT_TYPE_UTCOFFSET,\n    \"tzoffsetto\": DEFAULT_TYPE_UTCOFFSET,\n    \"tzurl\": DEFAULT_TYPE_URI,\n    \"tzid\": DEFAULT_TYPE_TEXT,\n    \"tzname\": DEFAULT_TYPE_TEXT\n  }); // When adding a value here, be sure to add it to the parameter types!\n\n  var vcardValues = ICAL.helpers.extend(commonValues, {\n    text: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\n    uri: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\n    date: {\n      decorate: function decorate(aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date\");\n      },\n      undecorate: function undecorate(aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function fromICAL(aValue) {\n        if (aValue.length == 8) {\n          return icalValues.date.fromICAL(aValue);\n        } else if (aValue[0] == '-' && aValue.length == 6) {\n          return aValue.substr(0, 4) + '-' + aValue.substr(4);\n        } else {\n          return aValue;\n        }\n      },\n      toICAL: function toICAL(aValue) {\n        if (aValue.length == 10) {\n          return icalValues.date.toICAL(aValue);\n        } else if (aValue[0] == '-' && aValue.length == 7) {\n          return aValue.substr(0, 4) + aValue.substr(5);\n        } else {\n          return aValue;\n        }\n      }\n    },\n    time: {\n      decorate: function decorate(aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(\"T\" + aValue, \"time\");\n      },\n      undecorate: function undecorate(aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function fromICAL(aValue) {\n        var splitzone = vcardValues.time._splitZone(aValue, true);\n\n        var zone = splitzone[0],\n            value = splitzone[1]; //console.log(\"SPLIT: \",splitzone);\n\n        if (value.length == 6) {\n          value = value.substr(0, 2) + ':' + value.substr(2, 2) + ':' + value.substr(4, 2);\n        } else if (value.length == 4 && value[0] != '-') {\n          value = value.substr(0, 2) + ':' + value.substr(2, 2);\n        } else if (value.length == 5) {\n          value = value.substr(0, 3) + ':' + value.substr(3, 2);\n        }\n\n        if (zone.length == 5 && (zone[0] == '-' || zone[0] == '+')) {\n          zone = zone.substr(0, 3) + ':' + zone.substr(3);\n        }\n\n        return value + zone;\n      },\n      toICAL: function toICAL(aValue) {\n        var splitzone = vcardValues.time._splitZone(aValue);\n\n        var zone = splitzone[0],\n            value = splitzone[1];\n\n        if (value.length == 8) {\n          value = value.substr(0, 2) + value.substr(3, 2) + value.substr(6, 2);\n        } else if (value.length == 5 && value[0] != '-') {\n          value = value.substr(0, 2) + value.substr(3, 2);\n        } else if (value.length == 6) {\n          value = value.substr(0, 3) + value.substr(4, 2);\n        }\n\n        if (zone.length == 6 && (zone[0] == '-' || zone[0] == '+')) {\n          zone = zone.substr(0, 3) + zone.substr(4);\n        }\n\n        return value + zone;\n      },\n      _splitZone: function _splitZone(aValue, isFromIcal) {\n        var lastChar = aValue.length - 1;\n        var signChar = aValue.length - (isFromIcal ? 5 : 6);\n        var sign = aValue[signChar];\n        var zone, value;\n\n        if (aValue[lastChar] == 'Z') {\n          zone = aValue[lastChar];\n          value = aValue.substr(0, lastChar);\n        } else if (aValue.length > 6 && (sign == '-' || sign == '+')) {\n          zone = aValue.substr(signChar);\n          value = aValue.substr(0, signChar);\n        } else {\n          zone = \"\";\n          value = aValue;\n        }\n\n        return [zone, value];\n      }\n    },\n    \"date-time\": {\n      decorate: function decorate(aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date-time\");\n      },\n      undecorate: function undecorate(aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function fromICAL(aValue) {\n        return vcardValues['date-and-or-time'].fromICAL(aValue);\n      },\n      toICAL: function toICAL(aValue) {\n        return vcardValues['date-and-or-time'].toICAL(aValue);\n      }\n    },\n    \"date-and-or-time\": {\n      decorate: function decorate(aValue) {\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date-and-or-time\");\n      },\n      undecorate: function undecorate(aValue) {\n        return aValue.toString();\n      },\n      fromICAL: function fromICAL(aValue) {\n        var parts = aValue.split('T');\n        return (parts[0] ? vcardValues.date.fromICAL(parts[0]) : '') + (parts[1] ? 'T' + vcardValues.time.fromICAL(parts[1]) : '');\n      },\n      toICAL: function toICAL(aValue) {\n        var parts = aValue.split('T');\n        return vcardValues.date.toICAL(parts[0]) + (parts[1] ? 'T' + vcardValues.time.toICAL(parts[1]) : '');\n      }\n    },\n    timestamp: icalValues['date-time'],\n    \"language-tag\": {\n      matches: /^[a-zA-Z0-9-]+$/ // Could go with a more strict regex here\n\n    }\n  });\n  var vcardParams = {\n    \"type\": {\n      valueType: \"text\",\n      multiValue: \",\"\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"text\", \"uri\", \"date\", \"time\", \"date-time\", \"date-and-or-time\", \"timestamp\", \"boolean\", \"integer\", \"float\", \"utc-offset\", \"language-tag\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  };\n  var vcardProperties = ICAL.helpers.extend(commonProperties, {\n    \"adr\": {\n      defaultType: \"text\",\n      structuredValue: \";\",\n      multiValue: \",\"\n    },\n    \"anniversary\": DEFAULT_TYPE_DATE_ANDOR_TIME,\n    \"bday\": DEFAULT_TYPE_DATE_ANDOR_TIME,\n    \"caladruri\": DEFAULT_TYPE_URI,\n    \"caluri\": DEFAULT_TYPE_URI,\n    \"clientpidmap\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"email\": DEFAULT_TYPE_TEXT,\n    \"fburl\": DEFAULT_TYPE_URI,\n    \"fn\": DEFAULT_TYPE_TEXT,\n    \"gender\": DEFAULT_TYPE_TEXT_STRUCTURED,\n    \"geo\": DEFAULT_TYPE_URI,\n    \"impp\": DEFAULT_TYPE_URI,\n    \"key\": DEFAULT_TYPE_URI,\n    \"kind\": DEFAULT_TYPE_TEXT,\n    \"lang\": {\n      defaultType: \"language-tag\"\n    },\n    \"logo\": DEFAULT_TYPE_URI,\n    \"member\": DEFAULT_TYPE_URI,\n    \"n\": {\n      defaultType: \"text\",\n      structuredValue: \";\",\n      multiValue: \",\"\n    },\n    \"nickname\": DEFAULT_TYPE_TEXT_MULTI,\n    \"note\": DEFAULT_TYPE_TEXT,\n    \"org\": {\n      defaultType: \"text\",\n      structuredValue: \";\"\n    },\n    \"photo\": DEFAULT_TYPE_URI,\n    \"related\": DEFAULT_TYPE_URI,\n    \"rev\": {\n      defaultType: \"timestamp\"\n    },\n    \"role\": DEFAULT_TYPE_TEXT,\n    \"sound\": DEFAULT_TYPE_URI,\n    \"source\": DEFAULT_TYPE_URI,\n    \"tel\": {\n      defaultType: \"uri\",\n      allowedTypes: [\"uri\", \"text\"]\n    },\n    \"title\": DEFAULT_TYPE_TEXT,\n    \"tz\": {\n      defaultType: \"text\",\n      allowedTypes: [\"text\", \"utc-offset\", \"uri\"]\n    },\n    \"xml\": DEFAULT_TYPE_TEXT\n  });\n  var vcard3Values = ICAL.helpers.extend(commonValues, {\n    binary: icalValues.binary,\n    date: vcardValues.date,\n    \"date-time\": vcardValues[\"date-time\"],\n    \"phone-number\": {// TODO\n\n      /* ... */\n    },\n    uri: icalValues.uri,\n    text: icalValues.text,\n    time: icalValues.time,\n    vcard: icalValues.text,\n    \"utc-offset\": {\n      toICAL: function toICAL(aValue) {\n        return aValue.substr(0, 7);\n      },\n      fromICAL: function fromICAL(aValue) {\n        return aValue.substr(0, 7);\n      },\n      decorate: function decorate(aValue) {\n        return ICAL.UtcOffset.fromString(aValue);\n      },\n      undecorate: function undecorate(aValue) {\n        return aValue.toString();\n      }\n    }\n  });\n  var vcard3Params = {\n    \"type\": {\n      valueType: \"text\",\n      multiValue: \",\"\n    },\n    \"value\": {\n      // since the value here is a 'type' lowercase is used.\n      values: [\"text\", \"uri\", \"date\", \"date-time\", \"phone-number\", \"time\", \"boolean\", \"integer\", \"float\", \"utc-offset\", \"vcard\", \"binary\"],\n      allowXName: true,\n      allowIanaToken: true\n    }\n  };\n  var vcard3Properties = ICAL.helpers.extend(commonProperties, {\n    fn: DEFAULT_TYPE_TEXT,\n    n: {\n      defaultType: \"text\",\n      structuredValue: \";\",\n      multiValue: \",\"\n    },\n    nickname: DEFAULT_TYPE_TEXT_MULTI,\n    photo: {\n      defaultType: \"binary\",\n      allowedTypes: [\"binary\", \"uri\"]\n    },\n    bday: {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      detectType: function detectType(string) {\n        return string.indexOf('T') === -1 ? 'date' : 'date-time';\n      }\n    },\n    adr: {\n      defaultType: \"text\",\n      structuredValue: \";\",\n      multiValue: \",\"\n    },\n    label: DEFAULT_TYPE_TEXT,\n    tel: {\n      defaultType: \"phone-number\"\n    },\n    email: DEFAULT_TYPE_TEXT,\n    mailer: DEFAULT_TYPE_TEXT,\n    tz: {\n      defaultType: \"utc-offset\",\n      allowedTypes: [\"utc-offset\", \"text\"]\n    },\n    geo: {\n      defaultType: \"float\",\n      structuredValue: \";\"\n    },\n    title: DEFAULT_TYPE_TEXT,\n    role: DEFAULT_TYPE_TEXT,\n    logo: {\n      defaultType: \"binary\",\n      allowedTypes: [\"binary\", \"uri\"]\n    },\n    agent: {\n      defaultType: \"vcard\",\n      allowedTypes: [\"vcard\", \"text\", \"uri\"]\n    },\n    org: DEFAULT_TYPE_TEXT_STRUCTURED,\n    note: DEFAULT_TYPE_TEXT_MULTI,\n    prodid: DEFAULT_TYPE_TEXT,\n    rev: {\n      defaultType: \"date-time\",\n      allowedTypes: [\"date-time\", \"date\"],\n      detectType: function detectType(string) {\n        return string.indexOf('T') === -1 ? 'date' : 'date-time';\n      }\n    },\n    \"sort-string\": DEFAULT_TYPE_TEXT,\n    sound: {\n      defaultType: \"binary\",\n      allowedTypes: [\"binary\", \"uri\"]\n    },\n    class: DEFAULT_TYPE_TEXT,\n    key: {\n      defaultType: \"binary\",\n      allowedTypes: [\"binary\", \"text\"]\n    }\n  });\n  /**\r\n   * iCalendar design set\r\n   * @type {ICAL.design.designSet}\r\n   */\n\n  var icalSet = {\n    value: icalValues,\n    param: icalParams,\n    property: icalProperties\n  };\n  /**\r\n   * vCard 4.0 design set\r\n   * @type {ICAL.design.designSet}\r\n   */\n\n  var vcardSet = {\n    value: vcardValues,\n    param: vcardParams,\n    property: vcardProperties\n  };\n  /**\r\n   * vCard 3.0 design set\r\n   * @type {ICAL.design.designSet}\r\n   */\n\n  var vcard3Set = {\n    value: vcard3Values,\n    param: vcard3Params,\n    property: vcard3Properties\n  };\n  /**\r\n   * The design data, used by the parser to determine types for properties and\r\n   * other metadata needed to produce correct jCard/jCal data.\r\n   *\r\n   * @alias ICAL.design\r\n   * @namespace\r\n   */\n\n  var design = {\n    /**\r\n     * A designSet describes value, parameter and property data. It is used by\r\n     * ther parser and stringifier in components and properties to determine they\r\n     * should be represented.\r\n     *\r\n     * @typedef {Object} designSet\r\n     * @memberOf ICAL.design\r\n     * @property {Object} value       Definitions for value types, keys are type names\r\n     * @property {Object} param       Definitions for params, keys are param names\r\n     * @property {Object} property    Defintions for properties, keys are property names\r\n     */\n\n    /**\r\n     * Can be set to false to make the parser more lenient.\r\n     */\n    strict: true,\n\n    /**\r\n     * The default set for new properties and components if none is specified.\r\n     * @type {ICAL.design.designSet}\r\n     */\n    defaultSet: icalSet,\n\n    /**\r\n     * The default type for unknown properties\r\n     * @type {String}\r\n     */\n    defaultType: 'unknown',\n\n    /**\r\n     * Holds the design set for known top-level components\r\n     *\r\n     * @type {Object}\r\n     * @property {ICAL.design.designSet} vcard       vCard VCARD\r\n     * @property {ICAL.design.designSet} vevent      iCalendar VEVENT\r\n     * @property {ICAL.design.designSet} vtodo       iCalendar VTODO\r\n     * @property {ICAL.design.designSet} vjournal    iCalendar VJOURNAL\r\n     * @property {ICAL.design.designSet} valarm      iCalendar VALARM\r\n     * @property {ICAL.design.designSet} vtimezone   iCalendar VTIMEZONE\r\n     * @property {ICAL.design.designSet} daylight    iCalendar DAYLIGHT\r\n     * @property {ICAL.design.designSet} standard    iCalendar STANDARD\r\n     *\r\n     * @example\r\n     * var propertyName = 'fn';\r\n     * var componentDesign = ICAL.design.components.vcard;\r\n     * var propertyDetails = componentDesign.property[propertyName];\r\n     * if (propertyDetails.defaultType == 'text') {\r\n     *   // Yep, sure is...\r\n     * }\r\n     */\n    components: {\n      vcard: vcardSet,\n      vcard3: vcard3Set,\n      vevent: icalSet,\n      vtodo: icalSet,\n      vjournal: icalSet,\n      valarm: icalSet,\n      vtimezone: icalSet,\n      daylight: icalSet,\n      standard: icalSet\n    },\n\n    /**\r\n     * The design set for iCalendar (rfc5545/rfc7265) components.\r\n     * @type {ICAL.design.designSet}\r\n     */\n    icalendar: icalSet,\n\n    /**\r\n     * The design set for vCard (rfc6350/rfc7095) components.\r\n     * @type {ICAL.design.designSet}\r\n     */\n    vcard: vcardSet,\n\n    /**\r\n     * The design set for vCard (rfc2425/rfc2426/rfc7095) components.\r\n     * @type {ICAL.design.designSet}\r\n     */\n    vcard3: vcard3Set,\n\n    /**\r\n     * Gets the design set for the given component name.\r\n     *\r\n     * @param {String} componentName        The name of the component\r\n     * @return {ICAL.design.designSet}      The design set for the component\r\n     */\n    getDesignSet: function getDesignSet(componentName) {\n      var isInDesign = componentName && componentName in design.components;\n      return isInDesign ? design.components[componentName] : design.defaultSet;\n    }\n  };\n  return design;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\r\n * Contains various functions to convert jCal and jCard data back into\r\n * iCalendar and vCard.\r\n * @namespace\r\n */\n\n\nICAL.stringify = function () {\n  'use strict';\n\n  var LINE_ENDING = '\\r\\n';\n  var DEFAULT_VALUE_TYPE = 'unknown';\n  var design = ICAL.design;\n  var helpers = ICAL.helpers;\n  /**\r\n   * Convert a full jCal/jCard array into a iCalendar/vCard string.\r\n   *\r\n   * @function ICAL.stringify\r\n   * @variation function\r\n   * @param {Array} jCal    The jCal/jCard document\r\n   * @return {String}       The stringified iCalendar/vCard document\r\n   */\n\n  function stringify(jCal) {\n    if (typeof jCal[0] == \"string\") {\n      // This is a single component\n      jCal = [jCal];\n    }\n\n    var i = 0;\n    var len = jCal.length;\n    var result = '';\n\n    for (; i < len; i++) {\n      result += stringify.component(jCal[i]) + LINE_ENDING;\n    }\n\n    return result;\n  }\n  /**\r\n   * Converts an jCal component array into a ICAL string.\r\n   * Recursive will resolve sub-components.\r\n   *\r\n   * Exact component/property order is not saved all\r\n   * properties will come before subcomponents.\r\n   *\r\n   * @function ICAL.stringify.component\r\n   * @param {Array} component\r\n   *        jCal/jCard fragment of a component\r\n   * @param {ICAL.design.designSet} designSet\r\n   *        The design data to use for this component\r\n   * @return {String}       The iCalendar/vCard string\r\n   */\n\n\n  stringify.component = function (component, designSet) {\n    var name = component[0].toUpperCase();\n    var result = 'BEGIN:' + name + LINE_ENDING;\n    var props = component[1];\n    var propIdx = 0;\n    var propLen = props.length;\n    var designSetName = component[0]; // rfc6350 requires that in vCard 4.0 the first component is the VERSION\n    // component with as value 4.0, note that 3.0 does not have this requirement.\n\n    if (designSetName === 'vcard' && component[1].length > 0 && !(component[1][0][0] === \"version\" && component[1][0][3] === \"4.0\")) {\n      designSetName = \"vcard3\";\n    }\n\n    designSet = designSet || design.getDesignSet(designSetName);\n\n    for (; propIdx < propLen; propIdx++) {\n      result += stringify.property(props[propIdx], designSet) + LINE_ENDING;\n    } // Ignore subcomponents if none exist, e.g. in vCard.\n\n\n    var comps = component[2] || [];\n    var compIdx = 0;\n    var compLen = comps.length;\n\n    for (; compIdx < compLen; compIdx++) {\n      result += stringify.component(comps[compIdx], designSet) + LINE_ENDING;\n    }\n\n    result += 'END:' + name;\n    return result;\n  };\n  /**\r\n   * Converts a single jCal/jCard property to a iCalendar/vCard string.\r\n   *\r\n   * @function ICAL.stringify.property\r\n   * @param {Array} property\r\n   *        jCal/jCard property array\r\n   * @param {ICAL.design.designSet} designSet\r\n   *        The design data to use for this property\r\n   * @param {Boolean} noFold\r\n   *        If true, the line is not folded\r\n   * @return {String}       The iCalendar/vCard string\r\n   */\n\n\n  stringify.property = function (property, designSet, noFold) {\n    var name = property[0].toUpperCase();\n    var jsName = property[0];\n    var params = property[1];\n    var line = name;\n    var paramName;\n\n    for (paramName in params) {\n      var value = params[paramName];\n      /* istanbul ignore else */\n\n      if (params.hasOwnProperty(paramName)) {\n        var multiValue = paramName in designSet.param && designSet.param[paramName].multiValue;\n\n        if (multiValue && Array.isArray(value)) {\n          if (designSet.param[paramName].multiValueSeparateDQuote) {\n            multiValue = '\"' + multiValue + '\"';\n          }\n\n          value = value.map(stringify._rfc6868Unescape);\n          value = stringify.multiValue(value, multiValue, \"unknown\", null, designSet);\n        } else {\n          value = stringify._rfc6868Unescape(value);\n        }\n\n        line += ';' + paramName.toUpperCase();\n        line += '=' + stringify.propertyValue(value);\n      }\n    }\n\n    if (property.length === 3) {\n      // If there are no values, we must assume a blank value\n      return line + ':';\n    }\n\n    var valueType = property[2];\n\n    if (!designSet) {\n      designSet = design.defaultSet;\n    }\n\n    var propDetails;\n    var multiValue = false;\n    var structuredValue = false;\n    var isDefault = false;\n\n    if (jsName in designSet.property) {\n      propDetails = designSet.property[jsName];\n\n      if ('multiValue' in propDetails) {\n        multiValue = propDetails.multiValue;\n      }\n\n      if ('structuredValue' in propDetails && Array.isArray(property[3])) {\n        structuredValue = propDetails.structuredValue;\n      }\n\n      if ('defaultType' in propDetails) {\n        if (valueType === propDetails.defaultType) {\n          isDefault = true;\n        }\n      } else {\n        if (valueType === DEFAULT_VALUE_TYPE) {\n          isDefault = true;\n        }\n      }\n    } else {\n      if (valueType === DEFAULT_VALUE_TYPE) {\n        isDefault = true;\n      }\n    } // push the VALUE property if type is not the default\n    // for the current property.\n\n\n    if (!isDefault) {\n      // value will never contain ;/:/, so we don't escape it here.\n      line += ';VALUE=' + valueType.toUpperCase();\n    }\n\n    line += ':';\n\n    if (multiValue && structuredValue) {\n      line += stringify.multiValue(property[3], structuredValue, valueType, multiValue, designSet, structuredValue);\n    } else if (multiValue) {\n      line += stringify.multiValue(property.slice(3), multiValue, valueType, null, designSet, false);\n    } else if (structuredValue) {\n      line += stringify.multiValue(property[3], structuredValue, valueType, null, designSet, structuredValue);\n    } else {\n      line += stringify.value(property[3], valueType, designSet, false);\n    }\n\n    return noFold ? line : ICAL.helpers.foldline(line);\n  };\n  /**\r\n   * Handles escaping of property values that may contain:\r\n   *\r\n   *    COLON (:), SEMICOLON (;), or COMMA (,)\r\n   *\r\n   * If any of the above are present the result is wrapped\r\n   * in double quotes.\r\n   *\r\n   * @function ICAL.stringify.propertyValue\r\n   * @param {String} value      Raw property value\r\n   * @return {String}           Given or escaped value when needed\r\n   */\n\n\n  stringify.propertyValue = function (value) {\n    if (helpers.unescapedIndexOf(value, ',') === -1 && helpers.unescapedIndexOf(value, ':') === -1 && helpers.unescapedIndexOf(value, ';') === -1) {\n      return value;\n    }\n\n    return '\"' + value + '\"';\n  };\n  /**\r\n   * Converts an array of ical values into a single\r\n   * string based on a type and a delimiter value (like \",\").\r\n   *\r\n   * @function ICAL.stringify.multiValue\r\n   * @param {Array} values      List of values to convert\r\n   * @param {String} delim      Used to join the values (\",\", \";\", \":\")\r\n   * @param {String} type       Lowecase ical value type\r\n   *        (like boolean, date-time, etc..)\r\n   * @param {?String} innerMulti If set, each value will again be processed\r\n   *        Used for structured values\r\n   * @param {ICAL.design.designSet} designSet\r\n   *        The design data to use for this property\r\n   *\r\n   * @return {String}           iCalendar/vCard string for value\r\n   */\n\n\n  stringify.multiValue = function (values, delim, type, innerMulti, designSet, structuredValue) {\n    var result = '';\n    var len = values.length;\n    var i = 0;\n\n    for (; i < len; i++) {\n      if (innerMulti && Array.isArray(values[i])) {\n        result += stringify.multiValue(values[i], innerMulti, type, null, designSet, structuredValue);\n      } else {\n        result += stringify.value(values[i], type, designSet, structuredValue);\n      }\n\n      if (i !== len - 1) {\n        result += delim;\n      }\n    }\n\n    return result;\n  };\n  /**\r\n   * Processes a single ical value runs the associated \"toICAL\" method from the\r\n   * design value type if available to convert the value.\r\n   *\r\n   * @function ICAL.stringify.value\r\n   * @param {String|Number} value       A formatted value\r\n   * @param {String} type               Lowercase iCalendar/vCard value type\r\n   *  (like boolean, date-time, etc..)\r\n   * @return {String}                   iCalendar/vCard value for single value\r\n   */\n\n\n  stringify.value = function (value, type, designSet, structuredValue) {\n    if (type in designSet.value && 'toICAL' in designSet.value[type]) {\n      return designSet.value[type].toICAL(value, structuredValue);\n    }\n\n    return value;\n  };\n  /**\r\n   * Internal helper for rfc6868. Exposing this on ICAL.stringify so that\r\n   * hackers can disable the rfc6868 parsing if the really need to.\r\n   *\r\n   * @param {String} val        The value to unescape\r\n   * @return {String}           The escaped value\r\n   */\n\n\n  stringify._rfc6868Unescape = function (val) {\n    return val.replace(/[\\n^\"]/g, function (x) {\n      return RFC6868_REPLACE_MAP[x];\n    });\n  };\n\n  var RFC6868_REPLACE_MAP = {\n    '\"': \"^'\",\n    \"\\n\": \"^n\",\n    \"^\": \"^^\"\n  };\n  return stringify;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\r\n * Contains various functions to parse iCalendar and vCard data.\r\n * @namespace\r\n */\n\n\nICAL.parse = function () {\n  'use strict';\n\n  var CHAR = /[^ \\t]/;\n  var MULTIVALUE_DELIMITER = ',';\n  var VALUE_DELIMITER = ':';\n  var PARAM_DELIMITER = ';';\n  var PARAM_NAME_DELIMITER = '=';\n  var DEFAULT_VALUE_TYPE = 'unknown';\n  var DEFAULT_PARAM_TYPE = 'text';\n  var design = ICAL.design;\n  var helpers = ICAL.helpers;\n  /**\r\n   * An error that occurred during parsing.\r\n   *\r\n   * @param {String} message        The error message\r\n   * @memberof ICAL.parse\r\n   * @extends {Error}\r\n   * @class\r\n   */\n\n  function ParserError(message) {\n    this.message = message;\n    this.name = 'ParserError';\n\n    try {\n      throw new Error();\n    } catch (e) {\n      if (e.stack) {\n        var split = e.stack.split('\\n');\n        split.shift();\n        this.stack = split.join('\\n');\n      }\n    }\n  }\n\n  ParserError.prototype = Error.prototype;\n  /**\r\n   * Parses iCalendar or vCard data into a raw jCal object. Consult\r\n   * documentation on the {@tutorial layers|layers of parsing} for more\r\n   * details.\r\n   *\r\n   * @function ICAL.parse\r\n   * @variation function\r\n   * @todo Fix the API to be more clear on the return type\r\n   * @param {String} input      The string data to parse\r\n   * @return {Object|Object[]}  A single jCal object, or an array thereof\r\n   */\n\n  function parser(input) {\n    var state = {};\n    var root = state.component = [];\n    state.stack = [root];\n\n    parser._eachLine(input, function (err, line) {\n      parser._handleContentLine(line, state);\n    }); // when there are still items on the stack\n    // throw a fatal error, a component was not closed\n    // correctly in that case.\n\n\n    if (state.stack.length > 1) {\n      throw new ParserError('invalid ical body. component began but did not end');\n    }\n\n    state = null;\n    return root.length == 1 ? root[0] : root;\n  }\n  /**\r\n   * Parse an iCalendar property value into the jCal for a single property\r\n   *\r\n   * @function ICAL.parse.property\r\n   * @param {String} str\r\n   *   The iCalendar property string to parse\r\n   * @param {ICAL.design.designSet=} designSet\r\n   *   The design data to use for this property\r\n   * @return {Object}\r\n   *   The jCal Object containing the property\r\n   */\n\n\n  parser.property = function (str, designSet) {\n    var state = {\n      component: [[], []],\n      designSet: designSet || design.defaultSet\n    };\n\n    parser._handleContentLine(str, state);\n\n    return state.component[1][0];\n  };\n  /**\r\n   * Convenience method to parse a component. You can use ICAL.parse() directly\r\n   * instead.\r\n   *\r\n   * @function ICAL.parse.component\r\n   * @see ICAL.parse(function)\r\n   * @param {String} str    The iCalendar component string to parse\r\n   * @return {Object}       The jCal Object containing the component\r\n   */\n\n\n  parser.component = function (str) {\n    return parser(str);\n  }; // classes & constants\n\n\n  parser.ParserError = ParserError;\n  /**\r\n   * The state for parsing content lines from an iCalendar/vCard string.\r\n   *\r\n   * @private\r\n   * @memberof ICAL.parse\r\n   * @typedef {Object} parserState\r\n   * @property {ICAL.design.designSet} designSet    The design set to use for parsing\r\n   * @property {ICAL.Component[]} stack             The stack of components being processed\r\n   * @property {ICAL.Component} component           The currently active component\r\n   */\n\n  /**\r\n   * Handles a single line of iCalendar/vCard, updating the state.\r\n   *\r\n   * @private\r\n   * @function ICAL.parse._handleContentLine\r\n   * @param {String} line               The content line to process\r\n   * @param {ICAL.parse.parserState}    The current state of the line parsing\r\n   */\n\n  parser._handleContentLine = function (line, state) {\n    // break up the parts of the line\n    var valuePos = line.indexOf(VALUE_DELIMITER);\n    var paramPos = line.indexOf(PARAM_DELIMITER);\n    var lastParamIndex;\n    var lastValuePos; // name of property or begin/end\n\n    var name;\n    var value; // params is only overridden if paramPos !== -1.\n    // we can't do params = params || {} later on\n    // because it sacrifices ops.\n\n    var params = {};\n    /**\r\n     * Different property cases\r\n     *\r\n     *\r\n     * 1. RRULE:FREQ=foo\r\n     *    // FREQ= is not a param but the value\r\n     *\r\n     * 2. ATTENDEE;ROLE=REQ-PARTICIPANT;\r\n     *    // ROLE= is a param because : has not happened yet\r\n     */\n    // when the parameter delimiter is after the\n    // value delimiter then its not a parameter.\n\n    if (paramPos !== -1 && valuePos !== -1) {\n      // when the parameter delimiter is after the\n      // value delimiter then its not a parameter.\n      if (paramPos > valuePos) {\n        paramPos = -1;\n      }\n    }\n\n    var parsedParams;\n\n    if (paramPos !== -1) {\n      name = line.substring(0, paramPos).toLowerCase();\n      parsedParams = parser._parseParameters(line.substring(paramPos), 0, state.designSet);\n\n      if (parsedParams[2] == -1) {\n        throw new ParserError(\"Invalid parameters in '\" + line + \"'\");\n      }\n\n      params = parsedParams[0];\n      lastParamIndex = parsedParams[1].length + parsedParams[2] + paramPos;\n\n      if ((lastValuePos = line.substring(lastParamIndex).indexOf(VALUE_DELIMITER)) !== -1) {\n        value = line.substring(lastParamIndex + lastValuePos + 1);\n      } else {\n        throw new ParserError(\"Missing parameter value in '\" + line + \"'\");\n      }\n    } else if (valuePos !== -1) {\n      // without parmeters (BEGIN:VCAENDAR, CLASS:PUBLIC)\n      name = line.substring(0, valuePos).toLowerCase();\n      value = line.substring(valuePos + 1);\n\n      if (name === 'begin') {\n        var newComponent = [value.toLowerCase(), [], []];\n\n        if (state.stack.length === 1) {\n          state.component.push(newComponent);\n        } else {\n          state.component[2].push(newComponent);\n        }\n\n        state.stack.push(state.component);\n        state.component = newComponent;\n\n        if (!state.designSet) {\n          state.designSet = design.getDesignSet(state.component[0]);\n        }\n\n        return;\n      } else if (name === 'end') {\n        state.component = state.stack.pop();\n        return;\n      } // If its not begin/end, then this is a property with an empty value,\n      // which should be considered valid.\n\n    } else {\n      /**\r\n       * Invalid line.\r\n       * The rational to throw an error is we will\r\n       * never be certain that the rest of the file\r\n       * is sane and its unlikely that we can serialize\r\n       * the result correctly either.\r\n       */\n      throw new ParserError('invalid line (no token \";\" or \":\") \"' + line + '\"');\n    }\n\n    var valueType;\n    var multiValue = false;\n    var structuredValue = false;\n    var propertyDetails;\n\n    if (name in state.designSet.property) {\n      propertyDetails = state.designSet.property[name];\n\n      if ('multiValue' in propertyDetails) {\n        multiValue = propertyDetails.multiValue;\n      }\n\n      if ('structuredValue' in propertyDetails) {\n        structuredValue = propertyDetails.structuredValue;\n      }\n\n      if (value && 'detectType' in propertyDetails) {\n        valueType = propertyDetails.detectType(value);\n      }\n    } // attempt to determine value\n\n\n    if (!valueType) {\n      if (!('value' in params)) {\n        if (propertyDetails) {\n          valueType = propertyDetails.defaultType;\n        } else {\n          valueType = DEFAULT_VALUE_TYPE;\n        }\n      } else {\n        // possible to avoid this?\n        valueType = params.value.toLowerCase();\n      }\n    }\n\n    delete params.value;\n    /**\r\n     * Note on `var result` juggling:\r\n     *\r\n     * I observed that building the array in pieces has adverse\r\n     * effects on performance, so where possible we inline the creation.\r\n     * Its a little ugly but resulted in ~2000 additional ops/sec.\r\n     */\n\n    var result;\n\n    if (multiValue && structuredValue) {\n      value = parser._parseMultiValue(value, structuredValue, valueType, [], multiValue, state.designSet, structuredValue);\n      result = [name, params, valueType, value];\n    } else if (multiValue) {\n      result = [name, params, valueType];\n\n      parser._parseMultiValue(value, multiValue, valueType, result, null, state.designSet, false);\n    } else if (structuredValue) {\n      value = parser._parseMultiValue(value, structuredValue, valueType, [], null, state.designSet, structuredValue);\n      result = [name, params, valueType, value];\n    } else {\n      value = parser._parseValue(value, valueType, state.designSet, false);\n      result = [name, params, valueType, value];\n    } // rfc6350 requires that in vCard 4.0 the first component is the VERSION\n    // component with as value 4.0, note that 3.0 does not have this requirement.\n\n\n    if (state.component[0] === 'vcard' && state.component[1].length === 0 && !(name === 'version' && value === '4.0')) {\n      state.designSet = design.getDesignSet(\"vcard3\");\n    }\n\n    state.component[1].push(result);\n  };\n  /**\r\n   * Parse a value from the raw value into the jCard/jCal value.\r\n   *\r\n   * @private\r\n   * @function ICAL.parse._parseValue\r\n   * @param {String} value          Original value\r\n   * @param {String} type           Type of value\r\n   * @param {Object} designSet      The design data to use for this value\r\n   * @return {Object} varies on type\r\n   */\n\n\n  parser._parseValue = function (value, type, designSet, structuredValue) {\n    if (type in designSet.value && 'fromICAL' in designSet.value[type]) {\n      return designSet.value[type].fromICAL(value, structuredValue);\n    }\n\n    return value;\n  };\n  /**\r\n   * Parse parameters from a string to object.\r\n   *\r\n   * @function ICAL.parse._parseParameters\r\n   * @private\r\n   * @param {String} line           A single unfolded line\r\n   * @param {Numeric} start         Position to start looking for properties\r\n   * @param {Object} designSet      The design data to use for this property\r\n   * @return {Object} key/value pairs\r\n   */\n\n\n  parser._parseParameters = function (line, start, designSet) {\n    var lastParam = start;\n    var pos = 0;\n    var delim = PARAM_NAME_DELIMITER;\n    var result = {};\n    var name, lcname;\n    var value,\n        valuePos = -1;\n    var type, multiValue, mvdelim; // find the next '=' sign\n    // use lastParam and pos to find name\n    // check if \" is used if so get value from \"->\"\n    // then increment pos to find next ;\n\n    while (pos !== false && (pos = helpers.unescapedIndexOf(line, delim, pos + 1)) !== -1) {\n      name = line.substr(lastParam + 1, pos - lastParam - 1);\n\n      if (name.length == 0) {\n        throw new ParserError(\"Empty parameter name in '\" + line + \"'\");\n      }\n\n      lcname = name.toLowerCase();\n      mvdelim = false;\n      multiValue = false;\n\n      if (lcname in designSet.param && designSet.param[lcname].valueType) {\n        type = designSet.param[lcname].valueType;\n      } else {\n        type = DEFAULT_PARAM_TYPE;\n      }\n\n      if (lcname in designSet.param) {\n        multiValue = designSet.param[lcname].multiValue;\n\n        if (designSet.param[lcname].multiValueSeparateDQuote) {\n          mvdelim = parser._rfc6868Escape('\"' + multiValue + '\"');\n        }\n      }\n\n      var nextChar = line[pos + 1];\n\n      if (nextChar === '\"') {\n        valuePos = pos + 2;\n        pos = helpers.unescapedIndexOf(line, '\"', valuePos);\n\n        if (multiValue && pos != -1) {\n          var extendedValue = true;\n\n          while (extendedValue) {\n            if (line[pos + 1] == multiValue && line[pos + 2] == '\"') {\n              pos = helpers.unescapedIndexOf(line, '\"', pos + 3);\n            } else {\n              extendedValue = false;\n            }\n          }\n        }\n\n        if (pos === -1) {\n          throw new ParserError('invalid line (no matching double quote) \"' + line + '\"');\n        }\n\n        value = line.substr(valuePos, pos - valuePos);\n        lastParam = helpers.unescapedIndexOf(line, PARAM_DELIMITER, pos);\n\n        if (lastParam === -1) {\n          pos = false;\n        }\n      } else {\n        valuePos = pos + 1; // move to next \";\"\n\n        var nextPos = helpers.unescapedIndexOf(line, PARAM_DELIMITER, valuePos);\n        var propValuePos = helpers.unescapedIndexOf(line, VALUE_DELIMITER, valuePos);\n\n        if (propValuePos !== -1 && nextPos > propValuePos) {\n          // this is a delimiter in the property value, let's stop here\n          nextPos = propValuePos;\n          pos = false;\n        } else if (nextPos === -1) {\n          // no \";\"\n          if (propValuePos === -1) {\n            nextPos = line.length;\n          } else {\n            nextPos = propValuePos;\n          }\n\n          pos = false;\n        } else {\n          lastParam = nextPos;\n          pos = nextPos;\n        }\n\n        value = line.substr(valuePos, nextPos - valuePos);\n      }\n\n      value = parser._rfc6868Escape(value);\n\n      if (multiValue) {\n        var delimiter = mvdelim || multiValue;\n        value = parser._parseMultiValue(value, delimiter, type, [], null, designSet);\n      } else {\n        value = parser._parseValue(value, type, designSet);\n      }\n\n      if (multiValue && lcname in result) {\n        if (Array.isArray(result[lcname])) {\n          result[lcname].push(value);\n        } else {\n          result[lcname] = [result[lcname], value];\n        }\n      } else {\n        result[lcname] = value;\n      }\n    }\n\n    return [result, value, valuePos];\n  };\n  /**\r\n   * Internal helper for rfc6868. Exposing this on ICAL.parse so that\r\n   * hackers can disable the rfc6868 parsing if the really need to.\r\n   *\r\n   * @function ICAL.parse._rfc6868Escape\r\n   * @param {String} val        The value to escape\r\n   * @return {String}           The escaped value\r\n   */\n\n\n  parser._rfc6868Escape = function (val) {\n    return val.replace(/\\^['n^]/g, function (x) {\n      return RFC6868_REPLACE_MAP[x];\n    });\n  };\n\n  var RFC6868_REPLACE_MAP = {\n    \"^'\": '\"',\n    \"^n\": \"\\n\",\n    \"^^\": \"^\"\n  };\n  /**\r\n   * Parse a multi value string. This function is used either for parsing\r\n   * actual multi-value property's values, or for handling parameter values. It\r\n   * can be used for both multi-value properties and structured value properties.\r\n   *\r\n   * @private\r\n   * @function ICAL.parse._parseMultiValue\r\n   * @param {String} buffer     The buffer containing the full value\r\n   * @param {String} delim      The multi-value delimiter\r\n   * @param {String} type       The value type to be parsed\r\n   * @param {Array.<?>} result        The array to append results to, varies on value type\r\n   * @param {String} innerMulti The inner delimiter to split each value with\r\n   * @param {ICAL.design.designSet} designSet   The design data for this value\r\n   * @return {?|Array.<?>}            Either an array of results, or the first result\r\n   */\n\n  parser._parseMultiValue = function (buffer, delim, type, result, innerMulti, designSet, structuredValue) {\n    var pos = 0;\n    var lastPos = 0;\n    var value;\n\n    if (delim.length === 0) {\n      return buffer;\n    } // split each piece\n\n\n    while ((pos = helpers.unescapedIndexOf(buffer, delim, lastPos)) !== -1) {\n      value = buffer.substr(lastPos, pos - lastPos);\n\n      if (innerMulti) {\n        value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);\n      } else {\n        value = parser._parseValue(value, type, designSet, structuredValue);\n      }\n\n      result.push(value);\n      lastPos = pos + delim.length;\n    } // on the last piece take the rest of string\n\n\n    value = buffer.substr(lastPos);\n\n    if (innerMulti) {\n      value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);\n    } else {\n      value = parser._parseValue(value, type, designSet, structuredValue);\n    }\n\n    result.push(value);\n    return result.length == 1 ? result[0] : result;\n  };\n  /**\r\n   * Process a complete buffer of iCalendar/vCard data line by line, correctly\r\n   * unfolding content. Each line will be processed with the given callback\r\n   *\r\n   * @private\r\n   * @function ICAL.parse._eachLine\r\n   * @param {String} buffer                         The buffer to process\r\n   * @param {function(?String, String)} callback    The callback for each line\r\n   */\n\n\n  parser._eachLine = function (buffer, callback) {\n    var len = buffer.length;\n    var lastPos = buffer.search(CHAR);\n    var pos = lastPos;\n    var line;\n    var firstChar;\n    var newlineOffset;\n\n    do {\n      pos = buffer.indexOf('\\n', lastPos) + 1;\n\n      if (pos > 1 && buffer[pos - 2] === '\\r') {\n        newlineOffset = 2;\n      } else {\n        newlineOffset = 1;\n      }\n\n      if (pos === 0) {\n        pos = len;\n        newlineOffset = 0;\n      }\n\n      firstChar = buffer[lastPos];\n\n      if (firstChar === ' ' || firstChar === '\\t') {\n        // add to line\n        line += buffer.substr(lastPos + 1, pos - lastPos - (newlineOffset + 1));\n      } else {\n        if (line) callback(null, line); // push line\n\n        line = buffer.substr(lastPos, pos - lastPos - newlineOffset);\n      }\n\n      lastPos = pos;\n    } while (pos !== len); // extra ending line\n\n\n    line = line.trim();\n    if (line.length) callback(null, line);\n  };\n\n  return parser;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\r\n * This symbol is further described later on\r\n * @ignore\r\n */\n\n\nICAL.Component = function () {\n  'use strict';\n\n  var PROPERTY_INDEX = 1;\n  var COMPONENT_INDEX = 2;\n  var NAME_INDEX = 0;\n  /**\r\n   * @classdesc\r\n   * Wraps a jCal component, adding convenience methods to add, remove and\r\n   * update subcomponents and properties.\r\n   *\r\n   * @class\r\n   * @alias ICAL.Component\r\n   * @param {Array|String} jCal         Raw jCal component data OR name of new\r\n   *                                      component\r\n   * @param {ICAL.Component} parent     Parent component to associate\r\n   */\n\n  function Component(jCal, parent) {\n    if (typeof jCal === 'string') {\n      // jCal spec (name, properties, components)\n      jCal = [jCal, [], []];\n    } // mostly for legacy reasons.\n\n\n    this.jCal = jCal;\n    this.parent = parent || null;\n  }\n\n  Component.prototype = {\n    /**\r\n     * Hydrated properties are inserted into the _properties array at the same\r\n     * position as in the jCal array, so its possible the array contains\r\n     * undefined values for unhydrdated properties. To avoid iterating the\r\n     * array when checking if all properties have been hydrated, we save the\r\n     * count here.\r\n     *\r\n     * @type {Number}\r\n     * @private\r\n     */\n    _hydratedPropertyCount: 0,\n\n    /**\r\n     * The same count as for _hydratedPropertyCount, but for subcomponents\r\n     *\r\n     * @type {Number}\r\n     * @private\r\n     */\n    _hydratedComponentCount: 0,\n\n    /**\r\n     * The name of this component\r\n     * @readonly\r\n     */\n    get name() {\n      return this.jCal[NAME_INDEX];\n    },\n\n    /**\r\n     * The design set for this component, e.g. icalendar vs vcard\r\n     *\r\n     * @type {ICAL.design.designSet}\r\n     * @private\r\n     */\n    get _designSet() {\n      var parentDesign = this.parent && this.parent._designSet;\n      return parentDesign || ICAL.design.getDesignSet(this.name);\n    },\n\n    _hydrateComponent: function _hydrateComponent(index) {\n      if (!this._components) {\n        this._components = [];\n        this._hydratedComponentCount = 0;\n      }\n\n      if (this._components[index]) {\n        return this._components[index];\n      }\n\n      var comp = new Component(this.jCal[COMPONENT_INDEX][index], this);\n      this._hydratedComponentCount++;\n      return this._components[index] = comp;\n    },\n    _hydrateProperty: function _hydrateProperty(index) {\n      if (!this._properties) {\n        this._properties = [];\n        this._hydratedPropertyCount = 0;\n      }\n\n      if (this._properties[index]) {\n        return this._properties[index];\n      }\n\n      var prop = new ICAL.Property(this.jCal[PROPERTY_INDEX][index], this);\n      this._hydratedPropertyCount++;\n      return this._properties[index] = prop;\n    },\n\n    /**\r\n     * Finds first sub component, optionally filtered by name.\r\n     *\r\n     * @param {String=} name        Optional name to filter by\r\n     * @return {?ICAL.Component}     The found subcomponent\r\n     */\n    getFirstSubcomponent: function getFirstSubcomponent(name) {\n      if (name) {\n        var i = 0;\n        var comps = this.jCal[COMPONENT_INDEX];\n        var len = comps.length;\n\n        for (; i < len; i++) {\n          if (comps[i][NAME_INDEX] === name) {\n            var result = this._hydrateComponent(i);\n\n            return result;\n          }\n        }\n      } else {\n        if (this.jCal[COMPONENT_INDEX].length) {\n          return this._hydrateComponent(0);\n        }\n      } // ensure we return a value (strict mode)\n\n\n      return null;\n    },\n\n    /**\r\n     * Finds all sub components, optionally filtering by name.\r\n     *\r\n     * @param {String=} name            Optional name to filter by\r\n     * @return {ICAL.Component[]}       The found sub components\r\n     */\n    getAllSubcomponents: function getAllSubcomponents(name) {\n      var jCalLen = this.jCal[COMPONENT_INDEX].length;\n      var i = 0;\n\n      if (name) {\n        var comps = this.jCal[COMPONENT_INDEX];\n        var result = [];\n\n        for (; i < jCalLen; i++) {\n          if (name === comps[i][NAME_INDEX]) {\n            result.push(this._hydrateComponent(i));\n          }\n        }\n\n        return result;\n      } else {\n        if (!this._components || this._hydratedComponentCount !== jCalLen) {\n          for (; i < jCalLen; i++) {\n            this._hydrateComponent(i);\n          }\n        }\n\n        return this._components || [];\n      }\n    },\n\n    /**\r\n     * Returns true when a named property exists.\r\n     *\r\n     * @param {String} name     The property name\r\n     * @return {Boolean}        True, when property is found\r\n     */\n    hasProperty: function hasProperty(name) {\n      var props = this.jCal[PROPERTY_INDEX];\n      var len = props.length;\n      var i = 0;\n\n      for (; i < len; i++) {\n        // 0 is property name\n        if (props[i][NAME_INDEX] === name) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\r\n     * Finds the first property, optionally with the given name.\r\n     *\r\n     * @param {String=} name        Lowercase property name\r\n     * @return {?ICAL.Property}     The found property\r\n     */\n    getFirstProperty: function getFirstProperty(name) {\n      if (name) {\n        var i = 0;\n        var props = this.jCal[PROPERTY_INDEX];\n        var len = props.length;\n\n        for (; i < len; i++) {\n          if (props[i][NAME_INDEX] === name) {\n            var result = this._hydrateProperty(i);\n\n            return result;\n          }\n        }\n      } else {\n        if (this.jCal[PROPERTY_INDEX].length) {\n          return this._hydrateProperty(0);\n        }\n      }\n\n      return null;\n    },\n\n    /**\r\n     * Returns first property's value, if available.\r\n     *\r\n     * @param {String=} name    Lowercase property name\r\n     * @return {?String}        The found property value.\r\n     */\n    getFirstPropertyValue: function getFirstPropertyValue(name) {\n      var prop = this.getFirstProperty(name);\n\n      if (prop) {\n        return prop.getFirstValue();\n      }\n\n      return null;\n    },\n\n    /**\r\n     * Get all properties in the component, optionally filtered by name.\r\n     *\r\n     * @param {String=} name        Lowercase property name\r\n     * @return {ICAL.Property[]}    List of properties\r\n     */\n    getAllProperties: function getAllProperties(name) {\n      var jCalLen = this.jCal[PROPERTY_INDEX].length;\n      var i = 0;\n\n      if (name) {\n        var props = this.jCal[PROPERTY_INDEX];\n        var result = [];\n\n        for (; i < jCalLen; i++) {\n          if (name === props[i][NAME_INDEX]) {\n            result.push(this._hydrateProperty(i));\n          }\n        }\n\n        return result;\n      } else {\n        if (!this._properties || this._hydratedPropertyCount !== jCalLen) {\n          for (; i < jCalLen; i++) {\n            this._hydrateProperty(i);\n          }\n        }\n\n        return this._properties || [];\n      }\n    },\n    _removeObjectByIndex: function _removeObjectByIndex(jCalIndex, cache, index) {\n      cache = cache || []; // remove cached version\n\n      if (cache[index]) {\n        var obj = cache[index];\n\n        if (\"parent\" in obj) {\n          obj.parent = null;\n        }\n      }\n\n      cache.splice(index, 1); // remove it from the jCal\n\n      this.jCal[jCalIndex].splice(index, 1);\n    },\n    _removeObject: function _removeObject(jCalIndex, cache, nameOrObject) {\n      var i = 0;\n      var objects = this.jCal[jCalIndex];\n      var len = objects.length;\n      var cached = this[cache];\n\n      if (typeof nameOrObject === 'string') {\n        for (; i < len; i++) {\n          if (objects[i][NAME_INDEX] === nameOrObject) {\n            this._removeObjectByIndex(jCalIndex, cached, i);\n\n            return true;\n          }\n        }\n      } else if (cached) {\n        for (; i < len; i++) {\n          if (cached[i] && cached[i] === nameOrObject) {\n            this._removeObjectByIndex(jCalIndex, cached, i);\n\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n    _removeAllObjects: function _removeAllObjects(jCalIndex, cache, name) {\n      var cached = this[cache]; // Unfortunately we have to run through all children to reset their\n      // parent property.\n\n      var objects = this.jCal[jCalIndex];\n      var i = objects.length - 1; // descending search required because splice\n      // is used and will effect the indices.\n\n      for (; i >= 0; i--) {\n        if (!name || objects[i][NAME_INDEX] === name) {\n          this._removeObjectByIndex(jCalIndex, cached, i);\n        }\n      }\n    },\n\n    /**\r\n     * Adds a single sub component.\r\n     *\r\n     * @param {ICAL.Component} component        The component to add\r\n     * @return {ICAL.Component}                 The passed in component\r\n     */\n    addSubcomponent: function addSubcomponent(component) {\n      if (!this._components) {\n        this._components = [];\n        this._hydratedComponentCount = 0;\n      }\n\n      if (component.parent) {\n        component.parent.removeSubcomponent(component);\n      }\n\n      var idx = this.jCal[COMPONENT_INDEX].push(component.jCal);\n      this._components[idx - 1] = component;\n      this._hydratedComponentCount++;\n      component.parent = this;\n      return component;\n    },\n\n    /**\r\n     * Removes a single component by name or the instance of a specific\r\n     * component.\r\n     *\r\n     * @param {ICAL.Component|String} nameOrComp    Name of component, or component\r\n     * @return {Boolean}                            True when comp is removed\r\n     */\n    removeSubcomponent: function removeSubcomponent(nameOrComp) {\n      var removed = this._removeObject(COMPONENT_INDEX, '_components', nameOrComp);\n\n      if (removed) {\n        this._hydratedComponentCount--;\n      }\n\n      return removed;\n    },\n\n    /**\r\n     * Removes all components or (if given) all components by a particular\r\n     * name.\r\n     *\r\n     * @param {String=} name            Lowercase component name\r\n     */\n    removeAllSubcomponents: function removeAllSubcomponents(name) {\n      var removed = this._removeAllObjects(COMPONENT_INDEX, '_components', name);\n\n      this._hydratedComponentCount = 0;\n      return removed;\n    },\n\n    /**\r\n     * Adds an {@link ICAL.Property} to the component.\r\n     *\r\n     * @param {ICAL.Property} property      The property to add\r\n     * @return {ICAL.Property}              The passed in property\r\n     */\n    addProperty: function addProperty(property) {\n      if (!(property instanceof ICAL.Property)) {\n        throw new TypeError('must instance of ICAL.Property');\n      }\n\n      if (!this._properties) {\n        this._properties = [];\n        this._hydratedPropertyCount = 0;\n      }\n\n      if (property.parent) {\n        property.parent.removeProperty(property);\n      }\n\n      var idx = this.jCal[PROPERTY_INDEX].push(property.jCal);\n      this._properties[idx - 1] = property;\n      this._hydratedPropertyCount++;\n      property.parent = this;\n      return property;\n    },\n\n    /**\r\n     * Helper method to add a property with a value to the component.\r\n     *\r\n     * @param {String}               name         Property name to add\r\n     * @param {String|Number|Object} value        Property value\r\n     * @return {ICAL.Property}                    The created property\r\n     */\n    addPropertyWithValue: function addPropertyWithValue(name, value) {\n      var prop = new ICAL.Property(name);\n      prop.setValue(value);\n      this.addProperty(prop);\n      return prop;\n    },\n\n    /**\r\n     * Helper method that will update or create a property of the given name\r\n     * and sets its value. If multiple properties with the given name exist,\r\n     * only the first is updated.\r\n     *\r\n     * @param {String}               name         Property name to update\r\n     * @param {String|Number|Object} value        Property value\r\n     * @return {ICAL.Property}                    The created property\r\n     */\n    updatePropertyWithValue: function updatePropertyWithValue(name, value) {\n      var prop = this.getFirstProperty(name);\n\n      if (prop) {\n        prop.setValue(value);\n      } else {\n        prop = this.addPropertyWithValue(name, value);\n      }\n\n      return prop;\n    },\n\n    /**\r\n     * Removes a single property by name or the instance of the specific\r\n     * property.\r\n     *\r\n     * @param {String|ICAL.Property} nameOrProp     Property name or instance to remove\r\n     * @return {Boolean}                            True, when deleted\r\n     */\n    removeProperty: function removeProperty(nameOrProp) {\n      var removed = this._removeObject(PROPERTY_INDEX, '_properties', nameOrProp);\n\n      if (removed) {\n        this._hydratedPropertyCount--;\n      }\n\n      return removed;\n    },\n\n    /**\r\n     * Removes all properties associated with this component, optionally\r\n     * filtered by name.\r\n     *\r\n     * @param {String=} name        Lowercase property name\r\n     * @return {Boolean}            True, when deleted\r\n     */\n    removeAllProperties: function removeAllProperties(name) {\n      var removed = this._removeAllObjects(PROPERTY_INDEX, '_properties', name);\n\n      this._hydratedPropertyCount = 0;\n      return removed;\n    },\n\n    /**\r\n     * Returns the Object representation of this component. The returned object\r\n     * is a live jCal object and should be cloned if modified.\r\n     * @return {Object}\r\n     */\n    toJSON: function toJSON() {\n      return this.jCal;\n    },\n\n    /**\r\n     * The string representation of this component.\r\n     * @return {String}\r\n     */\n    toString: function toString() {\n      return ICAL.stringify.component(this.jCal, this._designSet);\n    }\n  };\n  /**\r\n   * Create an {@link ICAL.Component} by parsing the passed iCalendar string.\r\n   *\r\n   * @param {String} str        The iCalendar string to parse\r\n   */\n\n  Component.fromString = function (str) {\n    return new Component(ICAL.parse.component(str));\n  };\n\n  return Component;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\r\n * This symbol is further described later on\r\n * @ignore\r\n */\n\n\nICAL.Property = function () {\n  'use strict';\n\n  var NAME_INDEX = 0;\n  var PROP_INDEX = 1;\n  var TYPE_INDEX = 2;\n  var VALUE_INDEX = 3;\n  var design = ICAL.design;\n  /**\r\n   * @classdesc\r\n   * Provides a layer on top of the raw jCal object for manipulating a single\r\n   * property, with its parameters and value.\r\n   *\r\n   * @description\r\n   * Its important to note that mutations done in the wrapper\r\n   * directly mutate the jCal object used to initialize.\r\n   *\r\n   * Can also be used to create new properties by passing\r\n   * the name of the property (as a String).\r\n   *\r\n   * @class\r\n   * @alias ICAL.Property\r\n   * @param {Array|String} jCal         Raw jCal representation OR\r\n   *  the new name of the property\r\n   *\r\n   * @param {ICAL.Component=} parent    Parent component\r\n   */\n\n  function Property(jCal, parent) {\n    this._parent = parent || null;\n\n    if (typeof jCal === 'string') {\n      // We are creating the property by name and need to detect the type\n      this.jCal = [jCal, {}, design.defaultType];\n      this.jCal[TYPE_INDEX] = this.getDefaultType();\n    } else {\n      this.jCal = jCal;\n    }\n\n    this._updateType();\n  }\n\n  Property.prototype = {\n    /**\r\n     * The value type for this property\r\n     * @readonly\r\n     * @type {String}\r\n     */\n    get type() {\n      return this.jCal[TYPE_INDEX];\n    },\n\n    /**\r\n     * The name of this property, in lowercase.\r\n     * @readonly\r\n     * @type {String}\r\n     */\n    get name() {\n      return this.jCal[NAME_INDEX];\n    },\n\n    /**\r\n     * The parent component for this property.\r\n     * @type {ICAL.Component}\r\n     */\n    get parent() {\n      return this._parent;\n    },\n\n    set parent(p) {\n      // Before setting the parent, check if the design set has changed. If it\n      // has, we later need to update the type if it was unknown before.\n      var designSetChanged = !this._parent || p && p._designSet != this._parent._designSet;\n      this._parent = p;\n\n      if (this.type == design.defaultType && designSetChanged) {\n        this.jCal[TYPE_INDEX] = this.getDefaultType();\n\n        this._updateType();\n      }\n\n      return p;\n    },\n\n    /**\r\n     * The design set for this property, e.g. icalendar vs vcard\r\n     *\r\n     * @type {ICAL.design.designSet}\r\n     * @private\r\n     */\n    get _designSet() {\n      return this.parent ? this.parent._designSet : design.defaultSet;\n    },\n\n    /**\r\n     * Updates the type metadata from the current jCal type and design set.\r\n     *\r\n     * @private\r\n     */\n    _updateType: function _updateType() {\n      var designSet = this._designSet;\n\n      if (this.type in designSet.value) {\n        var designType = designSet.value[this.type];\n\n        if ('decorate' in designSet.value[this.type]) {\n          this.isDecorated = true;\n        } else {\n          this.isDecorated = false;\n        }\n\n        if (this.name in designSet.property) {\n          this.isMultiValue = 'multiValue' in designSet.property[this.name];\n          this.isStructuredValue = 'structuredValue' in designSet.property[this.name];\n        }\n      }\n    },\n\n    /**\r\n     * Hydrate a single value. The act of hydrating means turning the raw jCal\r\n     * value into a potentially wrapped object, for example {@link ICAL.Time}.\r\n     *\r\n     * @private\r\n     * @param {Number} index        The index of the value to hydrate\r\n     * @return {Object}             The decorated value.\r\n     */\n    _hydrateValue: function _hydrateValue(index) {\n      if (this._values && this._values[index]) {\n        return this._values[index];\n      } // for the case where there is no value.\n\n\n      if (this.jCal.length <= VALUE_INDEX + index) {\n        return null;\n      }\n\n      if (this.isDecorated) {\n        if (!this._values) {\n          this._values = [];\n        }\n\n        return this._values[index] = this._decorate(this.jCal[VALUE_INDEX + index]);\n      } else {\n        return this.jCal[VALUE_INDEX + index];\n      }\n    },\n\n    /**\r\n     * Decorate a single value, returning its wrapped object. This is used by\r\n     * the hydrate function to actually wrap the value.\r\n     *\r\n     * @private\r\n     * @param {?} value         The value to decorate\r\n     * @return {Object}         The decorated value\r\n     */\n    _decorate: function _decorate(value) {\n      return this._designSet.value[this.type].decorate(value, this);\n    },\n\n    /**\r\n     * Undecorate a single value, returning its raw jCal data.\r\n     *\r\n     * @private\r\n     * @param {Object} value         The value to undecorate\r\n     * @return {?}                   The undecorated value\r\n     */\n    _undecorate: function _undecorate(value) {\n      return this._designSet.value[this.type].undecorate(value, this);\n    },\n\n    /**\r\n     * Sets the value at the given index while also hydrating it. The passed\r\n     * value can either be a decorated or undecorated value.\r\n     *\r\n     * @private\r\n     * @param {?} value             The value to set\r\n     * @param {Number} index        The index to set it at\r\n     */\n    _setDecoratedValue: function _setDecoratedValue(value, index) {\n      if (!this._values) {\n        this._values = [];\n      }\n\n      if (typeof value === 'object' && 'icaltype' in value) {\n        // decorated value\n        this.jCal[VALUE_INDEX + index] = this._undecorate(value);\n        this._values[index] = value;\n      } else {\n        // undecorated value\n        this.jCal[VALUE_INDEX + index] = value;\n        this._values[index] = this._decorate(value);\n      }\n    },\n\n    /**\r\n     * Gets a parameter on the property.\r\n     *\r\n     * @param {String}        name   Property name (lowercase)\r\n     * @return {Array|String}        Property value\r\n     */\n    getParameter: function getParameter(name) {\n      if (name in this.jCal[PROP_INDEX]) {\n        return this.jCal[PROP_INDEX][name];\n      } else {\n        return undefined;\n      }\n    },\n\n    /**\r\n     * Gets first parameter on the property.\r\n     *\r\n     * @param {String}        name   Property name (lowercase)\r\n     * @return {String}        Property value\r\n     */\n    getFirstParameter: function getFirstParameter(name) {\n      var parameters = this.getParameter(name);\n\n      if (Array.isArray(parameters)) {\n        return parameters[0];\n      }\n\n      return parameters;\n    },\n\n    /**\r\n     * Sets a parameter on the property.\r\n     *\r\n     * @param {String}       name     The parameter name\r\n     * @param {Array|String} value    The parameter value\r\n     */\n    setParameter: function setParameter(name, value) {\n      var lcname = name.toLowerCase();\n\n      if (typeof value === \"string\" && lcname in this._designSet.param && 'multiValue' in this._designSet.param[lcname]) {\n        value = [value];\n      }\n\n      this.jCal[PROP_INDEX][name] = value;\n    },\n\n    /**\r\n     * Removes a parameter\r\n     *\r\n     * @param {String} name     The parameter name\r\n     */\n    removeParameter: function removeParameter(name) {\n      delete this.jCal[PROP_INDEX][name];\n    },\n\n    /**\r\n     * Get the default type based on this property's name.\r\n     *\r\n     * @return {String}     The default type for this property\r\n     */\n    getDefaultType: function getDefaultType() {\n      var name = this.jCal[NAME_INDEX];\n      var designSet = this._designSet;\n\n      if (name in designSet.property) {\n        var details = designSet.property[name];\n\n        if ('defaultType' in details) {\n          return details.defaultType;\n        }\n      }\n\n      return design.defaultType;\n    },\n\n    /**\r\n     * Sets type of property and clears out any existing values of the current\r\n     * type.\r\n     *\r\n     * @param {String} type     New iCAL type (see design.*.values)\r\n     */\n    resetType: function resetType(type) {\n      this.removeAllValues();\n      this.jCal[TYPE_INDEX] = type;\n\n      this._updateType();\n    },\n\n    /**\r\n     * Finds the first property value.\r\n     *\r\n     * @return {String}         First property value\r\n     */\n    getFirstValue: function getFirstValue() {\n      return this._hydrateValue(0);\n    },\n\n    /**\r\n     * Gets all values on the property.\r\n     *\r\n     * NOTE: this creates an array during each call.\r\n     *\r\n     * @return {Array}          List of values\r\n     */\n    getValues: function getValues() {\n      var len = this.jCal.length - VALUE_INDEX;\n\n      if (len < 1) {\n        // its possible for a property to have no value.\n        return [];\n      }\n\n      var i = 0;\n      var result = [];\n\n      for (; i < len; i++) {\n        result[i] = this._hydrateValue(i);\n      }\n\n      return result;\n    },\n\n    /**\r\n     * Removes all values from this property\r\n     */\n    removeAllValues: function removeAllValues() {\n      if (this._values) {\n        this._values.length = 0;\n      }\n\n      this.jCal.length = 3;\n    },\n\n    /**\r\n     * Sets the values of the property.  Will overwrite the existing values.\r\n     * This can only be used for multi-value properties.\r\n     *\r\n     * @param {Array} values    An array of values\r\n     */\n    setValues: function setValues(values) {\n      if (!this.isMultiValue) {\n        throw new Error(this.name + ': does not not support mulitValue.\\n' + 'override isMultiValue');\n      }\n\n      var len = values.length;\n      var i = 0;\n      this.removeAllValues();\n\n      if (len > 0 && typeof values[0] === 'object' && 'icaltype' in values[0]) {\n        this.resetType(values[0].icaltype);\n      }\n\n      if (this.isDecorated) {\n        for (; i < len; i++) {\n          this._setDecoratedValue(values[i], i);\n        }\n      } else {\n        for (; i < len; i++) {\n          this.jCal[VALUE_INDEX + i] = values[i];\n        }\n      }\n    },\n\n    /**\r\n     * Sets the current value of the property. If this is a multi-value\r\n     * property, all other values will be removed.\r\n     *\r\n     * @param {String|Object} value     New property value.\r\n     */\n    setValue: function setValue(value) {\n      this.removeAllValues();\n\n      if (typeof value === 'object' && 'icaltype' in value) {\n        this.resetType(value.icaltype);\n      }\n\n      if (this.isDecorated) {\n        this._setDecoratedValue(value, 0);\n      } else {\n        this.jCal[VALUE_INDEX] = value;\n      }\n    },\n\n    /**\r\n     * Returns the Object representation of this component. The returned object\r\n     * is a live jCal object and should be cloned if modified.\r\n     * @return {Object}\r\n     */\n    toJSON: function toJSON() {\n      return this.jCal;\n    },\n\n    /**\r\n     * The string representation of this component.\r\n     * @return {String}\r\n     */\n    toICALString: function toICALString() {\n      return ICAL.stringify.property(this.jCal, this._designSet, true);\n    }\n  };\n  /**\r\n   * Create an {@link ICAL.Property} by parsing the passed iCalendar string.\r\n   *\r\n   * @param {String} str                        The iCalendar string to parse\r\n   * @param {ICAL.design.designSet=} designSet  The design data to use for this property\r\n   * @return {ICAL.Property}                    The created iCalendar property\r\n   */\n\n  Property.fromString = function (str, designSet) {\n    return new Property(ICAL.parse.property(str, designSet));\n  };\n\n  return Property;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\r\n * This symbol is further described later on\r\n * @ignore\r\n */\n\n\nICAL.UtcOffset = function () {\n  /**\r\n   * @classdesc\r\n   * This class represents the \"duration\" value type, with various calculation\r\n   * and manipulation methods.\r\n   *\r\n   * @class\r\n   * @alias ICAL.UtcOffset\r\n   * @param {Object} aData          An object with members of the utc offset\r\n   * @param {Number=} aData.hours   The hours for the utc offset\r\n   * @param {Number=} aData.minutes The minutes in the utc offset\r\n   * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\r\n   */\n  function UtcOffset(aData) {\n    this.fromData(aData);\n  }\n\n  UtcOffset.prototype = {\n    /**\r\n     * The hours in the utc-offset\r\n     * @type {Number}\r\n     */\n    hours: 0,\n\n    /**\r\n     * The minutes in the utc-offset\r\n     * @type {Number}\r\n     */\n    minutes: 0,\n\n    /**\r\n     * The sign of the utc offset, 1 for positive offset, -1 for negative\r\n     * offsets.\r\n     * @type {Number}\r\n     */\n    factor: 1,\n\n    /**\r\n     * The type name, to be used in the jCal object.\r\n     * @constant\r\n     * @type {String}\r\n     * @default \"utc-offset\"\r\n     */\n    icaltype: \"utc-offset\",\n\n    /**\r\n     * Returns a clone of the utc offset object.\r\n     *\r\n     * @return {ICAL.UtcOffset}     The cloned object\r\n     */\n    clone: function clone() {\n      return ICAL.UtcOffset.fromSeconds(this.toSeconds());\n    },\n\n    /**\r\n     * Sets up the current instance using members from the passed data object.\r\n     *\r\n     * @param {Object} aData          An object with members of the utc offset\r\n     * @param {Number=} aData.hours   The hours for the utc offset\r\n     * @param {Number=} aData.minutes The minutes in the utc offset\r\n     * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\r\n     */\n    fromData: function fromData(aData) {\n      if (aData) {\n        for (var key in aData) {\n          /* istanbul ignore else */\n          if (aData.hasOwnProperty(key)) {\n            this[key] = aData[key];\n          }\n        }\n      }\n\n      this._normalize();\n    },\n\n    /**\r\n     * Sets up the current instance from the given seconds value. The seconds\r\n     * value is truncated to the minute. Offsets are wrapped when the world\r\n     * ends, the hour after UTC+14:00 is UTC-12:00.\r\n     *\r\n     * @param {Number} aSeconds         The seconds to convert into an offset\r\n     */\n    fromSeconds: function fromSeconds(aSeconds) {\n      var secs = Math.abs(aSeconds);\n      this.factor = aSeconds < 0 ? -1 : 1;\n      this.hours = ICAL.helpers.trunc(secs / 3600);\n      secs -= this.hours * 3600;\n      this.minutes = ICAL.helpers.trunc(secs / 60);\n      return this;\n    },\n\n    /**\r\n     * Convert the current offset to a value in seconds\r\n     *\r\n     * @return {Number}                 The offset in seconds\r\n     */\n    toSeconds: function toSeconds() {\n      return this.factor * (60 * this.minutes + 3600 * this.hours);\n    },\n\n    /**\r\n     * Compare this utc offset with another one.\r\n     *\r\n     * @param {ICAL.UtcOffset} other        The other offset to compare with\r\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\r\n     */\n    compare: function icaltime_compare(other) {\n      var a = this.toSeconds();\n      var b = other.toSeconds();\n      return (a > b) - (b > a);\n    },\n    _normalize: function _normalize() {\n      // Range: 97200 seconds (with 1 hour inbetween)\n      var secs = this.toSeconds();\n      var factor = this.factor;\n\n      while (secs < -43200) {\n        // = UTC-12:00\n        secs += 97200;\n      }\n\n      while (secs > 50400) {\n        // = UTC+14:00\n        secs -= 97200;\n      }\n\n      this.fromSeconds(secs); // Avoid changing the factor when on zero seconds\n\n      if (secs == 0) {\n        this.factor = factor;\n      }\n    },\n\n    /**\r\n     * The iCalendar string representation of this utc-offset.\r\n     * @return {String}\r\n     */\n    toICALString: function toICALString() {\n      return ICAL.design.icalendar.value['utc-offset'].toICAL(this.toString());\n    },\n\n    /**\r\n     * The string representation of this utc-offset.\r\n     * @return {String}\r\n     */\n    toString: function toString() {\n      return (this.factor == 1 ? \"+\" : \"-\") + ICAL.helpers.pad2(this.hours) + ':' + ICAL.helpers.pad2(this.minutes);\n    }\n  };\n  /**\r\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed string.\r\n   *\r\n   * @param {String} aString    The string to parse\r\n   * @return {ICAL.Duration}    The created utc-offset instance\r\n   */\n\n  UtcOffset.fromString = function (aString) {\n    // -05:00\n    var options = {}; //TODO: support seconds per rfc5545 ?\n\n    options.factor = aString[0] === '+' ? 1 : -1;\n    options.hours = ICAL.helpers.strictParseInt(aString.substr(1, 2));\n    options.minutes = ICAL.helpers.strictParseInt(aString.substr(4, 2));\n    return new ICAL.UtcOffset(options);\n  };\n  /**\r\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed seconds\r\n   * value.\r\n   *\r\n   * @param {Number} aSeconds       The number of seconds to convert\r\n   */\n\n\n  UtcOffset.fromSeconds = function (aSeconds) {\n    var instance = new UtcOffset();\n    instance.fromSeconds(aSeconds);\n    return instance;\n  };\n\n  return UtcOffset;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\r\n * This symbol is further described later on\r\n * @ignore\r\n */\n\n\nICAL.Binary = function () {\n  /**\r\n   * @classdesc\r\n   * Represents the BINARY value type, which contains extra methods for\r\n   * encoding and decoding.\r\n   *\r\n   * @class\r\n   * @alias ICAL.Binary\r\n   * @param {String} aValue     The binary data for this value\r\n   */\n  function Binary(aValue) {\n    this.value = aValue;\n  }\n\n  Binary.prototype = {\n    /**\r\n     * The type name, to be used in the jCal object.\r\n     * @default \"binary\"\r\n     * @constant\r\n     */\n    icaltype: \"binary\",\n\n    /**\r\n     * Base64 decode the current value\r\n     *\r\n     * @return {String}         The base64-decoded value\r\n     */\n    decodeValue: function decodeValue() {\n      return this._b64_decode(this.value);\n    },\n\n    /**\r\n     * Encodes the passed parameter with base64 and sets the internal\r\n     * value to the result.\r\n     *\r\n     * @param {String} aValue      The raw binary value to encode\r\n     */\n    setEncodedValue: function setEncodedValue(aValue) {\n      this.value = this._b64_encode(aValue);\n    },\n    _b64_encode: function base64_encode(data) {\n      // http://kevin.vanzonneveld.net\n      // +   original by: Tyler Akins (http://rumkin.com)\n      // +   improved by: Bayron Guevara\n      // +   improved by: Thunder.m\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   bugfixed by: Pellentesque Malesuada\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   improved by: Rafał Kukawski (http://kukawski.pl)\n      // *     example 1: base64_encode('Kevin van Zonneveld');\n      // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='\n      // mozilla has this native\n      // - but breaks in 2.0.0.12!\n      //if (typeof this.window['atob'] == 'function') {\n      //    return atob(data);\n      //}\n      var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      var o1,\n          o2,\n          o3,\n          h1,\n          h2,\n          h3,\n          h4,\n          bits,\n          i = 0,\n          ac = 0,\n          enc = \"\",\n          tmp_arr = [];\n\n      if (!data) {\n        return data;\n      }\n\n      do {\n        // pack three octets into four hexets\n        o1 = data.charCodeAt(i++);\n        o2 = data.charCodeAt(i++);\n        o3 = data.charCodeAt(i++);\n        bits = o1 << 16 | o2 << 8 | o3;\n        h1 = bits >> 18 & 0x3f;\n        h2 = bits >> 12 & 0x3f;\n        h3 = bits >> 6 & 0x3f;\n        h4 = bits & 0x3f; // use hexets to index into b64, and append result to encoded string\n\n        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n      } while (i < data.length);\n\n      enc = tmp_arr.join('');\n      var r = data.length % 3;\n      return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);\n    },\n    _b64_decode: function base64_decode(data) {\n      // http://kevin.vanzonneveld.net\n      // +   original by: Tyler Akins (http://rumkin.com)\n      // +   improved by: Thunder.m\n      // +      input by: Aman Gupta\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +   bugfixed by: Onno Marsman\n      // +   bugfixed by: Pellentesque Malesuada\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // +      input by: Brett Zamir (http://brett-zamir.me)\n      // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n      // *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');\n      // *     returns 1: 'Kevin van Zonneveld'\n      // mozilla has this native\n      // - but breaks in 2.0.0.12!\n      //if (typeof this.window['btoa'] == 'function') {\n      //    return btoa(data);\n      //}\n      var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      var o1,\n          o2,\n          o3,\n          h1,\n          h2,\n          h3,\n          h4,\n          bits,\n          i = 0,\n          ac = 0,\n          dec = \"\",\n          tmp_arr = [];\n\n      if (!data) {\n        return data;\n      }\n\n      data += '';\n\n      do {\n        // unpack four hexets into three octets using index points in b64\n        h1 = b64.indexOf(data.charAt(i++));\n        h2 = b64.indexOf(data.charAt(i++));\n        h3 = b64.indexOf(data.charAt(i++));\n        h4 = b64.indexOf(data.charAt(i++));\n        bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n        o1 = bits >> 16 & 0xff;\n        o2 = bits >> 8 & 0xff;\n        o3 = bits & 0xff;\n\n        if (h3 == 64) {\n          tmp_arr[ac++] = String.fromCharCode(o1);\n        } else if (h4 == 64) {\n          tmp_arr[ac++] = String.fromCharCode(o1, o2);\n        } else {\n          tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);\n        }\n      } while (i < data.length);\n\n      dec = tmp_arr.join('');\n      return dec;\n    },\n\n    /**\r\n     * The string representation of this value\r\n     * @return {String}\r\n     */\n    toString: function toString() {\n      return this.value;\n    }\n  };\n  /**\r\n   * Creates a binary value from the given string.\r\n   *\r\n   * @param {String} aString        The binary value string\r\n   * @return {ICAL.Binary}          The binary value instance\r\n   */\n\n  Binary.fromString = function (aString) {\n    return new Binary(aString);\n  };\n\n  return Binary;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n(function () {\n  /**\r\n   * @classdesc\r\n   * This class represents the \"period\" value type, with various calculation\r\n   * and manipulation methods.\r\n   *\r\n   * @description\r\n   * The passed data object cannot contain both and end date and a duration.\r\n   *\r\n   * @class\r\n   * @param {Object} aData                  An object with members of the period\r\n   * @param {ICAL.Time=} aData.start        The start of the period\r\n   * @param {ICAL.Time=} aData.end          The end of the period\r\n   * @param {ICAL.Duration=} aData.duration The duration of the period\r\n   */\n  ICAL.Period = function icalperiod(aData) {\n    this.wrappedJSObject = this;\n\n    if (aData && 'start' in aData) {\n      if (aData.start && !(aData.start instanceof ICAL.Time)) {\n        throw new TypeError('.start must be an instance of ICAL.Time');\n      }\n\n      this.start = aData.start;\n    }\n\n    if (aData && aData.end && aData.duration) {\n      throw new Error('cannot accept both end and duration');\n    }\n\n    if (aData && 'end' in aData) {\n      if (aData.end && !(aData.end instanceof ICAL.Time)) {\n        throw new TypeError('.end must be an instance of ICAL.Time');\n      }\n\n      this.end = aData.end;\n    }\n\n    if (aData && 'duration' in aData) {\n      if (aData.duration && !(aData.duration instanceof ICAL.Duration)) {\n        throw new TypeError('.duration must be an instance of ICAL.Duration');\n      }\n\n      this.duration = aData.duration;\n    }\n  };\n\n  ICAL.Period.prototype = {\n    /**\r\n     * The start of the period\r\n     * @type {ICAL.Time}\r\n     */\n    start: null,\n\n    /**\r\n     * The end of the period\r\n     * @type {ICAL.Time}\r\n     */\n    end: null,\n\n    /**\r\n     * The duration of the period\r\n     * @type {ICAL.Duration}\r\n     */\n    duration: null,\n\n    /**\r\n     * The class identifier.\r\n     * @constant\r\n     * @type {String}\r\n     * @default \"icalperiod\"\r\n     */\n    icalclass: \"icalperiod\",\n\n    /**\r\n     * The type name, to be used in the jCal object.\r\n     * @constant\r\n     * @type {String}\r\n     * @default \"period\"\r\n     */\n    icaltype: \"period\",\n\n    /**\r\n     * Returns a clone of the duration object.\r\n     *\r\n     * @return {ICAL.Period}      The cloned object\r\n     */\n    clone: function clone() {\n      return ICAL.Period.fromData({\n        start: this.start ? this.start.clone() : null,\n        end: this.end ? this.end.clone() : null,\n        duration: this.duration ? this.duration.clone() : null\n      });\n    },\n\n    /**\r\n     * Calculates the duration of the period, either directly or by subtracting\r\n     * start from end date.\r\n     *\r\n     * @return {ICAL.Duration}      The calculated duration\r\n     */\n    getDuration: function duration() {\n      if (this.duration) {\n        return this.duration;\n      } else {\n        return this.end.subtractDate(this.start);\n      }\n    },\n\n    /**\r\n     * Calculates the end date of the period, either directly or by adding\r\n     * duration to start date.\r\n     *\r\n     * @return {ICAL.Time}          The calculated end date\r\n     */\n    getEnd: function getEnd() {\n      if (this.end) {\n        return this.end;\n      } else {\n        var end = this.start.clone();\n        end.addDuration(this.duration);\n        return end;\n      }\n    },\n\n    /**\r\n     * The string representation of this period.\r\n     * @return {String}\r\n     */\n    toString: function toString() {\n      return this.start + \"/\" + (this.end || this.duration);\n    },\n\n    /**\r\n     * The jCal representation of this period type.\r\n     * @return {Object}\r\n     */\n    toJSON: function toJSON() {\n      return [this.start.toString(), (this.end || this.duration).toString()];\n    },\n\n    /**\r\n     * The iCalendar string representation of this period.\r\n     * @return {String}\r\n     */\n    toICALString: function toICALString() {\n      return this.start.toICALString() + \"/\" + (this.end || this.duration).toICALString();\n    }\n  };\n  /**\r\n   * Creates a new {@link ICAL.Period} instance from the passed string.\r\n   *\r\n   * @param {String} str            The string to parse\r\n   * @param {ICAL.Property} prop    The property this period will be on\r\n   * @return {ICAL.Period}          The created period instance\r\n   */\n\n  ICAL.Period.fromString = function fromString(str, prop) {\n    var parts = str.split('/');\n\n    if (parts.length !== 2) {\n      throw new Error('Invalid string value: \"' + str + '\" must contain a \"/\" char.');\n    }\n\n    var options = {\n      start: ICAL.Time.fromDateTimeString(parts[0], prop)\n    };\n    var end = parts[1];\n\n    if (ICAL.Duration.isValueString(end)) {\n      options.duration = ICAL.Duration.fromString(end);\n    } else {\n      options.end = ICAL.Time.fromDateTimeString(end, prop);\n    }\n\n    return new ICAL.Period(options);\n  };\n  /**\r\n   * Creates a new {@link ICAL.Period} instance from the given data object.\r\n   * The passed data object cannot contain both and end date and a duration.\r\n   *\r\n   * @param {Object} aData                  An object with members of the period\r\n   * @param {ICAL.Time=} aData.start        The start of the period\r\n   * @param {ICAL.Time=} aData.end          The end of the period\r\n   * @param {ICAL.Duration=} aData.duration The duration of the period\r\n   * @return {ICAL.Period}                  The period instance\r\n   */\n\n\n  ICAL.Period.fromData = function fromData(aData) {\n    return new ICAL.Period(aData);\n  };\n  /**\r\n   * Returns a new period instance from the given jCal data array. The first\r\n   * member is always the start date string, the second member is either a\r\n   * duration or end date string.\r\n   *\r\n   * @param {Array<String,String>} aData    The jCal data array\r\n   * @param {ICAL.Property} aProp           The property this jCal data is on\r\n   * @param {Boolean} aLenient              If true, data value can be both date and date-time\r\n   * @return {ICAL.Period}                  The period instance\r\n   */\n\n\n  ICAL.Period.fromJSON = function (aData, aProp, aLenient) {\n    function fromDateOrDateTimeString(aValue, aProp) {\n      if (aLenient) {\n        return ICAL.Time.fromString(aValue, aProp);\n      } else {\n        return ICAL.Time.fromDateTimeString(aValue, aProp);\n      }\n    }\n\n    if (ICAL.Duration.isValueString(aData[1])) {\n      return ICAL.Period.fromData({\n        start: fromDateOrDateTimeString(aData[0], aProp),\n        duration: ICAL.Duration.fromString(aData[1])\n      });\n    } else {\n      return ICAL.Period.fromData({\n        start: fromDateOrDateTimeString(aData[0], aProp),\n        end: fromDateOrDateTimeString(aData[1], aProp)\n      });\n    }\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n(function () {\n  var DURATION_LETTERS = /([PDWHMTS]{1,1})/;\n  /**\r\n   * @classdesc\r\n   * This class represents the \"duration\" value type, with various calculation\r\n   * and manipulation methods.\r\n   *\r\n   * @class\r\n   * @alias ICAL.Duration\r\n   * @param {Object} data               An object with members of the duration\r\n   * @param {Number} data.weeks         Duration in weeks\r\n   * @param {Number} data.days          Duration in days\r\n   * @param {Number} data.hours         Duration in hours\r\n   * @param {Number} data.minutes       Duration in minutes\r\n   * @param {Number} data.seconds       Duration in seconds\r\n   * @param {Boolean} data.isNegative   If true, the duration is negative\r\n   */\n\n  ICAL.Duration = function icalduration(data) {\n    this.wrappedJSObject = this;\n    this.fromData(data);\n  };\n\n  ICAL.Duration.prototype = {\n    /**\r\n     * The weeks in this duration\r\n     * @type {Number}\r\n     * @default 0\r\n     */\n    weeks: 0,\n\n    /**\r\n     * The days in this duration\r\n     * @type {Number}\r\n     * @default 0\r\n     */\n    days: 0,\n\n    /**\r\n     * The days in this duration\r\n     * @type {Number}\r\n     * @default 0\r\n     */\n    hours: 0,\n\n    /**\r\n     * The minutes in this duration\r\n     * @type {Number}\r\n     * @default 0\r\n     */\n    minutes: 0,\n\n    /**\r\n     * The seconds in this duration\r\n     * @type {Number}\r\n     * @default 0\r\n     */\n    seconds: 0,\n\n    /**\r\n     * The seconds in this duration\r\n     * @type {Boolean}\r\n     * @default false\r\n     */\n    isNegative: false,\n\n    /**\r\n     * The class identifier.\r\n     * @constant\r\n     * @type {String}\r\n     * @default \"icalduration\"\r\n     */\n    icalclass: \"icalduration\",\n\n    /**\r\n     * The type name, to be used in the jCal object.\r\n     * @constant\r\n     * @type {String}\r\n     * @default \"duration\"\r\n     */\n    icaltype: \"duration\",\n\n    /**\r\n     * Returns a clone of the duration object.\r\n     *\r\n     * @return {ICAL.Duration}      The cloned object\r\n     */\n    clone: function clone() {\n      return ICAL.Duration.fromData(this);\n    },\n\n    /**\r\n     * The duration value expressed as a number of seconds.\r\n     *\r\n     * @return {Number}             The duration value in seconds\r\n     */\n    toSeconds: function toSeconds() {\n      var seconds = this.seconds + 60 * this.minutes + 3600 * this.hours + 86400 * this.days + 7 * 86400 * this.weeks;\n      return this.isNegative ? -seconds : seconds;\n    },\n\n    /**\r\n     * Reads the passed seconds value into this duration object. Afterwards,\r\n     * members like {@link ICAL.Duration#days days} and {@link ICAL.Duration#weeks weeks} will be set up\r\n     * accordingly.\r\n     *\r\n     * @param {Number} aSeconds     The duration value in seconds\r\n     * @return {ICAL.Duration}      Returns this instance\r\n     */\n    fromSeconds: function fromSeconds(aSeconds) {\n      var secs = Math.abs(aSeconds);\n      this.isNegative = aSeconds < 0;\n      this.days = ICAL.helpers.trunc(secs / 86400); // If we have a flat number of weeks, use them.\n\n      if (this.days % 7 == 0) {\n        this.weeks = this.days / 7;\n        this.days = 0;\n      } else {\n        this.weeks = 0;\n      }\n\n      secs -= (this.days + 7 * this.weeks) * 86400;\n      this.hours = ICAL.helpers.trunc(secs / 3600);\n      secs -= this.hours * 3600;\n      this.minutes = ICAL.helpers.trunc(secs / 60);\n      secs -= this.minutes * 60;\n      this.seconds = secs;\n      return this;\n    },\n\n    /**\r\n     * Sets up the current instance using members from the passed data object.\r\n     *\r\n     * @param {Object} aData               An object with members of the duration\r\n     * @param {Number} aData.weeks         Duration in weeks\r\n     * @param {Number} aData.days          Duration in days\r\n     * @param {Number} aData.hours         Duration in hours\r\n     * @param {Number} aData.minutes       Duration in minutes\r\n     * @param {Number} aData.seconds       Duration in seconds\r\n     * @param {Boolean} aData.isNegative   If true, the duration is negative\r\n     */\n    fromData: function fromData(aData) {\n      var propsToCopy = [\"weeks\", \"days\", \"hours\", \"minutes\", \"seconds\", \"isNegative\"];\n\n      for (var key in propsToCopy) {\n        /* istanbul ignore if */\n        if (!propsToCopy.hasOwnProperty(key)) {\n          continue;\n        }\n\n        var prop = propsToCopy[key];\n\n        if (aData && prop in aData) {\n          this[prop] = aData[prop];\n        } else {\n          this[prop] = 0;\n        }\n      }\n    },\n\n    /**\r\n     * Resets the duration instance to the default values, i.e. PT0S\r\n     */\n    reset: function reset() {\n      this.isNegative = false;\n      this.weeks = 0;\n      this.days = 0;\n      this.hours = 0;\n      this.minutes = 0;\n      this.seconds = 0;\n    },\n\n    /**\r\n     * Compares the duration instance with another one.\r\n     *\r\n     * @param {ICAL.Duration} aOther        The instance to compare with\r\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\r\n     */\n    compare: function compare(aOther) {\n      var thisSeconds = this.toSeconds();\n      var otherSeconds = aOther.toSeconds();\n      return (thisSeconds > otherSeconds) - (thisSeconds < otherSeconds);\n    },\n\n    /**\r\n     * Normalizes the duration instance. For example, a duration with a value\r\n     * of 61 seconds will be normalized to 1 minute and 1 second.\r\n     */\n    normalize: function normalize() {\n      this.fromSeconds(this.toSeconds());\n    },\n\n    /**\r\n     * The string representation of this duration.\r\n     * @return {String}\r\n     */\n    toString: function toString() {\n      if (this.toSeconds() == 0) {\n        return \"PT0S\";\n      } else {\n        var str = \"\";\n        if (this.isNegative) str += \"-\";\n        str += \"P\";\n        if (this.weeks) str += this.weeks + \"W\";\n        if (this.days) str += this.days + \"D\";\n\n        if (this.hours || this.minutes || this.seconds) {\n          str += \"T\";\n          if (this.hours) str += this.hours + \"H\";\n          if (this.minutes) str += this.minutes + \"M\";\n          if (this.seconds) str += this.seconds + \"S\";\n        }\n\n        return str;\n      }\n    },\n\n    /**\r\n     * The iCalendar string representation of this duration.\r\n     * @return {String}\r\n     */\n    toICALString: function toICALString() {\n      return this.toString();\n    }\n  };\n  /**\r\n   * Returns a new ICAL.Duration instance from the passed seconds value.\r\n   *\r\n   * @param {Number} aSeconds       The seconds to create the instance from\r\n   * @return {ICAL.Duration}        The newly created duration instance\r\n   */\n\n  ICAL.Duration.fromSeconds = function icalduration_from_seconds(aSeconds) {\n    return new ICAL.Duration().fromSeconds(aSeconds);\n  };\n  /**\r\n   * Internal helper function to handle a chunk of a duration.\r\n   *\r\n   * @param {String} letter type of duration chunk\r\n   * @param {String} number numeric value or -/+\r\n   * @param {Object} dict target to assign values to\r\n   */\n\n\n  function parseDurationChunk(letter, number, object) {\n    var type;\n\n    switch (letter) {\n      case 'P':\n        if (number && number === '-') {\n          object.isNegative = true;\n        } else {\n          object.isNegative = false;\n        } // period\n\n\n        break;\n\n      case 'D':\n        type = 'days';\n        break;\n\n      case 'W':\n        type = 'weeks';\n        break;\n\n      case 'H':\n        type = 'hours';\n        break;\n\n      case 'M':\n        type = 'minutes';\n        break;\n\n      case 'S':\n        type = 'seconds';\n        break;\n\n      default:\n        // Not a valid chunk\n        return 0;\n    }\n\n    if (type) {\n      if (!number && number !== 0) {\n        throw new Error('invalid duration value: Missing number before \"' + letter + '\"');\n      }\n\n      var num = parseInt(number, 10);\n\n      if (ICAL.helpers.isStrictlyNaN(num)) {\n        throw new Error('invalid duration value: Invalid number \"' + number + '\" before \"' + letter + '\"');\n      }\n\n      object[type] = num;\n    }\n\n    return 1;\n  }\n  /**\r\n   * Checks if the given string is an iCalendar duration value.\r\n   *\r\n   * @param {String} value      The raw ical value\r\n   * @return {Boolean}          True, if the given value is of the\r\n   *                              duration ical type\r\n   */\n\n\n  ICAL.Duration.isValueString = function (string) {\n    return string[0] === 'P' || string[1] === 'P';\n  };\n  /**\r\n   * Creates a new {@link ICAL.Duration} instance from the passed string.\r\n   *\r\n   * @param {String} aStr       The string to parse\r\n   * @return {ICAL.Duration}    The created duration instance\r\n   */\n\n\n  ICAL.Duration.fromString = function icalduration_from_string(aStr) {\n    var pos = 0;\n    var dict = Object.create(null);\n    var chunks = 0;\n\n    while ((pos = aStr.search(DURATION_LETTERS)) !== -1) {\n      var type = aStr[pos];\n      var numeric = aStr.substr(0, pos);\n      aStr = aStr.substr(pos + 1);\n      chunks += parseDurationChunk(type, numeric, dict);\n    }\n\n    if (chunks < 2) {\n      // There must be at least a chunk with \"P\" and some unit chunk\n      throw new Error('invalid duration value: Not enough duration components in \"' + aStr + '\"');\n    }\n\n    return new ICAL.Duration(dict);\n  };\n  /**\r\n   * Creates a new ICAL.Duration instance from the given data object.\r\n   *\r\n   * @param {Object} aData               An object with members of the duration\r\n   * @param {Number} aData.weeks         Duration in weeks\r\n   * @param {Number} aData.days          Duration in days\r\n   * @param {Number} aData.hours         Duration in hours\r\n   * @param {Number} aData.minutes       Duration in minutes\r\n   * @param {Number} aData.seconds       Duration in seconds\r\n   * @param {Boolean} aData.isNegative   If true, the duration is negative\r\n   * @return {ICAL.Duration}             The createad duration instance\r\n   */\n\n\n  ICAL.Duration.fromData = function icalduration_from_data(aData) {\n    return new ICAL.Duration(aData);\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2012 */\n\n\n(function () {\n  var OPTIONS = [\"tzid\", \"location\", \"tznames\", \"latitude\", \"longitude\"];\n  /**\r\n   * @classdesc\r\n   * Timezone representation, created by passing in a tzid and component.\r\n   *\r\n   * @example\r\n   * var vcalendar;\r\n   * var timezoneComp = vcalendar.getFirstSubcomponent('vtimezone');\r\n   * var tzid = timezoneComp.getFirstPropertyValue('tzid');\r\n   *\r\n   * var timezone = new ICAL.Timezone({\r\n   *   component: timezoneComp,\r\n   *   tzid\r\n   * });\r\n   *\r\n   * @class\r\n   * @param {ICAL.Component|Object} data options for class\r\n   * @param {String|ICAL.Component} data.component\r\n   *        If data is a simple object, then this member can be set to either a\r\n   *        string containing the component data, or an already parsed\r\n   *        ICAL.Component\r\n   * @param {String} data.tzid      The timezone identifier\r\n   * @param {String} data.location  The timezone locationw\r\n   * @param {String} data.tznames   An alternative string representation of the\r\n   *                                  timezone\r\n   * @param {Number} data.latitude  The latitude of the timezone\r\n   * @param {Number} data.longitude The longitude of the timezone\r\n   */\n\n  ICAL.Timezone = function icaltimezone(data) {\n    this.wrappedJSObject = this;\n    this.fromData(data);\n  };\n\n  ICAL.Timezone.prototype = {\n    /**\r\n     * Timezone identifier\r\n     * @type {String}\r\n     */\n    tzid: \"\",\n\n    /**\r\n     * Timezone location\r\n     * @type {String}\r\n     */\n    location: \"\",\n\n    /**\r\n     * Alternative timezone name, for the string representation\r\n     * @type {String}\r\n     */\n    tznames: \"\",\n\n    /**\r\n     * The primary latitude for the timezone.\r\n     * @type {Number}\r\n     */\n    latitude: 0.0,\n\n    /**\r\n     * The primary longitude for the timezone.\r\n     * @type {Number}\r\n     */\n    longitude: 0.0,\n\n    /**\r\n     * The vtimezone component for this timezone.\r\n     * @type {ICAL.Component}\r\n     */\n    component: null,\n\n    /**\r\n     * The year this timezone has been expanded to. All timezone transition\r\n     * dates until this year are known and can be used for calculation\r\n     *\r\n     * @private\r\n     * @type {Number}\r\n     */\n    expandedUntilYear: 0,\n\n    /**\r\n     * The class identifier.\r\n     * @constant\r\n     * @type {String}\r\n     * @default \"icaltimezone\"\r\n     */\n    icalclass: \"icaltimezone\",\n\n    /**\r\n     * Sets up the current instance using members from the passed data object.\r\n     *\r\n     * @param {ICAL.Component|Object} aData options for class\r\n     * @param {String|ICAL.Component} aData.component\r\n     *        If aData is a simple object, then this member can be set to either a\r\n     *        string containing the component data, or an already parsed\r\n     *        ICAL.Component\r\n     * @param {String} aData.tzid      The timezone identifier\r\n     * @param {String} aData.location  The timezone locationw\r\n     * @param {String} aData.tznames   An alternative string representation of the\r\n     *                                  timezone\r\n     * @param {Number} aData.latitude  The latitude of the timezone\r\n     * @param {Number} aData.longitude The longitude of the timezone\r\n     */\n    fromData: function fromData(aData) {\n      this.expandedUntilYear = 0;\n      this.changes = [];\n\n      if (aData instanceof ICAL.Component) {\n        // Either a component is passed directly\n        this.component = aData;\n      } else {\n        // Otherwise the component may be in the data object\n        if (aData && \"component\" in aData) {\n          if (typeof aData.component == \"string\") {\n            // If a string was passed, parse it as a component\n            var jCal = ICAL.parse(aData.component);\n            this.component = new ICAL.Component(jCal);\n          } else if (aData.component instanceof ICAL.Component) {\n            // If it was a component already, then just set it\n            this.component = aData.component;\n          } else {\n            // Otherwise just null out the component\n            this.component = null;\n          }\n        } // Copy remaining passed properties\n\n\n        for (var key in OPTIONS) {\n          /* istanbul ignore else */\n          if (OPTIONS.hasOwnProperty(key)) {\n            var prop = OPTIONS[key];\n\n            if (aData && prop in aData) {\n              this[prop] = aData[prop];\n            }\n          }\n        }\n      } // If we have a component but no TZID, attempt to get it from the\n      // component's properties.\n\n\n      if (this.component instanceof ICAL.Component && !this.tzid) {\n        this.tzid = this.component.getFirstPropertyValue('tzid');\n      }\n\n      return this;\n    },\n\n    /**\r\n     * Finds the utcOffset the given time would occur in this timezone.\r\n     *\r\n     * @param {ICAL.Time} tt        The time to check for\r\n     * @return {Number} utc offset in seconds\r\n     */\n    utcOffset: function utcOffset(tt) {\n      if (this == ICAL.Timezone.utcTimezone || this == ICAL.Timezone.localTimezone) {\n        return 0;\n      }\n\n      this._ensureCoverage(tt.year);\n\n      if (!this.changes.length) {\n        return 0;\n      }\n\n      var tt_change = {\n        year: tt.year,\n        month: tt.month,\n        day: tt.day,\n        hour: tt.hour,\n        minute: tt.minute,\n        second: tt.second\n      };\n\n      var change_num = this._findNearbyChange(tt_change);\n\n      var change_num_to_use = -1;\n      var step = 1; // TODO: replace with bin search?\n\n      for (;;) {\n        var change = ICAL.helpers.clone(this.changes[change_num], true);\n\n        if (change.utcOffset < change.prevUtcOffset) {\n          ICAL.Timezone.adjust_change(change, 0, 0, 0, change.utcOffset);\n        } else {\n          ICAL.Timezone.adjust_change(change, 0, 0, 0, change.prevUtcOffset);\n        }\n\n        var cmp = ICAL.Timezone._compare_change_fn(tt_change, change);\n\n        if (cmp >= 0) {\n          change_num_to_use = change_num;\n        } else {\n          step = -1;\n        }\n\n        if (step == -1 && change_num_to_use != -1) {\n          break;\n        }\n\n        change_num += step;\n\n        if (change_num < 0) {\n          return 0;\n        }\n\n        if (change_num >= this.changes.length) {\n          break;\n        }\n      }\n\n      var zone_change = this.changes[change_num_to_use];\n      var utcOffset_change = zone_change.utcOffset - zone_change.prevUtcOffset;\n\n      if (utcOffset_change < 0 && change_num_to_use > 0) {\n        var tmp_change = ICAL.helpers.clone(zone_change, true);\n        ICAL.Timezone.adjust_change(tmp_change, 0, 0, 0, tmp_change.prevUtcOffset);\n\n        if (ICAL.Timezone._compare_change_fn(tt_change, tmp_change) < 0) {\n          var prev_zone_change = this.changes[change_num_to_use - 1];\n          var want_daylight = false; // TODO\n\n          if (zone_change.is_daylight != want_daylight && prev_zone_change.is_daylight == want_daylight) {\n            zone_change = prev_zone_change;\n          }\n        }\n      } // TODO return is_daylight?\n\n\n      return zone_change.utcOffset;\n    },\n    _findNearbyChange: function icaltimezone_find_nearby_change(change) {\n      // find the closest match\n      var idx = ICAL.helpers.binsearchInsert(this.changes, change, ICAL.Timezone._compare_change_fn);\n\n      if (idx >= this.changes.length) {\n        return this.changes.length - 1;\n      }\n\n      return idx;\n    },\n    _ensureCoverage: function _ensureCoverage(aYear) {\n      if (ICAL.Timezone._minimumExpansionYear == -1) {\n        var today = ICAL.Time.now();\n        ICAL.Timezone._minimumExpansionYear = today.year;\n      }\n\n      var changesEndYear = aYear;\n\n      if (changesEndYear < ICAL.Timezone._minimumExpansionYear) {\n        changesEndYear = ICAL.Timezone._minimumExpansionYear;\n      }\n\n      changesEndYear += ICAL.Timezone.EXTRA_COVERAGE;\n\n      if (changesEndYear > ICAL.Timezone.MAX_YEAR) {\n        changesEndYear = ICAL.Timezone.MAX_YEAR;\n      }\n\n      if (!this.changes.length || this.expandedUntilYear < aYear) {\n        var subcomps = this.component.getAllSubcomponents();\n        var compLen = subcomps.length;\n        var compIdx = 0;\n\n        for (; compIdx < compLen; compIdx++) {\n          this._expandComponent(subcomps[compIdx], changesEndYear, this.changes);\n        }\n\n        this.changes.sort(ICAL.Timezone._compare_change_fn);\n        this.expandedUntilYear = changesEndYear;\n      }\n    },\n    _expandComponent: function _expandComponent(aComponent, aYear, changes) {\n      if (!aComponent.hasProperty(\"dtstart\") || !aComponent.hasProperty(\"tzoffsetto\") || !aComponent.hasProperty(\"tzoffsetfrom\")) {\n        return null;\n      }\n\n      var dtstart = aComponent.getFirstProperty(\"dtstart\").getFirstValue();\n      var change;\n\n      function convert_tzoffset(offset) {\n        return offset.factor * (offset.hours * 3600 + offset.minutes * 60);\n      }\n\n      function init_changes() {\n        var changebase = {};\n        changebase.is_daylight = aComponent.name == \"daylight\";\n        changebase.utcOffset = convert_tzoffset(aComponent.getFirstProperty(\"tzoffsetto\").getFirstValue());\n        changebase.prevUtcOffset = convert_tzoffset(aComponent.getFirstProperty(\"tzoffsetfrom\").getFirstValue());\n        return changebase;\n      }\n\n      if (!aComponent.hasProperty(\"rrule\") && !aComponent.hasProperty(\"rdate\")) {\n        change = init_changes();\n        change.year = dtstart.year;\n        change.month = dtstart.month;\n        change.day = dtstart.day;\n        change.hour = dtstart.hour;\n        change.minute = dtstart.minute;\n        change.second = dtstart.second;\n        ICAL.Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n        changes.push(change);\n      } else {\n        var props = aComponent.getAllProperties(\"rdate\");\n\n        for (var rdatekey in props) {\n          /* istanbul ignore if */\n          if (!props.hasOwnProperty(rdatekey)) {\n            continue;\n          }\n\n          var rdate = props[rdatekey];\n          var time = rdate.getFirstValue();\n          change = init_changes();\n          change.year = time.year;\n          change.month = time.month;\n          change.day = time.day;\n\n          if (time.isDate) {\n            change.hour = dtstart.hour;\n            change.minute = dtstart.minute;\n            change.second = dtstart.second;\n\n            if (dtstart.zone != ICAL.Timezone.utcTimezone) {\n              ICAL.Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n            }\n          } else {\n            change.hour = time.hour;\n            change.minute = time.minute;\n            change.second = time.second;\n\n            if (time.zone != ICAL.Timezone.utcTimezone) {\n              ICAL.Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n            }\n          }\n\n          changes.push(change);\n        }\n\n        var rrule = aComponent.getFirstProperty(\"rrule\");\n\n        if (rrule) {\n          rrule = rrule.getFirstValue();\n          change = init_changes();\n\n          if (rrule.until && rrule.until.zone == ICAL.Timezone.utcTimezone) {\n            rrule.until.adjust(0, 0, 0, change.prevUtcOffset);\n            rrule.until.zone = ICAL.Timezone.localTimezone;\n          }\n\n          var iterator = rrule.iterator(dtstart);\n          var occ;\n\n          while (occ = iterator.next()) {\n            change = init_changes();\n\n            if (occ.year > aYear || !occ) {\n              break;\n            }\n\n            change.year = occ.year;\n            change.month = occ.month;\n            change.day = occ.day;\n            change.hour = occ.hour;\n            change.minute = occ.minute;\n            change.second = occ.second;\n            change.isDate = occ.isDate;\n            ICAL.Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);\n            changes.push(change);\n          }\n        }\n      }\n\n      return changes;\n    },\n\n    /**\r\n     * The string representation of this timezone.\r\n     * @return {String}\r\n     */\n    toString: function toString() {\n      return this.tznames ? this.tznames : this.tzid;\n    }\n  };\n\n  ICAL.Timezone._compare_change_fn = function icaltimezone_compare_change_fn(a, b) {\n    if (a.year < b.year) return -1;else if (a.year > b.year) return 1;\n    if (a.month < b.month) return -1;else if (a.month > b.month) return 1;\n    if (a.day < b.day) return -1;else if (a.day > b.day) return 1;\n    if (a.hour < b.hour) return -1;else if (a.hour > b.hour) return 1;\n    if (a.minute < b.minute) return -1;else if (a.minute > b.minute) return 1;\n    if (a.second < b.second) return -1;else if (a.second > b.second) return 1;\n    return 0;\n  };\n  /**\r\n   * Convert the date/time from one zone to the next.\r\n   *\r\n   * @param {ICAL.Time} tt                  The time to convert\r\n   * @param {ICAL.Timezone} from_zone       The source zone to convert from\r\n   * @param {ICAL.Timezone} to_zone         The target zone to convert to\r\n   * @return {ICAL.Time}                    The converted date/time object\r\n   */\n\n\n  ICAL.Timezone.convert_time = function icaltimezone_convert_time(tt, from_zone, to_zone) {\n    if (tt.isDate || from_zone.tzid == to_zone.tzid || from_zone == ICAL.Timezone.localTimezone || to_zone == ICAL.Timezone.localTimezone) {\n      tt.zone = to_zone;\n      return tt;\n    }\n\n    var utcOffset = from_zone.utcOffset(tt);\n    tt.adjust(0, 0, 0, -utcOffset);\n    utcOffset = to_zone.utcOffset(tt);\n    tt.adjust(0, 0, 0, utcOffset);\n    return null;\n  };\n  /**\r\n   * Creates a new ICAL.Timezone instance from the passed data object.\r\n   *\r\n   * @param {ICAL.Component|Object} aData options for class\r\n   * @param {String|ICAL.Component} aData.component\r\n   *        If aData is a simple object, then this member can be set to either a\r\n   *        string containing the component data, or an already parsed\r\n   *        ICAL.Component\r\n   * @param {String} aData.tzid      The timezone identifier\r\n   * @param {String} aData.location  The timezone locationw\r\n   * @param {String} aData.tznames   An alternative string representation of the\r\n   *                                  timezone\r\n   * @param {Number} aData.latitude  The latitude of the timezone\r\n   * @param {Number} aData.longitude The longitude of the timezone\r\n   */\n\n\n  ICAL.Timezone.fromData = function icaltimezone_fromData(aData) {\n    var tt = new ICAL.Timezone();\n    return tt.fromData(aData);\n  };\n  /**\r\n   * The instance describing the UTC timezone\r\n   * @type {ICAL.Timezone}\r\n   * @constant\r\n   * @instance\r\n   */\n\n\n  ICAL.Timezone.utcTimezone = ICAL.Timezone.fromData({\n    tzid: \"UTC\"\n  });\n  /**\r\n   * The instance describing the local timezone\r\n   * @type {ICAL.Timezone}\r\n   * @constant\r\n   * @instance\r\n   */\n\n  ICAL.Timezone.localTimezone = ICAL.Timezone.fromData({\n    tzid: \"floating\"\n  });\n  /**\r\n   * Adjust a timezone change object.\r\n   * @private\r\n   * @param {Object} change     The timezone change object\r\n   * @param {Number} days       The extra amount of days\r\n   * @param {Number} hours      The extra amount of hours\r\n   * @param {Number} minutes    The extra amount of minutes\r\n   * @param {Number} seconds    The extra amount of seconds\r\n   */\n\n  ICAL.Timezone.adjust_change = function icaltimezone_adjust_change(change, days, hours, minutes, seconds) {\n    return ICAL.Time.prototype.adjust.call(change, days, hours, minutes, seconds, change);\n  };\n\n  ICAL.Timezone._minimumExpansionYear = -1;\n  ICAL.Timezone.MAX_YEAR = 2035; // TODO this is because of time_t, which we don't need. Still usefull?\n\n  ICAL.Timezone.EXTRA_COVERAGE = 5;\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\r\n * This symbol is further described later on\r\n * @ignore\r\n */\n\n\nICAL.TimezoneService = function () {\n  var zones;\n  /**\r\n   * @classdesc\r\n   * Singleton class to contain timezones.  Right now its all manual registry in\r\n   * the future we may use this class to download timezone information or handle\r\n   * loading pre-expanded timezones.\r\n   *\r\n   * @namespace\r\n   * @alias ICAL.TimezoneService\r\n   */\n\n  var TimezoneService = {\n    get count() {\n      return Object.keys(zones).length;\n    },\n\n    reset: function reset() {\n      zones = Object.create(null);\n      var utc = ICAL.Timezone.utcTimezone;\n      zones.Z = utc;\n      zones.UTC = utc;\n      zones.GMT = utc;\n    },\n\n    /**\r\n     * Checks if timezone id has been registered.\r\n     *\r\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\r\n     * @return {Boolean}        False, when not present\r\n     */\n    has: function has(tzid) {\n      return !!zones[tzid];\n    },\n\n    /**\r\n     * Returns a timezone by its tzid if present.\r\n     *\r\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\r\n     * @return {?ICAL.Timezone} The timezone, or null if not found\r\n     */\n    get: function get(tzid) {\n      return zones[tzid];\n    },\n\n    /**\r\n     * Registers a timezone object or component.\r\n     *\r\n     * @param {String=} name\r\n     *        The name of the timezone. Defaults to the component's TZID if not\r\n     *        passed.\r\n     * @param {ICAL.Component|ICAL.Timezone} zone\r\n     *        The initialized zone or vtimezone.\r\n     */\n    register: function register(name, timezone) {\n      if (name instanceof ICAL.Component) {\n        if (name.name === 'vtimezone') {\n          timezone = new ICAL.Timezone(name);\n          name = timezone.tzid;\n        }\n      }\n\n      if (timezone instanceof ICAL.Timezone) {\n        zones[name] = timezone;\n      } else {\n        throw new TypeError('timezone must be ICAL.Timezone or ICAL.Component');\n      }\n    },\n\n    /**\r\n     * Removes a timezone by its tzid from the list.\r\n     *\r\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\r\n     * @return {?ICAL.Timezone} The removed timezone, or null if not registered\r\n     */\n    remove: function remove(tzid) {\n      return delete zones[tzid];\n    }\n  }; // initialize defaults\n\n  TimezoneService.reset();\n  return TimezoneService;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n(function () {\n  /**\r\n   * @classdesc\r\n   * iCalendar Time representation (similar to JS Date object).  Fully\r\n   * independent of system (OS) timezone / time.  Unlike JS Date, the month\r\n   * January is 1, not zero.\r\n   *\r\n   * @example\r\n   * var time = new ICAL.Time({\r\n   *   year: 2012,\r\n   *   month: 10,\r\n   *   day: 11\r\n   *   minute: 0,\r\n   *   second: 0,\r\n   *   isDate: false\r\n   * });\r\n   *\r\n   *\r\n   * @alias ICAL.Time\r\n   * @class\r\n   * @param {Object} data           Time initialization\r\n   * @param {Number=} data.year     The year for this date\r\n   * @param {Number=} data.month    The month for this date\r\n   * @param {Number=} data.day      The day for this date\r\n   * @param {Number=} data.hour     The hour for this date\r\n   * @param {Number=} data.minute   The minute for this date\r\n   * @param {Number=} data.second   The second for this date\r\n   * @param {Boolean=} data.isDate  If true, the instance represents a date (as\r\n   *                                  opposed to a date-time)\r\n   * @param {ICAL.Timezone} zone timezone this position occurs in\r\n   */\n  ICAL.Time = function icaltime(data, zone) {\n    this.wrappedJSObject = this;\n    var time = this._time = Object.create(null);\n    /* time defaults */\n\n    time.year = 0;\n    time.month = 1;\n    time.day = 1;\n    time.hour = 0;\n    time.minute = 0;\n    time.second = 0;\n    time.isDate = false;\n    this.fromData(data, zone);\n  };\n\n  ICAL.Time._dowCache = {};\n  ICAL.Time._wnCache = {};\n  ICAL.Time.prototype = {\n    /**\r\n     * The class identifier.\r\n     * @constant\r\n     * @type {String}\r\n     * @default \"icaltime\"\r\n     */\n    icalclass: \"icaltime\",\n    _cachedUnixTime: null,\n\n    /**\r\n     * The type name, to be used in the jCal object. This value may change and\r\n     * is strictly defined by the {@link ICAL.Time#isDate isDate} member.\r\n     * @readonly\r\n     * @type {String}\r\n     * @default \"date-time\"\r\n     */\n    get icaltype() {\n      return this.isDate ? 'date' : 'date-time';\n    },\n\n    /**\r\n     * The timezone for this time.\r\n     * @type {ICAL.Timezone}\r\n     */\n    zone: null,\n\n    /**\r\n     * Internal uses to indicate that a change has been made and the next read\r\n     * operation must attempt to normalize the value (for example changing the\r\n     * day to 33).\r\n     *\r\n     * @type {Boolean}\r\n     * @private\r\n     */\n    _pendingNormalization: false,\n\n    /**\r\n     * Returns a clone of the time object.\r\n     *\r\n     * @return {ICAL.Time}              The cloned object\r\n     */\n    clone: function clone() {\n      return new ICAL.Time(this._time, this.zone);\n    },\n\n    /**\r\n     * Reset the time instance to epoch time\r\n     */\n    reset: function icaltime_reset() {\n      this.fromData(ICAL.Time.epochTime);\n      this.zone = ICAL.Timezone.utcTimezone;\n    },\n\n    /**\r\n     * Reset the time instance to the given date/time values.\r\n     *\r\n     * @param {Number} year             The year to set\r\n     * @param {Number} month            The month to set\r\n     * @param {Number} day              The day to set\r\n     * @param {Number} hour             The hour to set\r\n     * @param {Number} minute           The minute to set\r\n     * @param {Number} second           The second to set\r\n     * @param {ICAL.Timezone} timezone  The timezone to set\r\n     */\n    resetTo: function icaltime_resetTo(year, month, day, hour, minute, second, timezone) {\n      this.fromData({\n        year: year,\n        month: month,\n        day: day,\n        hour: hour,\n        minute: minute,\n        second: second,\n        zone: timezone\n      });\n    },\n\n    /**\r\n     * Set up the current instance from the Javascript date value.\r\n     *\r\n     * @param {?Date} aDate     The Javascript Date to read, or null to reset\r\n     * @param {Boolean} useUTC  If true, the UTC values of the date will be used\r\n     */\n    fromJSDate: function icaltime_fromJSDate(aDate, useUTC) {\n      if (!aDate) {\n        this.reset();\n      } else {\n        if (useUTC) {\n          this.zone = ICAL.Timezone.utcTimezone;\n          this.year = aDate.getUTCFullYear();\n          this.month = aDate.getUTCMonth() + 1;\n          this.day = aDate.getUTCDate();\n          this.hour = aDate.getUTCHours();\n          this.minute = aDate.getUTCMinutes();\n          this.second = aDate.getUTCSeconds();\n        } else {\n          this.zone = ICAL.Timezone.localTimezone;\n          this.year = aDate.getFullYear();\n          this.month = aDate.getMonth() + 1;\n          this.day = aDate.getDate();\n          this.hour = aDate.getHours();\n          this.minute = aDate.getMinutes();\n          this.second = aDate.getSeconds();\n        }\n      }\n\n      this._cachedUnixTime = null;\n      return this;\n    },\n\n    /**\r\n     * Sets up the current instance using members from the passed data object.\r\n     *\r\n     * @param {Object} aData            Time initialization\r\n     * @param {Number=} aData.year      The year for this date\r\n     * @param {Number=} aData.month     The month for this date\r\n     * @param {Number=} aData.day       The day for this date\r\n     * @param {Number=} aData.hour      The hour for this date\r\n     * @param {Number=} aData.minute    The minute for this date\r\n     * @param {Number=} aData.second    The second for this date\r\n     * @param {Boolean=} aData.isDate   If true, the instance represents a date\r\n     *                                    (as opposed to a date-time)\r\n     * @param {ICAL.Timezone=} aZone    Timezone this position occurs in\r\n     */\n    fromData: function fromData(aData, aZone) {\n      if (aData) {\n        for (var key in aData) {\n          /* istanbul ignore else */\n          if (Object.prototype.hasOwnProperty.call(aData, key)) {\n            // ical type cannot be set\n            if (key === 'icaltype') continue;\n            this[key] = aData[key];\n          }\n        }\n      }\n\n      if (aZone) {\n        this.zone = aZone;\n      }\n\n      if (aData && !(\"isDate\" in aData)) {\n        this.isDate = !(\"hour\" in aData);\n      } else if (aData && \"isDate\" in aData) {\n        this.isDate = aData.isDate;\n      }\n\n      if (aData && \"timezone\" in aData) {\n        var zone = ICAL.TimezoneService.get(aData.timezone);\n        this.zone = zone || ICAL.Timezone.localTimezone;\n      }\n\n      if (aData && \"zone\" in aData) {\n        this.zone = aData.zone;\n      }\n\n      if (!this.zone) {\n        this.zone = ICAL.Timezone.localTimezone;\n      }\n\n      this._cachedUnixTime = null;\n      return this;\n    },\n\n    /**\r\n     * Calculate the day of week.\r\n     * @param {ICAL.Time.weekDay=} aWeekStart\r\n     *        The week start weekday, defaults to SUNDAY\r\n     * @return {ICAL.Time.weekDay}\r\n     */\n    dayOfWeek: function icaltime_dayOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var dowCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + firstDow;\n\n      if (dowCacheKey in ICAL.Time._dowCache) {\n        return ICAL.Time._dowCache[dowCacheKey];\n      } // Using Zeller's algorithm\n\n\n      var q = this.day;\n      var m = this.month + (this.month < 3 ? 12 : 0);\n      var Y = this.year - (this.month < 3 ? 1 : 0);\n      var h = q + Y + ICAL.helpers.trunc((m + 1) * 26 / 10) + ICAL.helpers.trunc(Y / 4);\n      /* istanbul ignore else */\n\n      if (true\n      /* gregorian */\n      ) {\n        h += ICAL.helpers.trunc(Y / 100) * 6 + ICAL.helpers.trunc(Y / 400);\n      } else {\n        h += 5;\n      } // Normalize to 1 = wkst\n\n\n      h = (h + 7 - firstDow) % 7 + 1;\n      ICAL.Time._dowCache[dowCacheKey] = h;\n      return h;\n    },\n\n    /**\r\n     * Calculate the day of year.\r\n     * @return {Number}\r\n     */\n    dayOfYear: function dayOfYear() {\n      var is_leap = ICAL.Time.isLeapYear(this.year) ? 1 : 0;\n      var diypm = ICAL.Time.daysInYearPassedMonth;\n      return diypm[is_leap][this.month - 1] + this.day;\n    },\n\n    /**\r\n     * Returns a copy of the current date/time, rewound to the start of the\r\n     * week. The resulting ICAL.Time instance is of icaltype date, even if this\r\n     * is a date-time.\r\n     *\r\n     * @param {ICAL.Time.weekDay=} aWeekStart\r\n     *        The week start weekday, defaults to SUNDAY\r\n     * @return {ICAL.Time}      The start of the week (cloned)\r\n     */\n    startOfWeek: function startOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var result = this.clone();\n      result.day -= (this.dayOfWeek() + 7 - firstDow) % 7;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\r\n     * Returns a copy of the current date/time, shifted to the end of the week.\r\n     * The resulting ICAL.Time instance is of icaltype date, even if this is a\r\n     * date-time.\r\n     *\r\n     * @param {ICAL.Time.weekDay=} aWeekStart\r\n     *        The week start weekday, defaults to SUNDAY\r\n     * @return {ICAL.Time}      The end of the week (cloned)\r\n     */\n    endOfWeek: function endOfWeek(aWeekStart) {\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n      var result = this.clone();\n      result.day += (7 - this.dayOfWeek() + firstDow - ICAL.Time.SUNDAY) % 7;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\r\n     * Returns a copy of the current date/time, rewound to the start of the\r\n     * month. The resulting ICAL.Time instance is of icaltype date, even if\r\n     * this is a date-time.\r\n     *\r\n     * @return {ICAL.Time}      The start of the month (cloned)\r\n     */\n    startOfMonth: function startOfMonth() {\n      var result = this.clone();\n      result.day = 1;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\r\n     * Returns a copy of the current date/time, shifted to the end of the\r\n     * month.  The resulting ICAL.Time instance is of icaltype date, even if\r\n     * this is a date-time.\r\n     *\r\n     * @return {ICAL.Time}      The end of the month (cloned)\r\n     */\n    endOfMonth: function endOfMonth() {\n      var result = this.clone();\n      result.day = ICAL.Time.daysInMonth(result.month, result.year);\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\r\n     * Returns a copy of the current date/time, rewound to the start of the\r\n     * year. The resulting ICAL.Time instance is of icaltype date, even if\r\n     * this is a date-time.\r\n     *\r\n     * @return {ICAL.Time}      The start of the year (cloned)\r\n     */\n    startOfYear: function startOfYear() {\n      var result = this.clone();\n      result.day = 1;\n      result.month = 1;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\r\n     * Returns a copy of the current date/time, shifted to the end of the\r\n     * year.  The resulting ICAL.Time instance is of icaltype date, even if\r\n     * this is a date-time.\r\n     *\r\n     * @return {ICAL.Time}      The end of the year (cloned)\r\n     */\n    endOfYear: function endOfYear() {\n      var result = this.clone();\n      result.day = 31;\n      result.month = 12;\n      result.isDate = true;\n      result.hour = 0;\n      result.minute = 0;\n      result.second = 0;\n      return result;\n    },\n\n    /**\r\n     * First calculates the start of the week, then returns the day of year for\r\n     * this date. If the day falls into the previous year, the day is zero or negative.\r\n     *\r\n     * @param {ICAL.Time.weekDay=} aFirstDayOfWeek\r\n     *        The week start weekday, defaults to SUNDAY\r\n     * @return {Number}     The calculated day of year\r\n     */\n    startDoyWeek: function startDoyWeek(aFirstDayOfWeek) {\n      var firstDow = aFirstDayOfWeek || ICAL.Time.SUNDAY;\n      var delta = this.dayOfWeek() - firstDow;\n      if (delta < 0) delta += 7;\n      return this.dayOfYear() - delta;\n    },\n\n    /**\r\n     * Get the dominical letter for the current year. Letters range from A - G\r\n     * for common years, and AG to GF for leap years.\r\n     *\r\n     * @param {Number} yr           The year to retrieve the letter for\r\n     * @return {String}             The dominical letter.\r\n     */\n    getDominicalLetter: function getDominicalLetter() {\n      return ICAL.Time.getDominicalLetter(this.year);\n    },\n\n    /**\r\n     * Finds the nthWeekDay relative to the current month (not day).  The\r\n     * returned value is a day relative the month that this month belongs to so\r\n     * 1 would indicate the first of the month and 40 would indicate a day in\r\n     * the following month.\r\n     *\r\n     * @param {Number} aDayOfWeek   Day of the week see the day name constants\r\n     * @param {Number} aPos         Nth occurrence of a given week day values\r\n     *        of 1 and 0 both indicate the first weekday of that type. aPos may\r\n     *        be either positive or negative\r\n     *\r\n     * @return {Number} numeric value indicating a day relative\r\n     *                   to the current month of this time object\r\n     */\n    nthWeekDay: function icaltime_nthWeekDay(aDayOfWeek, aPos) {\n      var daysInMonth = ICAL.Time.daysInMonth(this.month, this.year);\n      var weekday;\n      var pos = aPos;\n      var start = 0;\n      var otherDay = this.clone();\n\n      if (pos >= 0) {\n        otherDay.day = 1; // because 0 means no position has been given\n        // 1 and 0 indicate the same day.\n\n        if (pos != 0) {\n          // remove the extra numeric value\n          pos--;\n        } // set current start offset to current day.\n\n\n        start = otherDay.day; // find the current day of week\n\n        var startDow = otherDay.dayOfWeek(); // calculate the difference between current\n        // day of the week and desired day of the week\n\n        var offset = aDayOfWeek - startDow; // if the offset goes into the past\n        // week we add 7 so its goes into the next\n        // week. We only want to go forward in time here.\n\n        if (offset < 0) // this is really important otherwise we would\n          // end up with dates from in the past.\n          offset += 7; // add offset to start so start is the same\n        // day of the week as the desired day of week.\n\n        start += offset; // because we are going to add (and multiply)\n        // the numeric value of the day we subtract it\n        // from the start position so not to add it twice.\n\n        start -= aDayOfWeek; // set week day\n\n        weekday = aDayOfWeek;\n      } else {\n        // then we set it to the last day in the current month\n        otherDay.day = daysInMonth; // find the ends weekday\n\n        var endDow = otherDay.dayOfWeek();\n        pos++;\n        weekday = endDow - aDayOfWeek;\n\n        if (weekday < 0) {\n          weekday += 7;\n        }\n\n        weekday = daysInMonth - weekday;\n      }\n\n      weekday += pos * 7;\n      return start + weekday;\n    },\n\n    /**\r\n     * Checks if current time is the nth weekday, relative to the current\r\n     * month.  Will always return false when rule resolves outside of current\r\n     * month.\r\n     *\r\n     * @param {ICAL.Time.weekDay} aDayOfWeek       Day of week to check\r\n     * @param {Number} aPos                        Relative position\r\n     * @return {Boolean}                           True, if its the nth weekday\r\n     */\n    isNthWeekDay: function isNthWeekDay(aDayOfWeek, aPos) {\n      var dow = this.dayOfWeek();\n\n      if (aPos === 0 && dow === aDayOfWeek) {\n        return true;\n      } // get pos\n\n\n      var day = this.nthWeekDay(aDayOfWeek, aPos);\n\n      if (day === this.day) {\n        return true;\n      }\n\n      return false;\n    },\n\n    /**\r\n     * Calculates the ISO 8601 week number. The first week of a year is the\r\n     * week that contains the first Thursday. The year can have 53 weeks, if\r\n     * January 1st is a Friday.\r\n     *\r\n     * Note there are regions where the first week of the year is the one that\r\n     * starts on January 1st, which may offset the week number. Also, if a\r\n     * different week start is specified, this will also affect the week\r\n     * number.\r\n     *\r\n     * @see ICAL.Time.weekOneStarts\r\n     * @param {ICAL.Time.weekDay} aWeekStart        The weekday the week starts with\r\n     * @return {Number}                             The ISO week number\r\n     */\n    weekNumber: function weekNumber(aWeekStart) {\n      var wnCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + aWeekStart;\n\n      if (wnCacheKey in ICAL.Time._wnCache) {\n        return ICAL.Time._wnCache[wnCacheKey];\n      } // This function courtesty of Julian Bucknall, published under the MIT license\n      // http://www.boyet.com/articles/publishedarticles/calculatingtheisoweeknumb.html\n      // plus some fixes to be able to use different week starts.\n\n\n      var week1;\n      var dt = this.clone();\n      dt.isDate = true;\n      var isoyear = this.year;\n\n      if (dt.month == 12 && dt.day > 25) {\n        week1 = ICAL.Time.weekOneStarts(isoyear + 1, aWeekStart);\n\n        if (dt.compare(week1) < 0) {\n          week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);\n        } else {\n          isoyear++;\n        }\n      } else {\n        week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);\n\n        if (dt.compare(week1) < 0) {\n          week1 = ICAL.Time.weekOneStarts(--isoyear, aWeekStart);\n        }\n      }\n\n      var daysBetween = dt.subtractDate(week1).toSeconds() / 86400;\n      var answer = ICAL.helpers.trunc(daysBetween / 7) + 1;\n      ICAL.Time._wnCache[wnCacheKey] = answer;\n      return answer;\n    },\n\n    /**\r\n     * Adds the duration to the current time. The instance is modified in\r\n     * place.\r\n     *\r\n     * @param {ICAL.Duration} aDuration         The duration to add\r\n     */\n    addDuration: function icaltime_add(aDuration) {\n      var mult = aDuration.isNegative ? -1 : 1; // because of the duration optimizations it is much\n      // more efficient to grab all the values up front\n      // then set them directly (which will avoid a normalization call).\n      // So we don't actually normalize until we need it.\n\n      var second = this.second;\n      var minute = this.minute;\n      var hour = this.hour;\n      var day = this.day;\n      second += mult * aDuration.seconds;\n      minute += mult * aDuration.minutes;\n      hour += mult * aDuration.hours;\n      day += mult * aDuration.days;\n      day += mult * 7 * aDuration.weeks;\n      this.second = second;\n      this.minute = minute;\n      this.hour = hour;\n      this.day = day;\n      this._cachedUnixTime = null;\n    },\n\n    /**\r\n     * Subtract the date details (_excluding_ timezone).  Useful for finding\r\n     * the relative difference between two time objects excluding their\r\n     * timezone differences.\r\n     *\r\n     * @param {ICAL.Time} aDate     The date to substract\r\n     * @return {ICAL.Duration}      The difference as a duration\r\n     */\n    subtractDate: function icaltime_subtract(aDate) {\n      var unixTime = this.toUnixTime() + this.utcOffset();\n      var other = aDate.toUnixTime() + aDate.utcOffset();\n      return ICAL.Duration.fromSeconds(unixTime - other);\n    },\n\n    /**\r\n     * Subtract the date details, taking timezones into account.\r\n     *\r\n     * @param {ICAL.Time} aDate  The date to subtract\r\n     * @return {ICAL.Duration}  The difference in duration\r\n     */\n    subtractDateTz: function icaltime_subtract_abs(aDate) {\n      var unixTime = this.toUnixTime();\n      var other = aDate.toUnixTime();\n      return ICAL.Duration.fromSeconds(unixTime - other);\n    },\n\n    /**\r\n     * Compares the ICAL.Time instance with another one.\r\n     *\r\n     * @param {ICAL.Duration} aOther        The instance to compare with\r\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\r\n     */\n    compare: function icaltime_compare(other) {\n      var a = this.toUnixTime();\n      var b = other.toUnixTime();\n      if (a > b) return 1;\n      if (b > a) return -1;\n      return 0;\n    },\n\n    /**\r\n     * Compares only the date part of this instance with another one.\r\n     *\r\n     * @param {ICAL.Duration} other         The instance to compare with\r\n     * @param {ICAL.Timezone} tz            The timezone to compare in\r\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\r\n     */\n    compareDateOnlyTz: function icaltime_compareDateOnlyTz(other, tz) {\n      function cmp(attr) {\n        return ICAL.Time._cmp_attr(a, b, attr);\n      }\n\n      var a = this.convertToZone(tz);\n      var b = other.convertToZone(tz);\n      var rc = 0;\n      if ((rc = cmp(\"year\")) != 0) return rc;\n      if ((rc = cmp(\"month\")) != 0) return rc;\n      if ((rc = cmp(\"day\")) != 0) return rc;\n      return rc;\n    },\n\n    /**\r\n     * Convert the instance into another timzone. The returned ICAL.Time\r\n     * instance is always a copy.\r\n     *\r\n     * @param {ICAL.Timezone} zone      The zone to convert to\r\n     * @return {ICAL.Time}              The copy, converted to the zone\r\n     */\n    convertToZone: function convertToZone(zone) {\n      var copy = this.clone();\n      var zone_equals = this.zone.tzid == zone.tzid;\n\n      if (!this.isDate && !zone_equals) {\n        ICAL.Timezone.convert_time(copy, this.zone, zone);\n      }\n\n      copy.zone = zone;\n      return copy;\n    },\n\n    /**\r\n     * Calculates the UTC offset of the current date/time in the timezone it is\r\n     * in.\r\n     *\r\n     * @return {Number}     UTC offset in seconds\r\n     */\n    utcOffset: function utc_offset() {\n      if (this.zone == ICAL.Timezone.localTimezone || this.zone == ICAL.Timezone.utcTimezone) {\n        return 0;\n      } else {\n        return this.zone.utcOffset(this);\n      }\n    },\n\n    /**\r\n     * Returns an RFC 5545 compliant ical representation of this object.\r\n     *\r\n     * @return {String} ical date/date-time\r\n     */\n    toICALString: function toICALString() {\n      var string = this.toString();\n\n      if (string.length > 10) {\n        return ICAL.design.icalendar.value['date-time'].toICAL(string);\n      } else {\n        return ICAL.design.icalendar.value.date.toICAL(string);\n      }\n    },\n\n    /**\r\n     * The string representation of this date/time, in jCal form\r\n     * (including : and - separators).\r\n     * @return {String}\r\n     */\n    toString: function toString() {\n      var result = this.year + '-' + ICAL.helpers.pad2(this.month) + '-' + ICAL.helpers.pad2(this.day);\n\n      if (!this.isDate) {\n        result += 'T' + ICAL.helpers.pad2(this.hour) + ':' + ICAL.helpers.pad2(this.minute) + ':' + ICAL.helpers.pad2(this.second);\n\n        if (this.zone === ICAL.Timezone.utcTimezone) {\n          result += 'Z';\n        }\n      }\n\n      return result;\n    },\n\n    /**\r\n     * Converts the current instance to a Javascript date\r\n     * @return {Date}\r\n     */\n    toJSDate: function toJSDate() {\n      if (this.zone == ICAL.Timezone.localTimezone) {\n        if (this.isDate) {\n          return new Date(this.year, this.month - 1, this.day);\n        } else {\n          return new Date(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, 0);\n        }\n      } else {\n        return new Date(this.toUnixTime() * 1000);\n      }\n    },\n    _normalize: function icaltime_normalize() {\n      var isDate = this._time.isDate;\n\n      if (this._time.isDate) {\n        this._time.hour = 0;\n        this._time.minute = 0;\n        this._time.second = 0;\n      }\n\n      this.adjust(0, 0, 0, 0);\n      return this;\n    },\n\n    /**\r\n     * Adjust the date/time by the given offset\r\n     *\r\n     * @param {Number} aExtraDays       The extra amount of days\r\n     * @param {Number} aExtraHours      The extra amount of hours\r\n     * @param {Number} aExtraMinutes    The extra amount of minutes\r\n     * @param {Number} aExtraSeconds    The extra amount of seconds\r\n     * @param {Number=} aTime           The time to adjust, defaults to the\r\n     *                                    current instance.\r\n     */\n    adjust: function icaltime_adjust(aExtraDays, aExtraHours, aExtraMinutes, aExtraSeconds, aTime) {\n      var minutesOverflow,\n          hoursOverflow,\n          daysOverflow = 0,\n          yearsOverflow = 0;\n      var second, minute, hour, day;\n      var daysInMonth;\n      var time = aTime || this._time;\n\n      if (!time.isDate) {\n        second = time.second + aExtraSeconds;\n        time.second = second % 60;\n        minutesOverflow = ICAL.helpers.trunc(second / 60);\n\n        if (time.second < 0) {\n          time.second += 60;\n          minutesOverflow--;\n        }\n\n        minute = time.minute + aExtraMinutes + minutesOverflow;\n        time.minute = minute % 60;\n        hoursOverflow = ICAL.helpers.trunc(minute / 60);\n\n        if (time.minute < 0) {\n          time.minute += 60;\n          hoursOverflow--;\n        }\n\n        hour = time.hour + aExtraHours + hoursOverflow;\n        time.hour = hour % 24;\n        daysOverflow = ICAL.helpers.trunc(hour / 24);\n\n        if (time.hour < 0) {\n          time.hour += 24;\n          daysOverflow--;\n        }\n      } // Adjust month and year first, because we need to know what month the day\n      // is in before adjusting it.\n\n\n      if (time.month > 12) {\n        yearsOverflow = ICAL.helpers.trunc((time.month - 1) / 12);\n      } else if (time.month < 1) {\n        yearsOverflow = ICAL.helpers.trunc(time.month / 12) - 1;\n      }\n\n      time.year += yearsOverflow;\n      time.month -= 12 * yearsOverflow; // Now take care of the days (and adjust month if needed)\n\n      day = time.day + aExtraDays + daysOverflow;\n\n      if (day > 0) {\n        for (;;) {\n          daysInMonth = ICAL.Time.daysInMonth(time.month, time.year);\n\n          if (day <= daysInMonth) {\n            break;\n          }\n\n          time.month++;\n\n          if (time.month > 12) {\n            time.year++;\n            time.month = 1;\n          }\n\n          day -= daysInMonth;\n        }\n      } else {\n        while (day <= 0) {\n          if (time.month == 1) {\n            time.year--;\n            time.month = 12;\n          } else {\n            time.month--;\n          }\n\n          day += ICAL.Time.daysInMonth(time.month, time.year);\n        }\n      }\n\n      time.day = day;\n      this._cachedUnixTime = null;\n      return this;\n    },\n\n    /**\r\n     * Sets up the current instance from unix time, the number of seconds since\r\n     * January 1st, 1970.\r\n     *\r\n     * @param {Number} seconds      The seconds to set up with\r\n     */\n    fromUnixTime: function fromUnixTime(seconds) {\n      this.zone = ICAL.Timezone.utcTimezone;\n      var epoch = ICAL.Time.epochTime.clone();\n      epoch.adjust(0, 0, 0, seconds);\n      this.year = epoch.year;\n      this.month = epoch.month;\n      this.day = epoch.day;\n      this.hour = epoch.hour;\n      this.minute = epoch.minute;\n      this.second = Math.floor(epoch.second);\n      this._cachedUnixTime = null;\n    },\n\n    /**\r\n     * Converts the current instance to seconds since January 1st 1970.\r\n     *\r\n     * @return {Number}         Seconds since 1970\r\n     */\n    toUnixTime: function toUnixTime() {\n      if (this._cachedUnixTime !== null) {\n        return this._cachedUnixTime;\n      }\n\n      var offset = this.utcOffset(); // we use the offset trick to ensure\n      // that we are getting the actual UTC time\n\n      var ms = Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second - offset); // seconds\n\n      this._cachedUnixTime = ms / 1000;\n      return this._cachedUnixTime;\n    },\n\n    /**\r\n     * Converts time to into Object which can be serialized then re-created\r\n     * using the constructor.\r\n     *\r\n     * @example\r\n     * // toJSON will automatically be called\r\n     * var json = JSON.stringify(mytime);\r\n     *\r\n     * var deserialized = JSON.parse(json);\r\n     *\r\n     * var time = new ICAL.Time(deserialized);\r\n     *\r\n     * @return {Object}\r\n     */\n    toJSON: function toJSON() {\n      var copy = ['year', 'month', 'day', 'hour', 'minute', 'second', 'isDate'];\n      var result = Object.create(null);\n      var i = 0;\n      var len = copy.length;\n      var prop;\n\n      for (; i < len; i++) {\n        prop = copy[i];\n        result[prop] = this[prop];\n      }\n\n      if (this.zone) {\n        result.timezone = this.zone.tzid;\n      }\n\n      return result;\n    }\n  };\n\n  (function setupNormalizeAttributes() {\n    // This needs to run before any instances are created!\n    function defineAttr(attr) {\n      Object.defineProperty(ICAL.Time.prototype, attr, {\n        get: function getTimeAttr() {\n          if (this._pendingNormalization) {\n            this._normalize();\n\n            this._pendingNormalization = false;\n          }\n\n          return this._time[attr];\n        },\n        set: function setTimeAttr(val) {\n          // Check if isDate will be set and if was not set to normalize date.\n          // This avoids losing days when seconds, minutes and hours are zeroed\n          // what normalize will do when time is a date.\n          if (attr === \"isDate\" && val && !this._time.isDate) {\n            this.adjust(0, 0, 0, 0);\n          }\n\n          this._cachedUnixTime = null;\n          this._pendingNormalization = true;\n          this._time[attr] = val;\n          return val;\n        }\n      });\n    }\n    /* istanbul ignore else */\n\n\n    if (\"defineProperty\" in Object) {\n      defineAttr(\"year\");\n      defineAttr(\"month\");\n      defineAttr(\"day\");\n      defineAttr(\"hour\");\n      defineAttr(\"minute\");\n      defineAttr(\"second\");\n      defineAttr(\"isDate\");\n    }\n  })();\n  /**\r\n   * Returns the days in the given month\r\n   *\r\n   * @param {Number} month      The month to check\r\n   * @param {Number} year       The year to check\r\n   * @return {Number}           The number of days in the month\r\n   */\n\n\n  ICAL.Time.daysInMonth = function icaltime_daysInMonth(month, year) {\n    var _daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    var days = 30;\n    if (month < 1 || month > 12) return days;\n    days = _daysInMonth[month];\n\n    if (month == 2) {\n      days += ICAL.Time.isLeapYear(year);\n    }\n\n    return days;\n  };\n  /**\r\n   * Checks if the year is a leap year\r\n   *\r\n   * @param {Number} year       The year to check\r\n   * @return {Boolean}          True, if the year is a leap year\r\n   */\n\n\n  ICAL.Time.isLeapYear = function isLeapYear(year) {\n    if (year <= 1752) {\n      return year % 4 == 0;\n    } else {\n      return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;\n    }\n  };\n  /**\r\n   * Create a new ICAL.Time from the day of year and year. The date is returned\r\n   * in floating timezone.\r\n   *\r\n   * @param {Number} aDayOfYear     The day of year\r\n   * @param {Number} aYear          The year to create the instance in\r\n   * @return {ICAL.Time}            The created instance with the calculated date\r\n   */\n\n\n  ICAL.Time.fromDayOfYear = function icaltime_fromDayOfYear(aDayOfYear, aYear) {\n    var year = aYear;\n    var doy = aDayOfYear;\n    var tt = new ICAL.Time();\n    tt.auto_normalize = false;\n    var is_leap = ICAL.Time.isLeapYear(year) ? 1 : 0;\n\n    if (doy < 1) {\n      year--;\n      is_leap = ICAL.Time.isLeapYear(year) ? 1 : 0;\n      doy += ICAL.Time.daysInYearPassedMonth[is_leap][12];\n      return ICAL.Time.fromDayOfYear(doy, year);\n    } else if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][12]) {\n      is_leap = ICAL.Time.isLeapYear(year) ? 1 : 0;\n      doy -= ICAL.Time.daysInYearPassedMonth[is_leap][12];\n      year++;\n      return ICAL.Time.fromDayOfYear(doy, year);\n    }\n\n    tt.year = year;\n    tt.isDate = true;\n\n    for (var month = 11; month >= 0; month--) {\n      if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][month]) {\n        tt.month = month + 1;\n        tt.day = doy - ICAL.Time.daysInYearPassedMonth[is_leap][month];\n        break;\n      }\n    }\n\n    tt.auto_normalize = true;\n    return tt;\n  };\n  /**\r\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\r\n   *\r\n   * @deprecated                Use {@link ICAL.Time.fromDateString} instead\r\n   * @param {String} str        The string to create from\r\n   * @return {ICAL.Time}        The date/time instance\r\n   */\n\n\n  ICAL.Time.fromStringv2 = function fromString(str) {\n    return new ICAL.Time({\n      year: parseInt(str.substr(0, 4), 10),\n      month: parseInt(str.substr(5, 2), 10),\n      day: parseInt(str.substr(8, 2), 10),\n      isDate: true\n    });\n  };\n  /**\r\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\r\n   *\r\n   * @param {String} aValue     The string to create from\r\n   * @return {ICAL.Time}        The date/time instance\r\n   */\n\n\n  ICAL.Time.fromDateString = function (aValue) {\n    // Dates should have no timezone.\n    // Google likes to sometimes specify Z on dates\n    // we specifically ignore that to avoid issues.\n    // YYYY-MM-DD\n    // 2012-10-10\n    return new ICAL.Time({\n      year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),\n      month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),\n      day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),\n      isDate: true\n    });\n  };\n  /**\r\n   * Returns a new ICAL.Time instance from a date-time string, e.g\r\n   * 2015-01-02T03:04:05. If a property is specified, the timezone is set up\r\n   * from the property's TZID parameter.\r\n   *\r\n   * @param {String} aValue         The string to create from\r\n   * @param {ICAL.Property=} prop   The property the date belongs to\r\n   * @return {ICAL.Time}            The date/time instance\r\n   */\n\n\n  ICAL.Time.fromDateTimeString = function (aValue, prop) {\n    if (aValue.length < 19) {\n      throw new Error('invalid date-time value: \"' + aValue + '\"');\n    }\n\n    var zone;\n\n    if (aValue[19] && aValue[19] === 'Z') {\n      zone = 'Z';\n    } else if (prop) {\n      zone = prop.getParameter('tzid');\n    } // 2012-10-10T10:10:10(Z)?\n\n\n    var time = new ICAL.Time({\n      year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),\n      month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),\n      day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),\n      hour: ICAL.helpers.strictParseInt(aValue.substr(11, 2)),\n      minute: ICAL.helpers.strictParseInt(aValue.substr(14, 2)),\n      second: ICAL.helpers.strictParseInt(aValue.substr(17, 2)),\n      timezone: zone\n    });\n    return time;\n  };\n  /**\r\n   * Returns a new ICAL.Time instance from a date or date-time string,\r\n   *\r\n   * @param {String} aValue         The string to create from\r\n   * @param {ICAL.Property=} prop   The property the date belongs to\r\n   * @return {ICAL.Time}            The date/time instance\r\n   */\n\n\n  ICAL.Time.fromString = function fromString(aValue, aProperty) {\n    if (aValue.length > 10) {\n      return ICAL.Time.fromDateTimeString(aValue, aProperty);\n    } else {\n      return ICAL.Time.fromDateString(aValue);\n    }\n  };\n  /**\r\n   * Creates a new ICAL.Time instance from the given Javascript Date.\r\n   *\r\n   * @param {?Date} aDate     The Javascript Date to read, or null to reset\r\n   * @param {Boolean} useUTC  If true, the UTC values of the date will be used\r\n   */\n\n\n  ICAL.Time.fromJSDate = function fromJSDate(aDate, useUTC) {\n    var tt = new ICAL.Time();\n    return tt.fromJSDate(aDate, useUTC);\n  };\n  /**\r\n   * Creates a new ICAL.Time instance from the the passed data object.\r\n   *\r\n   * @param {Object} aData            Time initialization\r\n   * @param {Number=} aData.year      The year for this date\r\n   * @param {Number=} aData.month     The month for this date\r\n   * @param {Number=} aData.day       The day for this date\r\n   * @param {Number=} aData.hour      The hour for this date\r\n   * @param {Number=} aData.minute    The minute for this date\r\n   * @param {Number=} aData.second    The second for this date\r\n   * @param {Boolean=} aData.isDate   If true, the instance represents a date\r\n   *                                    (as opposed to a date-time)\r\n   * @param {ICAL.Timezone=} aZone    Timezone this position occurs in\r\n   */\n\n\n  ICAL.Time.fromData = function fromData(aData, aZone) {\n    var t = new ICAL.Time();\n    return t.fromData(aData, aZone);\n  };\n  /**\r\n   * Creates a new ICAL.Time instance from the current moment.\r\n   * @return {ICAL.Time}\r\n   */\n\n\n  ICAL.Time.now = function icaltime_now() {\n    return ICAL.Time.fromJSDate(new Date(), false);\n  };\n  /**\r\n   * Returns the date on which ISO week number 1 starts.\r\n   *\r\n   * @see ICAL.Time#weekNumber\r\n   * @param {Number} aYear                  The year to search in\r\n   * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday, used for calculation.\r\n   * @return {ICAL.Time}                    The date on which week number 1 starts\r\n   */\n\n\n  ICAL.Time.weekOneStarts = function weekOneStarts(aYear, aWeekStart) {\n    var t = ICAL.Time.fromData({\n      year: aYear,\n      month: 1,\n      day: 1,\n      isDate: true\n    });\n    var dow = t.dayOfWeek();\n    var wkst = aWeekStart || ICAL.Time.DEFAULT_WEEK_START;\n\n    if (dow > ICAL.Time.THURSDAY) {\n      t.day += 7;\n    }\n\n    if (wkst > ICAL.Time.THURSDAY) {\n      t.day -= 7;\n    }\n\n    t.day -= dow - wkst;\n    return t;\n  };\n  /**\r\n   * Get the dominical letter for the given year. Letters range from A - G for\r\n   * common years, and AG to GF for leap years.\r\n   *\r\n   * @param {Number} yr           The year to retrieve the letter for\r\n   * @return {String}             The dominical letter.\r\n   */\n\n\n  ICAL.Time.getDominicalLetter = function (yr) {\n    var LTRS = \"GFEDCBA\";\n    var dom = (yr + (yr / 4 | 0) + (yr / 400 | 0) - (yr / 100 | 0) - 1) % 7;\n    var isLeap = ICAL.Time.isLeapYear(yr);\n\n    if (isLeap) {\n      return LTRS[(dom + 6) % 7] + LTRS[dom];\n    } else {\n      return LTRS[dom];\n    }\n  };\n  /**\r\n   * January 1st, 1970 as an ICAL.Time.\r\n   * @type {ICAL.Time}\r\n   * @constant\r\n   * @instance\r\n   */\n\n\n  ICAL.Time.epochTime = ICAL.Time.fromData({\n    year: 1970,\n    month: 1,\n    day: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    isDate: false,\n    timezone: \"Z\"\n  });\n\n  ICAL.Time._cmp_attr = function _cmp_attr(a, b, attr) {\n    if (a[attr] > b[attr]) return 1;\n    if (a[attr] < b[attr]) return -1;\n    return 0;\n  };\n  /**\r\n   * The days that have passed in the year after a given month. The array has\r\n   * two members, one being an array of passed days for non-leap years, the\r\n   * other analog for leap years.\r\n   * @example\r\n   * var isLeapYear = ICAL.Time.isLeapYear(year);\r\n   * var passedDays = ICAL.Time.daysInYearPassedMonth[isLeapYear][month];\r\n   * @type {Array.<Array.<Number>>}\r\n   */\n\n\n  ICAL.Time.daysInYearPassedMonth = [[0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365], [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]];\n  /**\r\n   * The weekday, 1 = SUNDAY, 7 = SATURDAY. Access via\r\n   * ICAL.Time.MONDAY, ICAL.Time.TUESDAY, ...\r\n   *\r\n   * @typedef {Number} weekDay\r\n   * @memberof ICAL.Time\r\n   */\n\n  ICAL.Time.SUNDAY = 1;\n  ICAL.Time.MONDAY = 2;\n  ICAL.Time.TUESDAY = 3;\n  ICAL.Time.WEDNESDAY = 4;\n  ICAL.Time.THURSDAY = 5;\n  ICAL.Time.FRIDAY = 6;\n  ICAL.Time.SATURDAY = 7;\n  /**\r\n   * The default weekday for the WKST part.\r\n   * @constant\r\n   * @default ICAL.Time.MONDAY\r\n   */\n\n  ICAL.Time.DEFAULT_WEEK_START = ICAL.Time.MONDAY;\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2015 */\n\n\n(function () {\n  /**\r\n   * Describes a vCard time, which has slight differences to the ICAL.Time.\r\n   * Properties can be null if not specified, for example for dates with\r\n   * reduced accuracy or truncation.\r\n   *\r\n   * Note that currently not all methods are correctly re-implemented for\r\n   * VCardTime. For example, comparison will have undefined results when some\r\n   * members are null.\r\n   *\r\n   * Also, normalization is not yet implemented for this class!\r\n   *\r\n   * @alias ICAL.VCardTime\r\n   * @class\r\n   * @extends {ICAL.Time}\r\n   * @param {Object} data                           The data for the time instance\r\n   * @param {Number=} data.year                     The year for this date\r\n   * @param {Number=} data.month                    The month for this date\r\n   * @param {Number=} data.day                      The day for this date\r\n   * @param {Number=} data.hour                     The hour for this date\r\n   * @param {Number=} data.minute                   The minute for this date\r\n   * @param {Number=} data.second                   The second for this date\r\n   * @param {ICAL.Timezone|ICAL.UtcOffset} zone     The timezone to use\r\n   * @param {String} icaltype                       The type for this date/time object\r\n   */\n  ICAL.VCardTime = function (data, zone, icaltype) {\n    this.wrappedJSObject = this;\n    var time = this._time = Object.create(null);\n    time.year = null;\n    time.month = null;\n    time.day = null;\n    time.hour = null;\n    time.minute = null;\n    time.second = null;\n    this.icaltype = icaltype || \"date-and-or-time\";\n    this.fromData(data, zone);\n  };\n\n  ICAL.helpers.inherits(ICAL.Time, ICAL.VCardTime,\n  /** @lends ICAL.VCardTime */\n  {\n    /**\r\n     * The class identifier.\r\n     * @constant\r\n     * @type {String}\r\n     * @default \"vcardtime\"\r\n     */\n    icalclass: \"vcardtime\",\n\n    /**\r\n     * The type name, to be used in the jCal object.\r\n     * @type {String}\r\n     * @default \"date-and-or-time\"\r\n     */\n    icaltype: \"date-and-or-time\",\n\n    /**\r\n     * The timezone. This can either be floating, UTC, or an instance of\r\n     * ICAL.UtcOffset.\r\n     * @type {ICAL.Timezone|ICAL.UtcOFfset}\r\n     */\n    zone: null,\n\n    /**\r\n     * Returns a clone of the vcard date/time object.\r\n     *\r\n     * @return {ICAL.VCardTime}     The cloned object\r\n     */\n    clone: function clone() {\n      return new ICAL.VCardTime(this._time, this.zone, this.icaltype);\n    },\n    _normalize: function _normalize() {\n      return this;\n    },\n\n    /**\r\n     * @inheritdoc\r\n     */\n    utcOffset: function utcOffset() {\n      if (this.zone instanceof ICAL.UtcOffset) {\n        return this.zone.toSeconds();\n      } else {\n        return ICAL.Time.prototype.utcOffset.apply(this, arguments);\n      }\n    },\n\n    /**\r\n     * Returns an RFC 6350 compliant representation of this object.\r\n     *\r\n     * @return {String}         vcard date/time string\r\n     */\n    toICALString: function toICALString() {\n      return ICAL.design.vcard.value[this.icaltype].toICAL(this.toString());\n    },\n\n    /**\r\n     * The string representation of this date/time, in jCard form\r\n     * (including : and - separators).\r\n     * @return {String}\r\n     */\n    toString: function toString() {\n      var p2 = ICAL.helpers.pad2;\n      var y = this.year,\n          m = this.month,\n          d = this.day;\n      var h = this.hour,\n          mm = this.minute,\n          s = this.second;\n      var hasYear = y !== null,\n          hasMonth = m !== null,\n          hasDay = d !== null;\n      var hasHour = h !== null,\n          hasMinute = mm !== null,\n          hasSecond = s !== null;\n      var datepart = (hasYear ? p2(y) + (hasMonth || hasDay ? '-' : '') : hasMonth || hasDay ? '--' : '') + (hasMonth ? p2(m) : '') + (hasDay ? '-' + p2(d) : '');\n      var timepart = (hasHour ? p2(h) : '-') + (hasHour && hasMinute ? ':' : '') + (hasMinute ? p2(mm) : '') + (!hasHour && !hasMinute ? '-' : '') + (hasMinute && hasSecond ? ':' : '') + (hasSecond ? p2(s) : '');\n      var zone;\n\n      if (this.zone === ICAL.Timezone.utcTimezone) {\n        zone = 'Z';\n      } else if (this.zone instanceof ICAL.UtcOffset) {\n        zone = this.zone.toString();\n      } else if (this.zone === ICAL.Timezone.localTimezone) {\n        zone = '';\n      } else if (this.zone instanceof ICAL.Timezone) {\n        var offset = ICAL.UtcOffset.fromSeconds(this.zone.utcOffset(this));\n        zone = offset.toString();\n      } else {\n        zone = '';\n      }\n\n      switch (this.icaltype) {\n        case \"time\":\n          return timepart + zone;\n\n        case \"date-and-or-time\":\n        case \"date-time\":\n          return datepart + (timepart == '--' ? '' : 'T' + timepart + zone);\n\n        case \"date\":\n          return datepart;\n      }\n\n      return null;\n    }\n  });\n  /**\r\n   * Returns a new ICAL.VCardTime instance from a date and/or time string.\r\n   *\r\n   * @param {String} aValue     The string to create from\r\n   * @param {String} aIcalType  The type for this instance, e.g. date-and-or-time\r\n   * @return {ICAL.VCardTime}   The date/time instance\r\n   */\n\n  ICAL.VCardTime.fromDateAndOrTimeString = function (aValue, aIcalType) {\n    function part(v, s, e) {\n      return v ? ICAL.helpers.strictParseInt(v.substr(s, e)) : null;\n    }\n\n    var parts = aValue.split('T');\n    var dt = parts[0],\n        tmz = parts[1];\n    var splitzone = tmz ? ICAL.design.vcard.value.time._splitZone(tmz) : [];\n    var zone = splitzone[0],\n        tm = splitzone[1];\n    var stoi = ICAL.helpers.strictParseInt;\n    var dtlen = dt ? dt.length : 0;\n    var tmlen = tm ? tm.length : 0;\n    var hasDashDate = dt && dt[0] == '-' && dt[1] == '-';\n    var hasDashTime = tm && tm[0] == '-';\n    var o = {\n      year: hasDashDate ? null : part(dt, 0, 4),\n      month: hasDashDate && (dtlen == 4 || dtlen == 7) ? part(dt, 2, 2) : dtlen == 7 ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 5, 2) : null,\n      day: dtlen == 5 ? part(dt, 3, 2) : dtlen == 7 && hasDashDate ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 8, 2) : null,\n      hour: hasDashTime ? null : part(tm, 0, 2),\n      minute: hasDashTime && tmlen == 3 ? part(tm, 1, 2) : tmlen > 4 ? hasDashTime ? part(tm, 1, 2) : part(tm, 3, 2) : null,\n      second: tmlen == 4 ? part(tm, 2, 2) : tmlen == 6 ? part(tm, 4, 2) : tmlen == 8 ? part(tm, 6, 2) : null\n    };\n\n    if (zone == 'Z') {\n      zone = ICAL.Timezone.utcTimezone;\n    } else if (zone && zone[3] == ':') {\n      zone = ICAL.UtcOffset.fromString(zone);\n    } else {\n      zone = null;\n    }\n\n    return new ICAL.VCardTime(o, zone, aIcalType);\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n\n(function () {\n  var DOW_MAP = {\n    SU: ICAL.Time.SUNDAY,\n    MO: ICAL.Time.MONDAY,\n    TU: ICAL.Time.TUESDAY,\n    WE: ICAL.Time.WEDNESDAY,\n    TH: ICAL.Time.THURSDAY,\n    FR: ICAL.Time.FRIDAY,\n    SA: ICAL.Time.SATURDAY\n  };\n  var REVERSE_DOW_MAP = {};\n\n  for (var key in DOW_MAP) {\n    /* istanbul ignore else */\n    if (DOW_MAP.hasOwnProperty(key)) {\n      REVERSE_DOW_MAP[DOW_MAP[key]] = key;\n    }\n  }\n\n  var COPY_PARTS = [\"BYSECOND\", \"BYMINUTE\", \"BYHOUR\", \"BYDAY\", \"BYMONTHDAY\", \"BYYEARDAY\", \"BYWEEKNO\", \"BYMONTH\", \"BYSETPOS\"];\n  /**\r\n   * @classdesc\r\n   * This class represents the \"recur\" value type, with various calculation\r\n   * and manipulation methods.\r\n   *\r\n   * @class\r\n   * @alias ICAL.Recur\r\n   * @param {Object} data                               An object with members of the recurrence\r\n   * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value\r\n   * @param {Number=} data.interval                     The INTERVAL value\r\n   * @param {ICAL.Time.weekDay=} data.wkst              The week start value\r\n   * @param {ICAL.Time=} data.until                     The end of the recurrence set\r\n   * @param {Number=} data.count                        The number of occurrences\r\n   * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\r\n   * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\r\n   * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\r\n   * @param {Array.<String>=} data.byday                The BYDAY values\r\n   * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\r\n   * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\r\n   * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\r\n   * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\r\n   * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\r\n   */\n\n  ICAL.Recur = function icalrecur(data) {\n    this.wrappedJSObject = this;\n    this.parts = {};\n\n    if (data && typeof data === 'object') {\n      this.fromData(data);\n    }\n  };\n\n  ICAL.Recur.prototype = {\n    /**\r\n     * An object holding the BY-parts of the recurrence rule\r\n     * @type {Object}\r\n     */\n    parts: null,\n\n    /**\r\n     * The interval value for the recurrence rule.\r\n     * @type {Number}\r\n     */\n    interval: 1,\n\n    /**\r\n     * The week start day\r\n     *\r\n     * @type {ICAL.Time.weekDay}\r\n     * @default ICAL.Time.MONDAY\r\n     */\n    wkst: ICAL.Time.MONDAY,\n\n    /**\r\n     * The end of the recurrence\r\n     * @type {?ICAL.Time}\r\n     */\n    until: null,\n\n    /**\r\n     * The maximum number of occurrences\r\n     * @type {?Number}\r\n     */\n    count: null,\n\n    /**\r\n     * The frequency value.\r\n     * @type {ICAL.Recur.frequencyValues}\r\n     */\n    freq: null,\n\n    /**\r\n     * The class identifier.\r\n     * @constant\r\n     * @type {String}\r\n     * @default \"icalrecur\"\r\n     */\n    icalclass: \"icalrecur\",\n\n    /**\r\n     * The type name, to be used in the jCal object.\r\n     * @constant\r\n     * @type {String}\r\n     * @default \"recur\"\r\n     */\n    icaltype: \"recur\",\n\n    /**\r\n     * Create a new iterator for this recurrence rule. The passed start date\r\n     * must be the start date of the event, not the start of the range to\r\n     * search in.\r\n     *\r\n     * @example\r\n     * var recur = comp.getFirstPropertyValue('rrule');\r\n     * var dtstart = comp.getFirstPropertyValue('dtstart');\r\n     * var iter = recur.iterator(dtstart);\r\n     * for (var next = iter.next(); next; next = iter.next()) {\r\n     *   if (next.compare(rangeStart) < 0) {\r\n     *     continue;\r\n     *   }\r\n     *   console.log(next.toString());\r\n     * }\r\n     *\r\n     * @param {ICAL.Time} aStart        The item's start date\r\n     * @return {ICAL.RecurIterator}     The recurrence iterator\r\n     */\n    iterator: function iterator(aStart) {\n      return new ICAL.RecurIterator({\n        rule: this,\n        dtstart: aStart\n      });\n    },\n\n    /**\r\n     * Returns a clone of the recurrence object.\r\n     *\r\n     * @return {ICAL.Recur}      The cloned object\r\n     */\n    clone: function clone() {\n      return new ICAL.Recur(this.toJSON());\n    },\n\n    /**\r\n     * Checks if the current rule is finite, i.e. has a count or until part.\r\n     *\r\n     * @return {Boolean}        True, if the rule is finite\r\n     */\n    isFinite: function isfinite() {\n      return !!(this.count || this.until);\n    },\n\n    /**\r\n     * Checks if the current rule has a count part, and not limited by an until\r\n     * part.\r\n     *\r\n     * @return {Boolean}        True, if the rule is by count\r\n     */\n    isByCount: function isbycount() {\n      return !!(this.count && !this.until);\n    },\n\n    /**\r\n     * Adds a component (part) to the recurrence rule. This is not a component\r\n     * in the sense of {@link ICAL.Component}, but a part of the recurrence\r\n     * rule, i.e. BYMONTH.\r\n     *\r\n     * @param {String} aType            The name of the component part\r\n     * @param {Array|String} aValue     The component value\r\n     */\n    addComponent: function addPart(aType, aValue) {\n      var ucname = aType.toUpperCase();\n\n      if (ucname in this.parts) {\n        this.parts[ucname].push(aValue);\n      } else {\n        this.parts[ucname] = [aValue];\n      }\n    },\n\n    /**\r\n     * Sets the component value for the given by-part.\r\n     *\r\n     * @param {String} aType        The component part name\r\n     * @param {Array} aValues       The component values\r\n     */\n    setComponent: function setComponent(aType, aValues) {\n      this.parts[aType.toUpperCase()] = aValues.slice();\n    },\n\n    /**\r\n     * Gets (a copy) of the requested component value.\r\n     *\r\n     * @param {String} aType        The component part name\r\n     * @return {Array}              The component part value\r\n     */\n    getComponent: function getComponent(aType) {\n      var ucname = aType.toUpperCase();\n      return ucname in this.parts ? this.parts[ucname].slice() : [];\n    },\n\n    /**\r\n     * Retrieves the next occurrence after the given recurrence id. See the\r\n     * guide on {@tutorial terminology} for more details.\r\n     *\r\n     * NOTE: Currently, this method iterates all occurrences from the start\r\n     * date. It should not be called in a loop for performance reasons. If you\r\n     * would like to get more than one occurrence, you can iterate the\r\n     * occurrences manually, see the example on the\r\n     * {@link ICAL.Recur#iterator iterator} method.\r\n     *\r\n     * @param {ICAL.Time} aStartTime        The start of the event series\r\n     * @param {ICAL.Time} aRecurrenceId     The date of the last occurrence\r\n     * @return {ICAL.Time}                  The next occurrence after\r\n     */\n    getNextOccurrence: function getNextOccurrence(aStartTime, aRecurrenceId) {\n      var iter = this.iterator(aStartTime);\n      var next, cdt;\n\n      do {\n        next = iter.next();\n      } while (next && next.compare(aRecurrenceId) <= 0);\n\n      if (next && aRecurrenceId.zone) {\n        next.zone = aRecurrenceId.zone;\n      }\n\n      return next;\n    },\n\n    /**\r\n     * Sets up the current instance using members from the passed data object.\r\n     *\r\n     * @param {Object} data                               An object with members of the recurrence\r\n     * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value\r\n     * @param {Number=} data.interval                     The INTERVAL value\r\n     * @param {ICAL.Time.weekDay=} data.wkst              The week start value\r\n     * @param {ICAL.Time=} data.until                     The end of the recurrence set\r\n     * @param {Number=} data.count                        The number of occurrences\r\n     * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\r\n     * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\r\n     * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\r\n     * @param {Array.<String>=} data.byday                The BYDAY values\r\n     * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\r\n     * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\r\n     * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\r\n     * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\r\n     * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\r\n     */\n    fromData: function fromData(data) {\n      for (var key in data) {\n        var uckey = key.toUpperCase();\n\n        if (uckey in partDesign) {\n          if (Array.isArray(data[key])) {\n            this.parts[uckey] = data[key];\n          } else {\n            this.parts[uckey] = [data[key]];\n          }\n        } else {\n          this[key] = data[key];\n        }\n      }\n\n      if (this.interval && typeof this.interval != \"number\") {\n        optionDesign.INTERVAL(this.interval, this);\n      }\n\n      if (this.wkst && typeof this.wkst != \"number\") {\n        this.wkst = ICAL.Recur.icalDayToNumericDay(this.wkst);\n      }\n\n      if (this.until && !(this.until instanceof ICAL.Time)) {\n        this.until = ICAL.Time.fromString(this.until);\n      }\n    },\n\n    /**\r\n     * The jCal representation of this recurrence type.\r\n     * @return {Object}\r\n     */\n    toJSON: function toJSON() {\n      var res = Object.create(null);\n      res.freq = this.freq;\n\n      if (this.count) {\n        res.count = this.count;\n      }\n\n      if (this.interval > 1) {\n        res.interval = this.interval;\n      }\n\n      for (var k in this.parts) {\n        /* istanbul ignore if */\n        if (!this.parts.hasOwnProperty(k)) {\n          continue;\n        }\n\n        var kparts = this.parts[k];\n\n        if (Array.isArray(kparts) && kparts.length == 1) {\n          res[k.toLowerCase()] = kparts[0];\n        } else {\n          res[k.toLowerCase()] = ICAL.helpers.clone(this.parts[k]);\n        }\n      }\n\n      if (this.until) {\n        res.until = this.until.toString();\n      }\n\n      if ('wkst' in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {\n        res.wkst = ICAL.Recur.numericDayToIcalDay(this.wkst);\n      }\n\n      return res;\n    },\n\n    /**\r\n     * The string representation of this recurrence rule.\r\n     * @return {String}\r\n     */\n    toString: function icalrecur_toString() {\n      // TODO retain order\n      var str = \"FREQ=\" + this.freq;\n\n      if (this.count) {\n        str += \";COUNT=\" + this.count;\n      }\n\n      if (this.interval > 1) {\n        str += \";INTERVAL=\" + this.interval;\n      }\n\n      for (var k in this.parts) {\n        /* istanbul ignore else */\n        if (this.parts.hasOwnProperty(k)) {\n          str += \";\" + k + \"=\" + this.parts[k];\n        }\n      }\n\n      if (this.until) {\n        str += ';UNTIL=' + this.until.toICALString();\n      }\n\n      if ('wkst' in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {\n        str += ';WKST=' + ICAL.Recur.numericDayToIcalDay(this.wkst);\n      }\n\n      return str;\n    }\n  };\n\n  function parseNumericValue(type, min, max, value) {\n    var result = value;\n\n    if (value[0] === '+') {\n      result = value.substr(1);\n    }\n\n    result = ICAL.helpers.strictParseInt(result);\n\n    if (min !== undefined && value < min) {\n      throw new Error(type + ': invalid value \"' + value + '\" must be > ' + min);\n    }\n\n    if (max !== undefined && value > max) {\n      throw new Error(type + ': invalid value \"' + value + '\" must be < ' + min);\n    }\n\n    return result;\n  }\n  /**\r\n   * Convert an ical representation of a day (SU, MO, etc..)\r\n   * into a numeric value of that day.\r\n   *\r\n   * @param {String} string     The iCalendar day name\r\n   * @param {ICAL.Time.weekDay=} aWeekStart\r\n   *        The week start weekday, defaults to SUNDAY\r\n   * @return {Number}           Numeric value of given day\r\n   */\n\n\n  ICAL.Recur.icalDayToNumericDay = function toNumericDay(string, aWeekStart) {\n    //XXX: this is here so we can deal\n    //     with possibly invalid string values.\n    var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n    return (DOW_MAP[string] - firstDow + 7) % 7 + 1;\n  };\n  /**\r\n   * Convert a numeric day value into its ical representation (SU, MO, etc..)\r\n   *\r\n   * @param {Number} num        Numeric value of given day\r\n   * @param {ICAL.Time.weekDay=} aWeekStart\r\n   *        The week start weekday, defaults to SUNDAY\r\n   * @return {String}           The ICAL day value, e.g SU,MO,...\r\n   */\n\n\n  ICAL.Recur.numericDayToIcalDay = function toIcalDay(num, aWeekStart) {\n    //XXX: this is here so we can deal with possibly invalid number values.\n    //     Also, this allows consistent mapping between day numbers and day\n    //     names for external users.\n    var firstDow = aWeekStart || ICAL.Time.SUNDAY;\n    var dow = num + firstDow - ICAL.Time.SUNDAY;\n\n    if (dow > 7) {\n      dow -= 7;\n    }\n\n    return REVERSE_DOW_MAP[dow];\n  };\n\n  var VALID_DAY_NAMES = /^(SU|MO|TU|WE|TH|FR|SA)$/;\n  var VALID_BYDAY_PART = /^([+-])?(5[0-3]|[1-4][0-9]|[1-9])?(SU|MO|TU|WE|TH|FR|SA)$/;\n  /**\r\n   * Possible frequency values for the FREQ part\r\n   * (YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY, SECONDLY)\r\n   *\r\n   * @typedef {String} frequencyValues\r\n   * @memberof ICAL.Recur\r\n   */\n\n  var ALLOWED_FREQ = ['SECONDLY', 'MINUTELY', 'HOURLY', 'DAILY', 'WEEKLY', 'MONTHLY', 'YEARLY'];\n  var optionDesign = {\n    FREQ: function FREQ(value, dict, fmtIcal) {\n      // yes this is actually equal or faster then regex.\n      // upside here is we can enumerate the valid values.\n      if (ALLOWED_FREQ.indexOf(value) !== -1) {\n        dict.freq = value;\n      } else {\n        throw new Error('invalid frequency \"' + value + '\" expected: \"' + ALLOWED_FREQ.join(', ') + '\"');\n      }\n    },\n    COUNT: function COUNT(value, dict, fmtIcal) {\n      dict.count = ICAL.helpers.strictParseInt(value);\n    },\n    INTERVAL: function INTERVAL(value, dict, fmtIcal) {\n      dict.interval = ICAL.helpers.strictParseInt(value);\n\n      if (dict.interval < 1) {\n        // 0 or negative values are not allowed, some engines seem to generate\n        // it though. Assume 1 instead.\n        dict.interval = 1;\n      }\n    },\n    UNTIL: function UNTIL(value, dict, fmtIcal) {\n      if (value.length > 10) {\n        dict.until = ICAL.design.icalendar.value['date-time'].fromICAL(value);\n      } else {\n        dict.until = ICAL.design.icalendar.value.date.fromICAL(value);\n      }\n\n      if (!fmtIcal) {\n        dict.until = ICAL.Time.fromString(dict.until);\n      }\n    },\n    WKST: function WKST(value, dict, fmtIcal) {\n      if (VALID_DAY_NAMES.test(value)) {\n        dict.wkst = ICAL.Recur.icalDayToNumericDay(value);\n      } else {\n        throw new Error('invalid WKST value \"' + value + '\"');\n      }\n    }\n  };\n  var partDesign = {\n    BYSECOND: parseNumericValue.bind(this, 'BYSECOND', 0, 60),\n    BYMINUTE: parseNumericValue.bind(this, 'BYMINUTE', 0, 59),\n    BYHOUR: parseNumericValue.bind(this, 'BYHOUR', 0, 23),\n    BYDAY: function BYDAY(value) {\n      if (VALID_BYDAY_PART.test(value)) {\n        return value;\n      } else {\n        throw new Error('invalid BYDAY value \"' + value + '\"');\n      }\n    },\n    BYMONTHDAY: parseNumericValue.bind(this, 'BYMONTHDAY', -31, 31),\n    BYYEARDAY: parseNumericValue.bind(this, 'BYYEARDAY', -366, 366),\n    BYWEEKNO: parseNumericValue.bind(this, 'BYWEEKNO', -53, 53),\n    BYMONTH: parseNumericValue.bind(this, 'BYMONTH', 0, 12),\n    BYSETPOS: parseNumericValue.bind(this, 'BYSETPOS', -366, 366)\n  };\n  /**\r\n   * Creates a new {@link ICAL.Recur} instance from the passed string.\r\n   *\r\n   * @param {String} string         The string to parse\r\n   * @return {ICAL.Recur}           The created recurrence instance\r\n   */\n\n  ICAL.Recur.fromString = function (string) {\n    var data = ICAL.Recur._stringToData(string, false);\n\n    return new ICAL.Recur(data);\n  };\n  /**\r\n   * Creates a new {@link ICAL.Recur} instance using members from the passed\r\n   * data object.\r\n   *\r\n   * @param {Object} aData                              An object with members of the recurrence\r\n   * @param {ICAL.Recur.frequencyValues=} aData.freq    The frequency value\r\n   * @param {Number=} aData.interval                    The INTERVAL value\r\n   * @param {ICAL.Time.weekDay=} aData.wkst             The week start value\r\n   * @param {ICAL.Time=} aData.until                    The end of the recurrence set\r\n   * @param {Number=} aData.count                       The number of occurrences\r\n   * @param {Array.<Number>=} aData.bysecond            The seconds for the BYSECOND part\r\n   * @param {Array.<Number>=} aData.byminute            The minutes for the BYMINUTE part\r\n   * @param {Array.<Number>=} aData.byhour              The hours for the BYHOUR part\r\n   * @param {Array.<String>=} aData.byday               The BYDAY values\r\n   * @param {Array.<Number>=} aData.bymonthday          The days for the BYMONTHDAY part\r\n   * @param {Array.<Number>=} aData.byyearday           The days for the BYYEARDAY part\r\n   * @param {Array.<Number>=} aData.byweekno            The weeks for the BYWEEKNO part\r\n   * @param {Array.<Number>=} aData.bymonth             The month for the BYMONTH part\r\n   * @param {Array.<Number>=} aData.bysetpos            The positionals for the BYSETPOS part\r\n   */\n\n\n  ICAL.Recur.fromData = function (aData) {\n    return new ICAL.Recur(aData);\n  };\n  /**\r\n   * Converts a recurrence string to a data object, suitable for the fromData\r\n   * method.\r\n   *\r\n   * @param {String} string     The string to parse\r\n   * @param {Boolean} fmtIcal   If true, the string is considered to be an\r\n   *                              iCalendar string\r\n   * @return {ICAL.Recur}       The recurrence instance\r\n   */\n\n\n  ICAL.Recur._stringToData = function (string, fmtIcal) {\n    var dict = Object.create(null); // split is slower in FF but fast enough.\n    // v8 however this is faster then manual split?\n\n    var values = string.split(';');\n    var len = values.length;\n\n    for (var i = 0; i < len; i++) {\n      var parts = values[i].split('=');\n      var ucname = parts[0].toUpperCase();\n      var lcname = parts[0].toLowerCase();\n      var name = fmtIcal ? lcname : ucname;\n      var value = parts[1];\n\n      if (ucname in partDesign) {\n        var partArr = value.split(',');\n        var partArrIdx = 0;\n        var partArrLen = partArr.length;\n\n        for (; partArrIdx < partArrLen; partArrIdx++) {\n          partArr[partArrIdx] = partDesign[ucname](partArr[partArrIdx]);\n        }\n\n        dict[name] = partArr.length == 1 ? partArr[0] : partArr;\n      } else if (ucname in optionDesign) {\n        optionDesign[ucname](value, dict, fmtIcal);\n      } else {\n        // Don't swallow unknown values. Just set them as they are.\n        dict[lcname] = value;\n      }\n    }\n\n    return dict;\n  };\n})();\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\r\n * This symbol is further described later on\r\n * @ignore\r\n */\n\n\nICAL.RecurIterator = function () {\n  /**\r\n   * @classdesc\r\n   * An iterator for a single recurrence rule. This class usually doesn't have\r\n   * to be instanciated directly, the convenience method\r\n   * {@link ICAL.Recur#iterator} can be used.\r\n   *\r\n   * @description\r\n   * The options object may contain additional members when resuming iteration from a previous run\r\n   *\r\n   * @description\r\n   * The options object may contain additional members when resuming iteration\r\n   * from a previous run.\r\n   *\r\n   * @class\r\n   * @alias ICAL.RecurIterator\r\n   * @param {Object} options                The iterator options\r\n   * @param {ICAL.Recur} options.rule       The rule to iterate.\r\n   * @param {ICAL.Time} options.dtstart     The start date of the event.\r\n   * @param {Boolean=} options.initialized  When true, assume that options are\r\n   *        from a previously constructed iterator. Initialization will not be\r\n   *        repeated.\r\n   */\n  function icalrecur_iterator(options) {\n    this.fromData(options);\n  }\n\n  icalrecur_iterator.prototype = {\n    /**\r\n     * True when iteration is finished.\r\n     * @type {Boolean}\r\n     */\n    completed: false,\n\n    /**\r\n     * The rule that is being iterated\r\n     * @type {ICAL.Recur}\r\n     */\n    rule: null,\n\n    /**\r\n     * The start date of the event being iterated.\r\n     * @type {ICAL.Time}\r\n     */\n    dtstart: null,\n\n    /**\r\n     * The last occurrence that was returned from the\r\n     * {@link ICAL.RecurIterator#next} method.\r\n     * @type {ICAL.Time}\r\n     */\n    last: null,\n\n    /**\r\n     * The sequence number from the occurrence\r\n     * @type {Number}\r\n     */\n    occurrence_number: 0,\n\n    /**\r\n     * The indices used for the {@link ICAL.RecurIterator#by_data} object.\r\n     * @type {Object}\r\n     * @private\r\n     */\n    by_indices: null,\n\n    /**\r\n     * If true, the iterator has already been initialized\r\n     * @type {Boolean}\r\n     * @private\r\n     */\n    initialized: false,\n\n    /**\r\n     * The initializd by-data.\r\n     * @type {Object}\r\n     * @private\r\n     */\n    by_data: null,\n\n    /**\r\n     * The expanded yeardays\r\n     * @type {Array}\r\n     * @private\r\n     */\n    days: null,\n\n    /**\r\n     * The index in the {@link ICAL.RecurIterator#days} array.\r\n     * @type {Number}\r\n     * @private\r\n     */\n    days_index: 0,\n\n    /**\r\n     * Initialize the recurrence iterator from the passed data object. This\r\n     * method is usually not called directly, you can initialize the iterator\r\n     * through the constructor.\r\n     *\r\n     * @param {Object} options                The iterator options\r\n     * @param {ICAL.Recur} options.rule       The rule to iterate.\r\n     * @param {ICAL.Time} options.dtstart     The start date of the event.\r\n     * @param {Boolean=} options.initialized  When true, assume that options are\r\n     *        from a previously constructed iterator. Initialization will not be\r\n     *        repeated.\r\n     */\n    fromData: function fromData(options) {\n      this.rule = ICAL.helpers.formatClassType(options.rule, ICAL.Recur);\n\n      if (!this.rule) {\n        throw new Error('iterator requires a (ICAL.Recur) rule');\n      }\n\n      this.dtstart = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);\n\n      if (!this.dtstart) {\n        throw new Error('iterator requires a (ICAL.Time) dtstart');\n      }\n\n      if (options.by_data) {\n        this.by_data = options.by_data;\n      } else {\n        this.by_data = ICAL.helpers.clone(this.rule.parts, true);\n      }\n\n      if (options.occurrence_number) this.occurrence_number = options.occurrence_number;\n      this.days = options.days || [];\n\n      if (options.last) {\n        this.last = ICAL.helpers.formatClassType(options.last, ICAL.Time);\n      }\n\n      this.by_indices = options.by_indices;\n\n      if (!this.by_indices) {\n        this.by_indices = {\n          \"BYSECOND\": 0,\n          \"BYMINUTE\": 0,\n          \"BYHOUR\": 0,\n          \"BYDAY\": 0,\n          \"BYMONTH\": 0,\n          \"BYWEEKNO\": 0,\n          \"BYMONTHDAY\": 0\n        };\n      }\n\n      this.initialized = options.initialized || false;\n\n      if (!this.initialized) {\n        this.init();\n      }\n    },\n\n    /**\r\n     * Intialize the iterator\r\n     * @private\r\n     */\n    init: function icalrecur_iterator_init() {\n      this.initialized = true;\n      this.last = this.dtstart.clone();\n      var parts = this.by_data;\n\n      if (\"BYDAY\" in parts) {\n        // libical does this earlier when the rule is loaded, but we postpone to\n        // now so we can preserve the original order.\n        this.sort_byday_rules(parts.BYDAY);\n      } // If the BYYEARDAY appares, no other date rule part may appear\n\n\n      if (\"BYYEARDAY\" in parts) {\n        if (\"BYMONTH\" in parts || \"BYWEEKNO\" in parts || \"BYMONTHDAY\" in parts || \"BYDAY\" in parts) {\n          throw new Error(\"Invalid BYYEARDAY rule\");\n        }\n      } // BYWEEKNO and BYMONTHDAY rule parts may not both appear\n\n\n      if (\"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) {\n        throw new Error(\"BYWEEKNO does not fit to BYMONTHDAY\");\n      } // For MONTHLY recurrences (FREQ=MONTHLY) neither BYYEARDAY nor\n      // BYWEEKNO may appear.\n\n\n      if (this.rule.freq == \"MONTHLY\" && (\"BYYEARDAY\" in parts || \"BYWEEKNO\" in parts)) {\n        throw new Error(\"For MONTHLY recurrences neither BYYEARDAY nor BYWEEKNO may appear\");\n      } // For WEEKLY recurrences (FREQ=WEEKLY) neither BYMONTHDAY nor\n      // BYYEARDAY may appear.\n\n\n      if (this.rule.freq == \"WEEKLY\" && (\"BYYEARDAY\" in parts || \"BYMONTHDAY\" in parts)) {\n        throw new Error(\"For WEEKLY recurrences neither BYMONTHDAY nor BYYEARDAY may appear\");\n      } // BYYEARDAY may only appear in YEARLY rules\n\n\n      if (this.rule.freq != \"YEARLY\" && \"BYYEARDAY\" in parts) {\n        throw new Error(\"BYYEARDAY may only appear in YEARLY rules\");\n      }\n\n      this.last.second = this.setup_defaults(\"BYSECOND\", \"SECONDLY\", this.dtstart.second);\n      this.last.minute = this.setup_defaults(\"BYMINUTE\", \"MINUTELY\", this.dtstart.minute);\n      this.last.hour = this.setup_defaults(\"BYHOUR\", \"HOURLY\", this.dtstart.hour);\n      this.last.day = this.setup_defaults(\"BYMONTHDAY\", \"DAILY\", this.dtstart.day);\n      this.last.month = this.setup_defaults(\"BYMONTH\", \"MONTHLY\", this.dtstart.month);\n\n      if (this.rule.freq == \"WEEKLY\") {\n        if (\"BYDAY\" in parts) {\n          var bydayParts = this.ruleDayOfWeek(parts.BYDAY[0], this.rule.wkst);\n          var pos = bydayParts[0];\n          var dow = bydayParts[1];\n          var wkdy = dow - this.last.dayOfWeek(this.rule.wkst);\n\n          if (this.last.dayOfWeek(this.rule.wkst) < dow && wkdy >= 0 || wkdy < 0) {\n            // Initial time is after first day of BYDAY data\n            this.last.day += wkdy;\n          }\n        } else {\n          var dayName = ICAL.Recur.numericDayToIcalDay(this.dtstart.dayOfWeek());\n          parts.BYDAY = [dayName];\n        }\n      }\n\n      if (this.rule.freq == \"YEARLY\") {\n        for (;;) {\n          this.expand_year_days(this.last.year);\n\n          if (this.days.length > 0) {\n            break;\n          }\n\n          this.increment_year(this.rule.interval);\n        }\n\n        this._nextByYearDay();\n      }\n\n      if (this.rule.freq == \"MONTHLY\" && this.has_by_data(\"BYDAY\")) {\n        var tempLast = null;\n        var initLast = this.last.clone();\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year); // Check every weekday in BYDAY with relative dow and pos.\n\n        for (var i in this.by_data.BYDAY) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYDAY.hasOwnProperty(i)) {\n            continue;\n          }\n\n          this.last = initLast.clone();\n          var bydayParts = this.ruleDayOfWeek(this.by_data.BYDAY[i]);\n          var pos = bydayParts[0];\n          var dow = bydayParts[1];\n          var dayOfMonth = this.last.nthWeekDay(dow, pos); // If |pos| >= 6, the byday is invalid for a monthly rule.\n\n          if (pos >= 6 || pos <= -6) {\n            throw new Error(\"Malformed values in BYDAY part\");\n          } // If a Byday with pos=+/-5 is not in the current month it\n          // must be searched in the next months.\n\n\n          if (dayOfMonth > daysInMonth || dayOfMonth <= 0) {\n            // Skip if we have already found a \"last\" in this month.\n            if (tempLast && tempLast.month == initLast.month) {\n              continue;\n            }\n\n            while (dayOfMonth > daysInMonth || dayOfMonth <= 0) {\n              this.increment_month();\n              daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n              dayOfMonth = this.last.nthWeekDay(dow, pos);\n            }\n          }\n\n          this.last.day = dayOfMonth;\n\n          if (!tempLast || this.last.compare(tempLast) < 0) {\n            tempLast = this.last.clone();\n          }\n        }\n\n        this.last = tempLast.clone(); //XXX: This feels like a hack, but we need to initialize\n        //     the BYMONTHDAY case correctly and byDayAndMonthDay handles\n        //     this case. It accepts a special flag which will avoid incrementing\n        //     the initial value without the flag days that match the start time\n        //     would be missed.\n\n        if (this.has_by_data('BYMONTHDAY')) {\n          this._byDayAndMonthDay(true);\n        }\n\n        if (this.last.day > daysInMonth || this.last.day == 0) {\n          throw new Error(\"Malformed values in BYDAY part\");\n        }\n      } else if (this.has_by_data(\"BYMONTHDAY\")) {\n        if (this.last.day < 0) {\n          var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n          this.last.day = daysInMonth + this.last.day + 1;\n        }\n      }\n    },\n\n    /**\r\n     * Retrieve the next occurrence from the iterator.\r\n     * @return {ICAL.Time}\r\n     */\n    next: function icalrecur_iterator_next() {\n      var before = this.last ? this.last.clone() : null;\n\n      if (this.rule.count && this.occurrence_number >= this.rule.count || this.rule.until && this.last.compare(this.rule.until) > 0) {\n        //XXX: right now this is just a flag and has no impact\n        //     we can simplify the above case to check for completed later.\n        this.completed = true;\n        return null;\n      }\n\n      if (this.occurrence_number == 0 && this.last.compare(this.dtstart) >= 0) {\n        // First of all, give the instance that was initialized\n        this.occurrence_number++;\n        return this.last;\n      }\n\n      var valid;\n\n      do {\n        valid = 1;\n\n        switch (this.rule.freq) {\n          case \"SECONDLY\":\n            this.next_second();\n            break;\n\n          case \"MINUTELY\":\n            this.next_minute();\n            break;\n\n          case \"HOURLY\":\n            this.next_hour();\n            break;\n\n          case \"DAILY\":\n            this.next_day();\n            break;\n\n          case \"WEEKLY\":\n            this.next_week();\n            break;\n\n          case \"MONTHLY\":\n            valid = this.next_month();\n            break;\n\n          case \"YEARLY\":\n            this.next_year();\n            break;\n\n          default:\n            return null;\n        }\n      } while (!this.check_contracting_rules() || this.last.compare(this.dtstart) < 0 || !valid); // TODO is this valid?\n\n\n      if (this.last.compare(before) == 0) {\n        throw new Error(\"Same occurrence found twice, protecting \" + \"you from death by recursion\");\n      }\n\n      if (this.rule.until && this.last.compare(this.rule.until) > 0) {\n        this.completed = true;\n        return null;\n      } else {\n        this.occurrence_number++;\n        return this.last;\n      }\n    },\n    next_second: function next_second() {\n      return this.next_generic(\"BYSECOND\", \"SECONDLY\", \"second\", \"minute\");\n    },\n    increment_second: function increment_second(inc) {\n      return this.increment_generic(inc, \"second\", 60, \"minute\");\n    },\n    next_minute: function next_minute() {\n      return this.next_generic(\"BYMINUTE\", \"MINUTELY\", \"minute\", \"hour\", \"next_second\");\n    },\n    increment_minute: function increment_minute(inc) {\n      return this.increment_generic(inc, \"minute\", 60, \"hour\");\n    },\n    next_hour: function next_hour() {\n      return this.next_generic(\"BYHOUR\", \"HOURLY\", \"hour\", \"monthday\", \"next_minute\");\n    },\n    increment_hour: function increment_hour(inc) {\n      this.increment_generic(inc, \"hour\", 24, \"monthday\");\n    },\n    next_day: function next_day() {\n      var has_by_day = (\"BYDAY\" in this.by_data);\n      var this_freq = this.rule.freq == \"DAILY\";\n\n      if (this.next_hour() == 0) {\n        return 0;\n      }\n\n      if (this_freq) {\n        this.increment_monthday(this.rule.interval);\n      } else {\n        this.increment_monthday(1);\n      }\n\n      return 0;\n    },\n    next_week: function next_week() {\n      var end_of_data = 0;\n\n      if (this.next_weekday_by_week() == 0) {\n        return end_of_data;\n      }\n\n      if (this.has_by_data(\"BYWEEKNO\")) {\n        var idx = ++this.by_indices.BYWEEKNO;\n\n        if (this.by_indices.BYWEEKNO == this.by_data.BYWEEKNO.length) {\n          this.by_indices.BYWEEKNO = 0;\n          end_of_data = 1;\n        } // HACK should be first month of the year\n\n\n        this.last.month = 1;\n        this.last.day = 1;\n        var week_no = this.by_data.BYWEEKNO[this.by_indices.BYWEEKNO];\n        this.last.day += 7 * week_no;\n\n        if (end_of_data) {\n          this.increment_year(1);\n        }\n      } else {\n        // Jump to the next week\n        this.increment_monthday(7 * this.rule.interval);\n      }\n\n      return end_of_data;\n    },\n\n    /**\r\n     * Normalize each by day rule for a given year/month.\r\n     * Takes into account ordering and negative rules\r\n     *\r\n     * @private\r\n     * @param {Number} year         Current year.\r\n     * @param {Number} month        Current month.\r\n     * @param {Array}  rules        Array of rules.\r\n     *\r\n     * @return {Array} sorted and normalized rules.\r\n     *                 Negative rules will be expanded to their\r\n     *                 correct positive values for easier processing.\r\n     */\n    normalizeByMonthDayRules: function normalizeByMonthDayRules(year, month, rules) {\n      var daysInMonth = ICAL.Time.daysInMonth(month, year); // XXX: This is probably bad for performance to allocate\n      //      a new array for each month we scan, if possible\n      //      we should try to optimize this...\n\n      var newRules = [];\n      var ruleIdx = 0;\n      var len = rules.length;\n      var rule;\n\n      for (; ruleIdx < len; ruleIdx++) {\n        rule = rules[ruleIdx]; // if this rule falls outside of given\n        // month discard it.\n\n        if (Math.abs(rule) > daysInMonth) {\n          continue;\n        } // negative case\n\n\n        if (rule < 0) {\n          // we add (not subtract its a negative number)\n          // one from the rule because 1 === last day of month\n          rule = daysInMonth + (rule + 1);\n        } else if (rule === 0) {\n          // skip zero its invalid.\n          continue;\n        } // only add unique items...\n\n\n        if (newRules.indexOf(rule) === -1) {\n          newRules.push(rule);\n        }\n      } // unique and sort\n\n\n      return newRules.sort(function (a, b) {\n        return a - b;\n      });\n    },\n\n    /**\r\n     * NOTES:\r\n     * We are given a list of dates in the month (BYMONTHDAY) (23, etc..)\r\n     * Also we are given a list of days (BYDAY) (MO, 2SU, etc..) when\r\n     * both conditions match a given date (this.last.day) iteration stops.\r\n     *\r\n     * @private\r\n     * @param {Boolean=} isInit     When given true will not increment the\r\n     *                                current day (this.last).\r\n     */\n    _byDayAndMonthDay: function _byDayAndMonthDay(isInit) {\n      var byMonthDay; // setup in initMonth\n\n      var byDay = this.by_data.BYDAY;\n      var date;\n      var dateIdx = 0;\n      var dateLen; // setup in initMonth\n\n      var dayLen = byDay.length; // we are not valid by default\n\n      var dataIsValid = 0;\n      var daysInMonth;\n      var self = this; // we need a copy of this, because a DateTime gets normalized\n      // automatically if the day is out of range. At some points we\n      // set the last day to 0 to start counting.\n\n      var lastDay = this.last.day;\n\n      function initMonth() {\n        daysInMonth = ICAL.Time.daysInMonth(self.last.month, self.last.year);\n        byMonthDay = self.normalizeByMonthDayRules(self.last.year, self.last.month, self.by_data.BYMONTHDAY);\n        dateLen = byMonthDay.length; // For the case of more than one occurrence in one month\n        // we have to be sure to start searching after the last\n        // found date or at the last BYMONTHDAY, unless we are\n        // initializing the iterator because in this case we have\n        // to consider the last found date too.\n\n        while (byMonthDay[dateIdx] <= lastDay && !(isInit && byMonthDay[dateIdx] == lastDay) && dateIdx < dateLen - 1) {\n          dateIdx++;\n        }\n      }\n\n      function nextMonth() {\n        // since the day is incremented at the start\n        // of the loop below, we need to start at 0\n        lastDay = 0;\n        self.increment_month();\n        dateIdx = 0;\n        initMonth();\n      }\n\n      initMonth(); // should come after initMonth\n\n      if (isInit) {\n        lastDay -= 1;\n      } // Use a counter to avoid an infinite loop with malformed rules.\n      // Stop checking after 4 years so we consider also a leap year.\n\n\n      var monthsCounter = 48;\n\n      while (!dataIsValid && monthsCounter) {\n        monthsCounter--; // increment the current date. This is really\n        // important otherwise we may fall into the infinite\n        // loop trap. The initial date takes care of the case\n        // where the current date is the date we are looking\n        // for.\n\n        date = lastDay + 1;\n\n        if (date > daysInMonth) {\n          nextMonth();\n          continue;\n        } // find next date\n\n\n        var next = byMonthDay[dateIdx++]; // this logic is dependant on the BYMONTHDAYS\n        // being in order (which is done by #normalizeByMonthDayRules)\n\n        if (next >= date) {\n          // if the next month day is in the future jump to it.\n          lastDay = next;\n        } else {\n          // in this case the 'next' monthday has past\n          // we must move to the month.\n          nextMonth();\n          continue;\n        } // Now we can loop through the day rules to see\n        // if one matches the current month date.\n\n\n        for (var dayIdx = 0; dayIdx < dayLen; dayIdx++) {\n          var parts = this.ruleDayOfWeek(byDay[dayIdx]);\n          var pos = parts[0];\n          var dow = parts[1];\n          this.last.day = lastDay;\n\n          if (this.last.isNthWeekDay(dow, pos)) {\n            // when we find the valid one we can mark\n            // the conditions as met and break the loop.\n            // (Because we have this condition above\n            //  it will also break the parent loop).\n            dataIsValid = 1;\n            break;\n          }\n        } // Its completely possible that the combination\n        // cannot be matched in the current month.\n        // When we reach the end of possible combinations\n        // in the current month we iterate to the next one.\n        // since dateIdx is incremented right after getting\n        // \"next\", we don't need dateLen -1 here.\n\n\n        if (!dataIsValid && dateIdx === dateLen) {\n          nextMonth();\n          continue;\n        }\n      }\n\n      if (monthsCounter <= 0) {\n        // Checked 4 years without finding a Byday that matches\n        // a Bymonthday. Maybe the rule is not correct.\n        throw new Error(\"Malformed values in BYDAY combined with BYMONTHDAY parts\");\n      }\n\n      return dataIsValid;\n    },\n    next_month: function next_month() {\n      var this_freq = this.rule.freq == \"MONTHLY\";\n      var data_valid = 1;\n\n      if (this.next_hour() == 0) {\n        return data_valid;\n      }\n\n      if (this.has_by_data(\"BYDAY\") && this.has_by_data(\"BYMONTHDAY\")) {\n        data_valid = this._byDayAndMonthDay();\n      } else if (this.has_by_data(\"BYDAY\")) {\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        var setpos = 0;\n        var setpos_total = 0;\n\n        if (this.has_by_data(\"BYSETPOS\")) {\n          var last_day = this.last.day;\n\n          for (var day = 1; day <= daysInMonth; day++) {\n            this.last.day = day;\n\n            if (this.is_day_in_byday(this.last)) {\n              setpos_total++;\n\n              if (day <= last_day) {\n                setpos++;\n              }\n            }\n          }\n\n          this.last.day = last_day;\n        }\n\n        data_valid = 0;\n\n        for (var day = this.last.day + 1; day <= daysInMonth; day++) {\n          this.last.day = day;\n\n          if (this.is_day_in_byday(this.last)) {\n            if (!this.has_by_data(\"BYSETPOS\") || this.check_set_position(++setpos) || this.check_set_position(setpos - setpos_total - 1)) {\n              data_valid = 1;\n              break;\n            }\n          }\n        }\n\n        if (day > daysInMonth) {\n          this.last.day = 1;\n          this.increment_month();\n\n          if (this.is_day_in_byday(this.last)) {\n            if (!this.has_by_data(\"BYSETPOS\") || this.check_set_position(1)) {\n              data_valid = 1;\n            }\n          } else {\n            data_valid = 0;\n          }\n        }\n      } else if (this.has_by_data(\"BYMONTHDAY\")) {\n        this.by_indices.BYMONTHDAY++;\n\n        if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) {\n          this.by_indices.BYMONTHDAY = 0;\n          this.increment_month();\n        }\n\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        var day = this.by_data.BYMONTHDAY[this.by_indices.BYMONTHDAY];\n\n        if (day < 0) {\n          day = daysInMonth + day + 1;\n        }\n\n        if (day > daysInMonth) {\n          this.last.day = 1;\n          data_valid = this.is_day_in_byday(this.last);\n        } else {\n          this.last.day = day;\n        }\n      } else {\n        this.increment_month();\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n\n        if (this.by_data.BYMONTHDAY[0] > daysInMonth) {\n          data_valid = 0;\n        } else {\n          this.last.day = this.by_data.BYMONTHDAY[0];\n        }\n      }\n\n      return data_valid;\n    },\n    next_weekday_by_week: function next_weekday_by_week() {\n      var end_of_data = 0;\n\n      if (this.next_hour() == 0) {\n        return end_of_data;\n      }\n\n      if (!this.has_by_data(\"BYDAY\")) {\n        return 1;\n      }\n\n      for (;;) {\n        var tt = new ICAL.Time();\n        this.by_indices.BYDAY++;\n\n        if (this.by_indices.BYDAY == Object.keys(this.by_data.BYDAY).length) {\n          this.by_indices.BYDAY = 0;\n          end_of_data = 1;\n        }\n\n        var coded_day = this.by_data.BYDAY[this.by_indices.BYDAY];\n        var parts = this.ruleDayOfWeek(coded_day);\n        var dow = parts[1];\n        dow -= this.rule.wkst;\n\n        if (dow < 0) {\n          dow += 7;\n        }\n\n        tt.year = this.last.year;\n        tt.month = this.last.month;\n        tt.day = this.last.day;\n        var startOfWeek = tt.startDoyWeek(this.rule.wkst);\n\n        if (dow + startOfWeek < 1) {\n          // The selected date is in the previous year\n          if (!end_of_data) {\n            continue;\n          }\n        }\n\n        var next = ICAL.Time.fromDayOfYear(startOfWeek + dow, this.last.year);\n        /**\r\n         * The normalization horrors below are due to\r\n         * the fact that when the year/month/day changes\r\n         * it can effect the other operations that come after.\r\n         */\n\n        this.last.year = next.year;\n        this.last.month = next.month;\n        this.last.day = next.day;\n        return end_of_data;\n      }\n    },\n    next_year: function next_year() {\n      if (this.next_hour() == 0) {\n        return 0;\n      }\n\n      if (++this.days_index == this.days.length) {\n        this.days_index = 0;\n\n        do {\n          this.increment_year(this.rule.interval);\n          this.expand_year_days(this.last.year);\n        } while (this.days.length == 0);\n      }\n\n      this._nextByYearDay();\n\n      return 1;\n    },\n    _nextByYearDay: function _nextByYearDay() {\n      var doy = this.days[this.days_index];\n      var year = this.last.year;\n\n      if (doy < 1) {\n        // Time.fromDayOfYear(doy, year) indexes relative to the\n        // start of the given year. That is different from the\n        // semantics of BYYEARDAY where negative indexes are an\n        // offset from the end of the given year.\n        doy += 1;\n        year += 1;\n      }\n\n      var next = ICAL.Time.fromDayOfYear(doy, year);\n      this.last.day = next.day;\n      this.last.month = next.month;\n    },\n\n    /**\r\n     * @param dow (eg: '1TU', '-1MO')\r\n     * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday\r\n     * @return [pos, numericDow] (eg: [1, 3]) numericDow is relative to aWeekStart\r\n     */\n    ruleDayOfWeek: function ruleDayOfWeek(dow, aWeekStart) {\n      var matches = dow.match(/([+-]?[0-9])?(MO|TU|WE|TH|FR|SA|SU)/);\n\n      if (matches) {\n        var pos = parseInt(matches[1] || 0, 10);\n        dow = ICAL.Recur.icalDayToNumericDay(matches[2], aWeekStart);\n        return [pos, dow];\n      } else {\n        return [0, 0];\n      }\n    },\n    next_generic: function next_generic(aRuleType, aInterval, aDateAttr, aFollowingAttr, aPreviousIncr) {\n      var has_by_rule = (aRuleType in this.by_data);\n      var this_freq = this.rule.freq == aInterval;\n      var end_of_data = 0;\n\n      if (aPreviousIncr && this[aPreviousIncr]() == 0) {\n        return end_of_data;\n      }\n\n      if (has_by_rule) {\n        this.by_indices[aRuleType]++;\n        var idx = this.by_indices[aRuleType];\n        var dta = this.by_data[aRuleType];\n\n        if (this.by_indices[aRuleType] == dta.length) {\n          this.by_indices[aRuleType] = 0;\n          end_of_data = 1;\n        }\n\n        this.last[aDateAttr] = dta[this.by_indices[aRuleType]];\n      } else if (this_freq) {\n        this[\"increment_\" + aDateAttr](this.rule.interval);\n      }\n\n      if (has_by_rule && end_of_data && this_freq) {\n        this[\"increment_\" + aFollowingAttr](1);\n      }\n\n      return end_of_data;\n    },\n    increment_monthday: function increment_monthday(inc) {\n      for (var i = 0; i < inc; i++) {\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\n        this.last.day++;\n\n        if (this.last.day > daysInMonth) {\n          this.last.day -= daysInMonth;\n          this.increment_month();\n        }\n      }\n    },\n    increment_month: function increment_month() {\n      this.last.day = 1;\n\n      if (this.has_by_data(\"BYMONTH\")) {\n        this.by_indices.BYMONTH++;\n\n        if (this.by_indices.BYMONTH == this.by_data.BYMONTH.length) {\n          this.by_indices.BYMONTH = 0;\n          this.increment_year(1);\n        }\n\n        this.last.month = this.by_data.BYMONTH[this.by_indices.BYMONTH];\n      } else {\n        if (this.rule.freq == \"MONTHLY\") {\n          this.last.month += this.rule.interval;\n        } else {\n          this.last.month++;\n        }\n\n        this.last.month--;\n        var years = ICAL.helpers.trunc(this.last.month / 12);\n        this.last.month %= 12;\n        this.last.month++;\n\n        if (years != 0) {\n          this.increment_year(years);\n        }\n      }\n    },\n    increment_year: function increment_year(inc) {\n      this.last.year += inc;\n    },\n    increment_generic: function increment_generic(inc, aDateAttr, aFactor, aNextIncrement) {\n      this.last[aDateAttr] += inc;\n      var nextunit = ICAL.helpers.trunc(this.last[aDateAttr] / aFactor);\n      this.last[aDateAttr] %= aFactor;\n\n      if (nextunit != 0) {\n        this[\"increment_\" + aNextIncrement](nextunit);\n      }\n    },\n    has_by_data: function has_by_data(aRuleType) {\n      return aRuleType in this.rule.parts;\n    },\n    expand_year_days: function expand_year_days(aYear) {\n      var t = new ICAL.Time();\n      this.days = []; // We need our own copy with a few keys set\n\n      var parts = {};\n      var rules = [\"BYDAY\", \"BYWEEKNO\", \"BYMONTHDAY\", \"BYMONTH\", \"BYYEARDAY\"];\n\n      for (var p in rules) {\n        /* istanbul ignore else */\n        if (rules.hasOwnProperty(p)) {\n          var part = rules[p];\n\n          if (part in this.rule.parts) {\n            parts[part] = this.rule.parts[part];\n          }\n        }\n      }\n\n      if (\"BYMONTH\" in parts && \"BYWEEKNO\" in parts) {\n        var valid = 1;\n        var validWeeks = {};\n        t.year = aYear;\n        t.isDate = true;\n\n        for (var monthIdx = 0; monthIdx < this.by_data.BYMONTH.length; monthIdx++) {\n          var month = this.by_data.BYMONTH[monthIdx];\n          t.month = month;\n          t.day = 1;\n          var first_week = t.weekNumber(this.rule.wkst);\n          t.day = ICAL.Time.daysInMonth(month, aYear);\n          var last_week = t.weekNumber(this.rule.wkst);\n\n          for (monthIdx = first_week; monthIdx < last_week; monthIdx++) {\n            validWeeks[monthIdx] = 1;\n          }\n        }\n\n        for (var weekIdx = 0; weekIdx < this.by_data.BYWEEKNO.length && valid; weekIdx++) {\n          var weekno = this.by_data.BYWEEKNO[weekIdx];\n\n          if (weekno < 52) {\n            valid &= validWeeks[weekIdx];\n          } else {\n            valid = 0;\n          }\n        }\n\n        if (valid) {\n          delete parts.BYMONTH;\n        } else {\n          delete parts.BYWEEKNO;\n        }\n      }\n\n      var partCount = Object.keys(parts).length;\n\n      if (partCount == 0) {\n        var t1 = this.dtstart.clone();\n        t1.year = this.last.year;\n        this.days.push(t1.dayOfYear());\n      } else if (partCount == 1 && \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n\n          var t2 = this.dtstart.clone();\n          t2.year = aYear;\n          t2.month = this.by_data.BYMONTH[monthkey];\n          t2.isDate = true;\n          this.days.push(t2.dayOfYear());\n        }\n      } else if (partCount == 1 && \"BYMONTHDAY\" in parts) {\n        for (var monthdaykey in this.by_data.BYMONTHDAY) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {\n            continue;\n          }\n\n          var t3 = this.dtstart.clone();\n          var day_ = this.by_data.BYMONTHDAY[monthdaykey];\n\n          if (day_ < 0) {\n            var daysInMonth = ICAL.Time.daysInMonth(t3.month, aYear);\n            day_ = day_ + daysInMonth + 1;\n          }\n\n          t3.day = day_;\n          t3.year = aYear;\n          t3.isDate = true;\n          this.days.push(t3.dayOfYear());\n        }\n      } else if (partCount == 2 && \"BYMONTHDAY\" in parts && \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n\n          var month_ = this.by_data.BYMONTH[monthkey];\n          var daysInMonth = ICAL.Time.daysInMonth(month_, aYear);\n\n          for (var monthdaykey in this.by_data.BYMONTHDAY) {\n            /* istanbul ignore if */\n            if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {\n              continue;\n            }\n\n            var day_ = this.by_data.BYMONTHDAY[monthdaykey];\n\n            if (day_ < 0) {\n              day_ = day_ + daysInMonth + 1;\n            }\n\n            t.day = day_;\n            t.month = month_;\n            t.year = aYear;\n            t.isDate = true;\n            this.days.push(t.dayOfYear());\n          }\n        }\n      } else if (partCount == 1 && \"BYWEEKNO\" in parts) {// TODO unimplemented in libical\n      } else if (partCount == 2 && \"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) {// TODO unimplemented in libical\n      } else if (partCount == 1 && \"BYDAY\" in parts) {\n        this.days = this.days.concat(this.expand_by_day(aYear));\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTH\" in parts) {\n        for (var monthkey in this.by_data.BYMONTH) {\n          /* istanbul ignore if */\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\n            continue;\n          }\n\n          var month = this.by_data.BYMONTH[monthkey];\n          var daysInMonth = ICAL.Time.daysInMonth(month, aYear);\n          t.year = aYear;\n          t.month = this.by_data.BYMONTH[monthkey];\n          t.day = 1;\n          t.isDate = true;\n          var first_dow = t.dayOfWeek();\n          var doy_offset = t.dayOfYear() - 1;\n          t.day = daysInMonth;\n          var last_dow = t.dayOfWeek();\n\n          if (this.has_by_data(\"BYSETPOS\")) {\n            var set_pos_counter = 0;\n            var by_month_day = [];\n\n            for (var day = 1; day <= daysInMonth; day++) {\n              t.day = day;\n\n              if (this.is_day_in_byday(t)) {\n                by_month_day.push(day);\n              }\n            }\n\n            for (var spIndex = 0; spIndex < by_month_day.length; spIndex++) {\n              if (this.check_set_position(spIndex + 1) || this.check_set_position(spIndex - by_month_day.length)) {\n                this.days.push(doy_offset + by_month_day[spIndex]);\n              }\n            }\n          } else {\n            for (var daycodedkey in this.by_data.BYDAY) {\n              /* istanbul ignore if */\n              if (!this.by_data.BYDAY.hasOwnProperty(daycodedkey)) {\n                continue;\n              }\n\n              var coded_day = this.by_data.BYDAY[daycodedkey];\n              var bydayParts = this.ruleDayOfWeek(coded_day);\n              var pos = bydayParts[0];\n              var dow = bydayParts[1];\n              var month_day;\n              var first_matching_day = (dow + 7 - first_dow) % 7 + 1;\n              var last_matching_day = daysInMonth - (last_dow + 7 - dow) % 7;\n\n              if (pos == 0) {\n                for (var day = first_matching_day; day <= daysInMonth; day += 7) {\n                  this.days.push(doy_offset + day);\n                }\n              } else if (pos > 0) {\n                month_day = first_matching_day + (pos - 1) * 7;\n\n                if (month_day <= daysInMonth) {\n                  this.days.push(doy_offset + month_day);\n                }\n              } else {\n                month_day = last_matching_day + (pos + 1) * 7;\n\n                if (month_day > 0) {\n                  this.days.push(doy_offset + month_day);\n                }\n              }\n            }\n          }\n        } // Return dates in order of occurrence (1,2,3,...) instead\n        // of by groups of weekdays (1,8,15,...,2,9,16,...).\n\n\n        this.days.sort(function (a, b) {\n          return a - b;\n        }); // Comparator function allows to sort numbers.\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTHDAY\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n\n          if (this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 3 && \"BYDAY\" in parts && \"BYMONTHDAY\" in parts && \"BYMONTH\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n\n          if (this.by_data.BYMONTH.indexOf(tt.month) >= 0 && this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYWEEKNO\" in parts) {\n        var expandedDays = this.expand_by_day(aYear);\n\n        for (var daykey in expandedDays) {\n          /* istanbul ignore if */\n          if (!expandedDays.hasOwnProperty(daykey)) {\n            continue;\n          }\n\n          var day = expandedDays[daykey];\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\n          var weekno = tt.weekNumber(this.rule.wkst);\n\n          if (this.by_data.BYWEEKNO.indexOf(weekno)) {\n            this.days.push(day);\n          }\n        }\n      } else if (partCount == 3 && \"BYDAY\" in parts && \"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) {// TODO unimplemted in libical\n      } else if (partCount == 1 && \"BYYEARDAY\" in parts) {\n        this.days = this.days.concat(this.by_data.BYYEARDAY);\n      } else {\n        this.days = [];\n      }\n\n      return 0;\n    },\n    expand_by_day: function expand_by_day(aYear) {\n      var days_list = [];\n      var tmp = this.last.clone();\n      tmp.year = aYear;\n      tmp.month = 1;\n      tmp.day = 1;\n      tmp.isDate = true;\n      var start_dow = tmp.dayOfWeek();\n      tmp.month = 12;\n      tmp.day = 31;\n      tmp.isDate = true;\n      var end_dow = tmp.dayOfWeek();\n      var end_year_day = tmp.dayOfYear();\n\n      for (var daykey in this.by_data.BYDAY) {\n        /* istanbul ignore if */\n        if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {\n          continue;\n        }\n\n        var day = this.by_data.BYDAY[daykey];\n        var parts = this.ruleDayOfWeek(day);\n        var pos = parts[0];\n        var dow = parts[1];\n\n        if (pos == 0) {\n          var tmp_start_doy = (dow + 7 - start_dow) % 7 + 1;\n\n          for (var doy = tmp_start_doy; doy <= end_year_day; doy += 7) {\n            days_list.push(doy);\n          }\n        } else if (pos > 0) {\n          var first;\n\n          if (dow >= start_dow) {\n            first = dow - start_dow + 1;\n          } else {\n            first = dow - start_dow + 8;\n          }\n\n          days_list.push(first + (pos - 1) * 7);\n        } else {\n          var last;\n          pos = -pos;\n\n          if (dow <= end_dow) {\n            last = end_year_day - end_dow + dow;\n          } else {\n            last = end_year_day - end_dow + dow - 7;\n          }\n\n          days_list.push(last - (pos - 1) * 7);\n        }\n      }\n\n      return days_list;\n    },\n    is_day_in_byday: function is_day_in_byday(tt) {\n      for (var daykey in this.by_data.BYDAY) {\n        /* istanbul ignore if */\n        if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {\n          continue;\n        }\n\n        var day = this.by_data.BYDAY[daykey];\n        var parts = this.ruleDayOfWeek(day);\n        var pos = parts[0];\n        var dow = parts[1];\n        var this_dow = tt.dayOfWeek();\n\n        if (pos == 0 && dow == this_dow || tt.nthWeekDay(dow, pos) == tt.day) {\n          return 1;\n        }\n      }\n\n      return 0;\n    },\n\n    /**\r\n     * Checks if given value is in BYSETPOS.\r\n     *\r\n     * @private\r\n     * @param {Numeric} aPos position to check for.\r\n     * @return {Boolean} false unless BYSETPOS rules exist\r\n     *                   and the given value is present in rules.\r\n     */\n    check_set_position: function check_set_position(aPos) {\n      if (this.has_by_data('BYSETPOS')) {\n        var idx = this.by_data.BYSETPOS.indexOf(aPos); // negative numbers are not false-y\n\n        return idx !== -1;\n      }\n\n      return false;\n    },\n    sort_byday_rules: function icalrecur_sort_byday_rules(aRules) {\n      for (var i = 0; i < aRules.length; i++) {\n        for (var j = 0; j < i; j++) {\n          var one = this.ruleDayOfWeek(aRules[j], this.rule.wkst)[1];\n          var two = this.ruleDayOfWeek(aRules[i], this.rule.wkst)[1];\n\n          if (one > two) {\n            var tmp = aRules[i];\n            aRules[i] = aRules[j];\n            aRules[j] = tmp;\n          }\n        }\n      }\n    },\n    check_contract_restriction: function check_contract_restriction(aRuleType, v) {\n      var indexMapValue = icalrecur_iterator._indexMap[aRuleType];\n      var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];\n      var pass = false;\n\n      if (aRuleType in this.by_data && ruleMapValue == icalrecur_iterator.CONTRACT) {\n        var ruleType = this.by_data[aRuleType];\n\n        for (var bydatakey in ruleType) {\n          /* istanbul ignore else */\n          if (ruleType.hasOwnProperty(bydatakey)) {\n            if (ruleType[bydatakey] == v) {\n              pass = true;\n              break;\n            }\n          }\n        }\n      } else {\n        // Not a contracting byrule or has no data, test passes\n        pass = true;\n      }\n\n      return pass;\n    },\n    check_contracting_rules: function check_contracting_rules() {\n      var dow = this.last.dayOfWeek();\n      var weekNo = this.last.weekNumber(this.rule.wkst);\n      var doy = this.last.dayOfYear();\n      return this.check_contract_restriction(\"BYSECOND\", this.last.second) && this.check_contract_restriction(\"BYMINUTE\", this.last.minute) && this.check_contract_restriction(\"BYHOUR\", this.last.hour) && this.check_contract_restriction(\"BYDAY\", ICAL.Recur.numericDayToIcalDay(dow)) && this.check_contract_restriction(\"BYWEEKNO\", weekNo) && this.check_contract_restriction(\"BYMONTHDAY\", this.last.day) && this.check_contract_restriction(\"BYMONTH\", this.last.month) && this.check_contract_restriction(\"BYYEARDAY\", doy);\n    },\n    setup_defaults: function setup_defaults(aRuleType, req, deftime) {\n      var indexMapValue = icalrecur_iterator._indexMap[aRuleType];\n      var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];\n\n      if (ruleMapValue != icalrecur_iterator.CONTRACT) {\n        if (!(aRuleType in this.by_data)) {\n          this.by_data[aRuleType] = [deftime];\n        }\n\n        if (this.rule.freq != req) {\n          return this.by_data[aRuleType][0];\n        }\n      }\n\n      return deftime;\n    },\n\n    /**\r\n     * Convert iterator into a serialize-able object.  Will preserve current\r\n     * iteration sequence to ensure the seamless continuation of the recurrence\r\n     * rule.\r\n     * @return {Object}\r\n     */\n    toJSON: function toJSON() {\n      var result = Object.create(null);\n      result.initialized = this.initialized;\n      result.rule = this.rule.toJSON();\n      result.dtstart = this.dtstart.toJSON();\n      result.by_data = this.by_data;\n      result.days = this.days;\n      result.last = this.last.toJSON();\n      result.by_indices = this.by_indices;\n      result.occurrence_number = this.occurrence_number;\n      return result;\n    }\n  };\n  icalrecur_iterator._indexMap = {\n    \"BYSECOND\": 0,\n    \"BYMINUTE\": 1,\n    \"BYHOUR\": 2,\n    \"BYDAY\": 3,\n    \"BYMONTHDAY\": 4,\n    \"BYYEARDAY\": 5,\n    \"BYWEEKNO\": 6,\n    \"BYMONTH\": 7,\n    \"BYSETPOS\": 8\n  };\n  icalrecur_iterator._expandMap = {\n    \"SECONDLY\": [1, 1, 1, 1, 1, 1, 1, 1],\n    \"MINUTELY\": [2, 1, 1, 1, 1, 1, 1, 1],\n    \"HOURLY\": [2, 2, 1, 1, 1, 1, 1, 1],\n    \"DAILY\": [2, 2, 2, 1, 1, 1, 1, 1],\n    \"WEEKLY\": [2, 2, 2, 2, 3, 3, 1, 1],\n    \"MONTHLY\": [2, 2, 2, 2, 2, 3, 3, 1],\n    \"YEARLY\": [2, 2, 2, 2, 2, 2, 2, 2]\n  };\n  icalrecur_iterator.UNKNOWN = 0;\n  icalrecur_iterator.CONTRACT = 1;\n  icalrecur_iterator.EXPAND = 2;\n  icalrecur_iterator.ILLEGAL = 3;\n  return icalrecur_iterator;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\r\n * This symbol is further described later on\r\n * @ignore\r\n */\n\n\nICAL.RecurExpansion = function () {\n  function formatTime(item) {\n    return ICAL.helpers.formatClassType(item, ICAL.Time);\n  }\n\n  function compareTime(a, b) {\n    return a.compare(b);\n  }\n\n  function isRecurringComponent(comp) {\n    return comp.hasProperty('rdate') || comp.hasProperty('rrule') || comp.hasProperty('recurrence-id');\n  }\n  /**\r\n   * @classdesc\r\n   * Primary class for expanding recurring rules.  Can take multiple rrules,\r\n   * rdates, exdate(s) and iterate (in order) over each next occurrence.\r\n   *\r\n   * Once initialized this class can also be serialized saved and continue\r\n   * iteration from the last point.\r\n   *\r\n   * NOTE: it is intended that this class is to be used\r\n   *       with ICAL.Event which handles recurrence exceptions.\r\n   *\r\n   * @example\r\n   * // assuming event is a parsed ical component\r\n   * var event;\r\n   *\r\n   * var expand = new ICAL.RecurExpansion({\r\n   *   component: event,\r\n   *   dtstart: event.getFirstPropertyValue('dtstart')\r\n   * });\r\n   *\r\n   * // remember there are infinite rules\r\n   * // so its a good idea to limit the scope\r\n   * // of the iterations then resume later on.\r\n   *\r\n   * // next is always an ICAL.Time or null\r\n   * var next;\r\n   *\r\n   * while (someCondition && (next = expand.next())) {\r\n   *   // do something with next\r\n   * }\r\n   *\r\n   * // save instance for later\r\n   * var json = JSON.stringify(expand);\r\n   *\r\n   * //...\r\n   *\r\n   * // NOTE: if the component's properties have\r\n   * //       changed you will need to rebuild the\r\n   * //       class and start over. This only works\r\n   * //       when the component's recurrence info is the same.\r\n   * var expand = new ICAL.RecurExpansion(JSON.parse(json));\r\n   *\r\n   * @description\r\n   * The options object can be filled with the specified initial values. It can\r\n   * also contain additional members, as a result of serializing a previous\r\n   * expansion state, as shown in the example.\r\n   *\r\n   * @class\r\n   * @alias ICAL.RecurExpansion\r\n   * @param {Object} options\r\n   *        Recurrence expansion options\r\n   * @param {ICAL.Time} options.dtstart\r\n   *        Start time of the event\r\n   * @param {ICAL.Component=} options.component\r\n   *        Component for expansion, required if not resuming.\r\n   */\n\n\n  function RecurExpansion(options) {\n    this.ruleDates = [];\n    this.exDates = [];\n    this.fromData(options);\n  }\n\n  RecurExpansion.prototype = {\n    /**\r\n     * True when iteration is fully completed.\r\n     * @type {Boolean}\r\n     */\n    complete: false,\n\n    /**\r\n     * Array of rrule iterators.\r\n     *\r\n     * @type {ICAL.RecurIterator[]}\r\n     * @private\r\n     */\n    ruleIterators: null,\n\n    /**\r\n     * Array of rdate instances.\r\n     *\r\n     * @type {ICAL.Time[]}\r\n     * @private\r\n     */\n    ruleDates: null,\n\n    /**\r\n     * Array of exdate instances.\r\n     *\r\n     * @type {ICAL.Time[]}\r\n     * @private\r\n     */\n    exDates: null,\n\n    /**\r\n     * Current position in ruleDates array.\r\n     * @type {Number}\r\n     * @private\r\n     */\n    ruleDateInc: 0,\n\n    /**\r\n     * Current position in exDates array\r\n     * @type {Number}\r\n     * @private\r\n     */\n    exDateInc: 0,\n\n    /**\r\n     * Current negative date.\r\n     *\r\n     * @type {ICAL.Time}\r\n     * @private\r\n     */\n    exDate: null,\n\n    /**\r\n     * Current additional date.\r\n     *\r\n     * @type {ICAL.Time}\r\n     * @private\r\n     */\n    ruleDate: null,\n\n    /**\r\n     * Start date of recurring rules.\r\n     *\r\n     * @type {ICAL.Time}\r\n     */\n    dtstart: null,\n\n    /**\r\n     * Last expanded time\r\n     *\r\n     * @type {ICAL.Time}\r\n     */\n    last: null,\n\n    /**\r\n     * Initialize the recurrence expansion from the data object. The options\r\n     * object may also contain additional members, see the\r\n     * {@link ICAL.RecurExpansion constructor} for more details.\r\n     *\r\n     * @param {Object} options\r\n     *        Recurrence expansion options\r\n     * @param {ICAL.Time} options.dtstart\r\n     *        Start time of the event\r\n     * @param {ICAL.Component=} options.component\r\n     *        Component for expansion, required if not resuming.\r\n     */\n    fromData: function fromData(options) {\n      var start = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);\n\n      if (!start) {\n        throw new Error('.dtstart (ICAL.Time) must be given');\n      } else {\n        this.dtstart = start;\n      }\n\n      if (options.component) {\n        this._init(options.component);\n      } else {\n        this.last = formatTime(options.last) || start.clone();\n\n        if (!options.ruleIterators) {\n          throw new Error('.ruleIterators or .component must be given');\n        }\n\n        this.ruleIterators = options.ruleIterators.map(function (item) {\n          return ICAL.helpers.formatClassType(item, ICAL.RecurIterator);\n        });\n        this.ruleDateInc = options.ruleDateInc;\n        this.exDateInc = options.exDateInc;\n\n        if (options.ruleDates) {\n          this.ruleDates = options.ruleDates.map(formatTime);\n          this.ruleDate = this.ruleDates[this.ruleDateInc];\n        }\n\n        if (options.exDates) {\n          this.exDates = options.exDates.map(formatTime);\n          this.exDate = this.exDates[this.exDateInc];\n        }\n\n        if (typeof options.complete !== 'undefined') {\n          this.complete = options.complete;\n        }\n      }\n    },\n\n    /**\r\n     * Retrieve the next occurrence in the series.\r\n     * @return {ICAL.Time}\r\n     */\n    next: function next() {\n      var iter;\n      var ruleOfDay;\n      var next;\n      var compare;\n      var maxTries = 500;\n      var currentTry = 0;\n\n      while (true) {\n        if (currentTry++ > maxTries) {\n          throw new Error('max tries have occured, rule may be impossible to forfill.');\n        }\n\n        next = this.ruleDate;\n        iter = this._nextRecurrenceIter(this.last); // no more matches\n        // because we increment the rule day or rule\n        // _after_ we choose a value this should be\n        // the only spot where we need to worry about the\n        // end of events.\n\n        if (!next && !iter) {\n          // there are no more iterators or rdates\n          this.complete = true;\n          break;\n        } // no next rule day or recurrence rule is first.\n\n\n        if (!next || iter && next.compare(iter.last) > 0) {\n          // must be cloned, recur will reuse the time element.\n          next = iter.last.clone(); // move to next so we can continue\n\n          iter.next();\n        } // if the ruleDate is still next increment it.\n\n\n        if (this.ruleDate === next) {\n          this._nextRuleDay();\n        }\n\n        this.last = next; // check the negative rules\n\n        if (this.exDate) {\n          compare = this.exDate.compare(this.last);\n\n          if (compare < 0) {\n            this._nextExDay();\n          } // if the current rule is excluded skip it.\n\n\n          if (compare === 0) {\n            this._nextExDay();\n\n            continue;\n          }\n        } //XXX: The spec states that after we resolve the final\n        //     list of dates we execute exdate this seems somewhat counter\n        //     intuitive to what I have seen most servers do so for now\n        //     I exclude based on the original date not the one that may\n        //     have been modified by the exception.\n\n\n        return this.last;\n      }\n    },\n\n    /**\r\n     * Converts object into a serialize-able format. This format can be passed\r\n     * back into the expansion to resume iteration.\r\n     * @return {Object}\r\n     */\n    toJSON: function toJSON() {\n      function toJSON(item) {\n        return item.toJSON();\n      }\n\n      var result = Object.create(null);\n      result.ruleIterators = this.ruleIterators.map(toJSON);\n\n      if (this.ruleDates) {\n        result.ruleDates = this.ruleDates.map(toJSON);\n      }\n\n      if (this.exDates) {\n        result.exDates = this.exDates.map(toJSON);\n      }\n\n      result.ruleDateInc = this.ruleDateInc;\n      result.exDateInc = this.exDateInc;\n      result.last = this.last.toJSON();\n      result.dtstart = this.dtstart.toJSON();\n      result.complete = this.complete;\n      return result;\n    },\n\n    /**\r\n     * Extract all dates from the properties in the given component. The\r\n     * properties will be filtered by the property name.\r\n     *\r\n     * @private\r\n     * @param {ICAL.Component} component        The component to search in\r\n     * @param {String} propertyName             The property name to search for\r\n     * @return {ICAL.Time[]}                    The extracted dates.\r\n     */\n    _extractDates: function _extractDates(component, propertyName) {\n      function handleProp(prop) {\n        idx = ICAL.helpers.binsearchInsert(result, prop, compareTime); // ordered insert\n\n        result.splice(idx, 0, prop);\n      }\n\n      var result = [];\n      var props = component.getAllProperties(propertyName);\n      var len = props.length;\n      var i = 0;\n      var prop;\n      var idx;\n\n      for (; i < len; i++) {\n        props[i].getValues().forEach(handleProp);\n      }\n\n      return result;\n    },\n\n    /**\r\n     * Initialize the recurrence expansion.\r\n     *\r\n     * @private\r\n     * @param {ICAL.Component} component    The component to initialize from.\r\n     */\n    _init: function _init(component) {\n      this.ruleIterators = [];\n      this.last = this.dtstart.clone(); // to provide api consistency non-recurring\n      // events can also use the iterator though it will\n      // only return a single time.\n\n      if (!isRecurringComponent(component)) {\n        this.ruleDate = this.last.clone();\n        this.complete = true;\n        return;\n      }\n\n      if (component.hasProperty('rdate')) {\n        this.ruleDates = this._extractDates(component, 'rdate'); // special hack for cases where first rdate is prior\n        // to the start date. We only check for the first rdate.\n        // This is mostly for google's crazy recurring date logic\n        // (contacts birthdays).\n\n        if (this.ruleDates[0] && this.ruleDates[0].compare(this.dtstart) < 0) {\n          this.ruleDateInc = 0;\n          this.last = this.ruleDates[0].clone();\n        } else {\n          this.ruleDateInc = ICAL.helpers.binsearchInsert(this.ruleDates, this.last, compareTime);\n        }\n\n        this.ruleDate = this.ruleDates[this.ruleDateInc];\n      }\n\n      if (component.hasProperty('rrule')) {\n        var rules = component.getAllProperties('rrule');\n        var i = 0;\n        var len = rules.length;\n        var rule;\n        var iter;\n\n        for (; i < len; i++) {\n          rule = rules[i].getFirstValue();\n          iter = rule.iterator(this.dtstart);\n          this.ruleIterators.push(iter); // increment to the next occurrence so future\n          // calls to next return times beyond the initial iteration.\n          // XXX: I find this suspicious might be a bug?\n\n          iter.next();\n        }\n      }\n\n      if (component.hasProperty('exdate')) {\n        this.exDates = this._extractDates(component, 'exdate'); // if we have a .last day we increment the index to beyond it.\n\n        this.exDateInc = ICAL.helpers.binsearchInsert(this.exDates, this.last, compareTime);\n        this.exDate = this.exDates[this.exDateInc];\n      }\n    },\n\n    /**\r\n     * Advance to the next exdate\r\n     * @private\r\n     */\n    _nextExDay: function _nextExDay() {\n      this.exDate = this.exDates[++this.exDateInc];\n    },\n\n    /**\r\n     * Advance to the next rule date\r\n     * @private\r\n     */\n    _nextRuleDay: function _nextRuleDay() {\n      this.ruleDate = this.ruleDates[++this.ruleDateInc];\n    },\n\n    /**\r\n     * Find and return the recurrence rule with the most recent event and\r\n     * return it.\r\n     *\r\n     * @private\r\n     * @return {?ICAL.RecurIterator}    Found iterator.\r\n     */\n    _nextRecurrenceIter: function _nextRecurrenceIter() {\n      var iters = this.ruleIterators;\n\n      if (iters.length === 0) {\n        return null;\n      }\n\n      var len = iters.length;\n      var iter;\n      var iterTime;\n      var iterIdx = 0;\n      var chosenIter; // loop through each iterator\n\n      for (; iterIdx < len; iterIdx++) {\n        iter = iters[iterIdx];\n        iterTime = iter.last; // if iteration is complete\n        // then we must exclude it from\n        // the search and remove it.\n\n        if (iter.completed) {\n          len--;\n\n          if (iterIdx !== 0) {\n            iterIdx--;\n          }\n\n          iters.splice(iterIdx, 1);\n          continue;\n        } // find the most recent possible choice\n\n\n        if (!chosenIter || chosenIter.last.compare(iterTime) > 0) {\n          // that iterator is saved\n          chosenIter = iter;\n        }\n      } // the chosen iterator is returned but not mutated\n      // this iterator contains the most recent event.\n\n\n      return chosenIter;\n    }\n  };\n  return RecurExpansion;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\r\n * This symbol is further described later on\r\n * @ignore\r\n */\n\n\nICAL.Event = function () {\n  /**\r\n   * @classdesc\r\n   * ICAL.js is organized into multiple layers. The bottom layer is a raw jCal\r\n   * object, followed by the component/property layer. The highest level is the\r\n   * event representation, which this class is part of. See the\r\n   * {@tutorial layers} guide for more details.\r\n   *\r\n   * @class\r\n   * @alias ICAL.Event\r\n   * @param {ICAL.Component=} component         The ICAL.Component to base this event on\r\n   * @param {Object} options                    Options for this event\r\n   * @param {Boolean} options.strictExceptions\r\n   *          When true, will verify exceptions are related by their UUID\r\n   * @param {Array<ICAL.Component|ICAL.Event>} options.exceptions\r\n   *          Exceptions to this event, either as components or events. If not\r\n   *            specified exceptions will automatically be set in relation of\r\n   *            component's parent\r\n   */\n  function Event(component, options) {\n    if (!(component instanceof ICAL.Component)) {\n      options = component;\n      component = null;\n    }\n\n    if (component) {\n      this.component = component;\n    } else {\n      this.component = new ICAL.Component('vevent');\n    }\n\n    this._rangeExceptionCache = Object.create(null);\n    this.exceptions = Object.create(null);\n    this.rangeExceptions = [];\n\n    if (options && options.strictExceptions) {\n      this.strictExceptions = options.strictExceptions;\n    }\n\n    if (options && options.exceptions) {\n      options.exceptions.forEach(this.relateException, this);\n    } else if (this.component.parent && !this.isRecurrenceException()) {\n      this.component.parent.getAllSubcomponents('vevent').forEach(function (event) {\n        if (event.hasProperty('recurrence-id')) {\n          this.relateException(event);\n        }\n      }, this);\n    }\n  }\n\n  Event.prototype = {\n    THISANDFUTURE: 'THISANDFUTURE',\n\n    /**\r\n     * List of related event exceptions.\r\n     *\r\n     * @type {ICAL.Event[]}\r\n     */\n    exceptions: null,\n\n    /**\r\n     * When true, will verify exceptions are related by their UUID.\r\n     *\r\n     * @type {Boolean}\r\n     */\n    strictExceptions: false,\n\n    /**\r\n     * Relates a given event exception to this object.  If the given component\r\n     * does not share the UID of this event it cannot be related and will throw\r\n     * an exception.\r\n     *\r\n     * If this component is an exception it cannot have other exceptions\r\n     * related to it.\r\n     *\r\n     * @param {ICAL.Component|ICAL.Event} obj       Component or event\r\n     */\n    relateException: function relateException(obj) {\n      if (this.isRecurrenceException()) {\n        throw new Error('cannot relate exception to exceptions');\n      }\n\n      if (obj instanceof ICAL.Component) {\n        obj = new ICAL.Event(obj);\n      }\n\n      if (this.strictExceptions && obj.uid !== this.uid) {\n        throw new Error('attempted to relate unrelated exception');\n      }\n\n      var id = obj.recurrenceId.toString(); // we don't sort or manage exceptions directly\n      // here the recurrence expander handles that.\n\n      this.exceptions[id] = obj; // index RANGE=THISANDFUTURE exceptions so we can\n      // look them up later in getOccurrenceDetails.\n\n      if (obj.modifiesFuture()) {\n        var item = [obj.recurrenceId.toUnixTime(), id]; // we keep them sorted so we can find the nearest\n        // value later on...\n\n        var idx = ICAL.helpers.binsearchInsert(this.rangeExceptions, item, compareRangeException);\n        this.rangeExceptions.splice(idx, 0, item);\n      }\n    },\n\n    /**\r\n     * Checks if this record is an exception and has the RANGE=THISANDFUTURE\r\n     * value.\r\n     *\r\n     * @return {Boolean}        True, when exception is within range\r\n     */\n    modifiesFuture: function modifiesFuture() {\n      if (!this.component.hasProperty('recurrence-id')) {\n        return false;\n      }\n\n      var range = this.component.getFirstProperty('recurrence-id').getParameter('range');\n      return range === this.THISANDFUTURE;\n    },\n\n    /**\r\n     * Finds the range exception nearest to the given date.\r\n     *\r\n     * @param {ICAL.Time} time usually an occurrence time of an event\r\n     * @return {?ICAL.Event} the related event/exception or null\r\n     */\n    findRangeException: function findRangeException(time) {\n      if (!this.rangeExceptions.length) {\n        return null;\n      }\n\n      var utc = time.toUnixTime();\n      var idx = ICAL.helpers.binsearchInsert(this.rangeExceptions, [utc], compareRangeException);\n      idx -= 1; // occurs before\n\n      if (idx < 0) {\n        return null;\n      }\n\n      var rangeItem = this.rangeExceptions[idx];\n      /* istanbul ignore next: sanity check only */\n\n      if (utc < rangeItem[0]) {\n        return null;\n      }\n\n      return rangeItem[1];\n    },\n\n    /**\r\n     * This object is returned by {@link ICAL.Event#getOccurrenceDetails getOccurrenceDetails}\r\n     *\r\n     * @typedef {Object} occurrenceDetails\r\n     * @memberof ICAL.Event\r\n     * @property {ICAL.Time} recurrenceId       The passed in recurrence id\r\n     * @property {ICAL.Event} item              The occurrence\r\n     * @property {ICAL.Time} startDate          The start of the occurrence\r\n     * @property {ICAL.Time} endDate            The end of the occurrence\r\n     */\n\n    /**\r\n     * Returns the occurrence details based on its start time.  If the\r\n     * occurrence has an exception will return the details for that exception.\r\n     *\r\n     * NOTE: this method is intend to be used in conjunction\r\n     *       with the {@link ICAL.Event#iterator iterator} method.\r\n     *\r\n     * @param {ICAL.Time} occurrence time occurrence\r\n     * @return {ICAL.Event.occurrenceDetails} Information about the occurrence\r\n     */\n    getOccurrenceDetails: function getOccurrenceDetails(occurrence) {\n      var id = occurrence.toString();\n      var utcId = occurrence.convertToZone(ICAL.Timezone.utcTimezone).toString();\n      var item;\n      var result = {\n        //XXX: Clone?\n        recurrenceId: occurrence\n      };\n\n      if (id in this.exceptions) {\n        item = result.item = this.exceptions[id];\n        result.startDate = item.startDate;\n        result.endDate = item.endDate;\n        result.item = item;\n      } else if (utcId in this.exceptions) {\n        item = this.exceptions[utcId];\n        result.startDate = item.startDate;\n        result.endDate = item.endDate;\n        result.item = item;\n      } else {\n        // range exceptions (RANGE=THISANDFUTURE) have a\n        // lower priority then direct exceptions but\n        // must be accounted for first. Their item is\n        // always the first exception with the range prop.\n        var rangeExceptionId = this.findRangeException(occurrence);\n        var end;\n\n        if (rangeExceptionId) {\n          var exception = this.exceptions[rangeExceptionId]; // range exception must modify standard time\n          // by the difference (if any) in start/end times.\n\n          result.item = exception;\n          var startDiff = this._rangeExceptionCache[rangeExceptionId];\n\n          if (!startDiff) {\n            var original = exception.recurrenceId.clone();\n            var newStart = exception.startDate.clone(); // zones must be same otherwise subtract may be incorrect.\n\n            original.zone = newStart.zone;\n            startDiff = newStart.subtractDate(original);\n            this._rangeExceptionCache[rangeExceptionId] = startDiff;\n          }\n\n          var start = occurrence.clone();\n          start.zone = exception.startDate.zone;\n          start.addDuration(startDiff);\n          end = start.clone();\n          end.addDuration(exception.duration);\n          result.startDate = start;\n          result.endDate = end;\n        } else {\n          // no range exception standard expansion\n          end = occurrence.clone();\n          end.addDuration(this.duration);\n          result.endDate = end;\n          result.startDate = occurrence;\n          result.item = this;\n        }\n      }\n\n      return result;\n    },\n\n    /**\r\n     * Builds a recur expansion instance for a specific point in time (defaults\r\n     * to startDate).\r\n     *\r\n     * @param {ICAL.Time} startTime     Starting point for expansion\r\n     * @return {ICAL.RecurExpansion}    Expansion object\r\n     */\n    iterator: function iterator(startTime) {\n      return new ICAL.RecurExpansion({\n        component: this.component,\n        dtstart: startTime || this.startDate\n      });\n    },\n\n    /**\r\n     * Checks if the event is recurring\r\n     *\r\n     * @return {Boolean}        True, if event is recurring\r\n     */\n    isRecurring: function isRecurring() {\n      var comp = this.component;\n      return comp.hasProperty('rrule') || comp.hasProperty('rdate');\n    },\n\n    /**\r\n     * Checks if the event describes a recurrence exception. See\r\n     * {@tutorial terminology} for details.\r\n     *\r\n     * @return {Boolean}    True, if the even describes a recurrence exception\r\n     */\n    isRecurrenceException: function isRecurrenceException() {\n      return this.component.hasProperty('recurrence-id');\n    },\n\n    /**\r\n     * Returns the types of recurrences this event may have.\r\n     *\r\n     * Returned as an object with the following possible keys:\r\n     *\r\n     *    - YEARLY\r\n     *    - MONTHLY\r\n     *    - WEEKLY\r\n     *    - DAILY\r\n     *    - MINUTELY\r\n     *    - SECONDLY\r\n     *\r\n     * @return {Object.<ICAL.Recur.frequencyValues, Boolean>}\r\n     *          Object of recurrence flags\r\n     */\n    getRecurrenceTypes: function getRecurrenceTypes() {\n      var rules = this.component.getAllProperties('rrule');\n      var i = 0;\n      var len = rules.length;\n      var result = Object.create(null);\n\n      for (; i < len; i++) {\n        var value = rules[i].getFirstValue();\n        result[value.freq] = true;\n      }\n\n      return result;\n    },\n\n    /**\r\n     * The uid of this event\r\n     * @type {String}\r\n     */\n    get uid() {\n      return this._firstProp('uid');\n    },\n\n    set uid(value) {\n      this._setProp('uid', value);\n    },\n\n    /**\r\n     * The start date\r\n     * @type {ICAL.Time}\r\n     */\n    get startDate() {\n      return this._firstProp('dtstart');\n    },\n\n    set startDate(value) {\n      this._setTime('dtstart', value);\n    },\n\n    /**\r\n     * The end date. This can be the result directly from the property, or the\r\n     * end date calculated from start date and duration. Setting the property\r\n     * will remove any duration properties.\r\n     * @type {ICAL.Time}\r\n     */\n    get endDate() {\n      var endDate = this._firstProp('dtend');\n\n      if (!endDate) {\n        var duration = this._firstProp('duration');\n\n        endDate = this.startDate.clone();\n\n        if (duration) {\n          endDate.addDuration(duration);\n        } else if (endDate.isDate) {\n          endDate.day += 1;\n        }\n      }\n\n      return endDate;\n    },\n\n    set endDate(value) {\n      if (this.component.hasProperty('duration')) {\n        this.component.removeProperty('duration');\n      }\n\n      this._setTime('dtend', value);\n    },\n\n    /**\r\n     * The duration. This can be the result directly from the property, or the\r\n     * duration calculated from start date and end date. Setting the property\r\n     * will remove any `dtend` properties.\r\n     * @type {ICAL.Duration}\r\n     */\n    get duration() {\n      var duration = this._firstProp('duration');\n\n      if (!duration) {\n        return this.endDate.subtractDateTz(this.startDate);\n      }\n\n      return duration;\n    },\n\n    set duration(value) {\n      if (this.component.hasProperty('dtend')) {\n        this.component.removeProperty('dtend');\n      }\n\n      this._setProp('duration', value);\n    },\n\n    /**\r\n     * The location of the event.\r\n     * @type {String}\r\n     */\n    get location() {\n      return this._firstProp('location');\n    },\n\n    set location(value) {\n      return this._setProp('location', value);\n    },\n\n    /**\r\n     * The attendees in the event\r\n     * @type {ICAL.Property[]}\r\n     * @readonly\r\n     */\n    get attendees() {\n      //XXX: This is way lame we should have a better\n      //     data structure for this later.\n      return this.component.getAllProperties('attendee');\n    },\n\n    /**\r\n     * The event summary\r\n     * @type {String}\r\n     */\n    get summary() {\n      return this._firstProp('summary');\n    },\n\n    set summary(value) {\n      this._setProp('summary', value);\n    },\n\n    /**\r\n     * The event description.\r\n     * @type {String}\r\n     */\n    get description() {\n      return this._firstProp('description');\n    },\n\n    set description(value) {\n      this._setProp('description', value);\n    },\n\n    /**\r\n     * The organizer value as an uri. In most cases this is a mailto: uri, but\r\n     * it can also be something else, like urn:uuid:...\r\n     * @type {String}\r\n     */\n    get organizer() {\n      return this._firstProp('organizer');\n    },\n\n    set organizer(value) {\n      this._setProp('organizer', value);\n    },\n\n    /**\r\n     * The sequence value for this event. Used for scheduling\r\n     * see {@tutorial terminology}.\r\n     * @type {Number}\r\n     */\n    get sequence() {\n      return this._firstProp('sequence');\n    },\n\n    set sequence(value) {\n      this._setProp('sequence', value);\n    },\n\n    /**\r\n     * The recurrence id for this event. See {@tutorial terminology} for details.\r\n     * @type {ICAL.Time}\r\n     */\n    get recurrenceId() {\n      return this._firstProp('recurrence-id');\n    },\n\n    set recurrenceId(value) {\n      this._setTime('recurrence-id', value);\n    },\n\n    /**\r\n     * Set/update a time property's value.\r\n     * This will also update the TZID of the property.\r\n     *\r\n     * TODO: this method handles the case where we are switching\r\n     * from a known timezone to an implied timezone (one without TZID).\r\n     * This does _not_ handle the case of moving between a known\r\n     *  (by TimezoneService) timezone to an unknown timezone...\r\n     *\r\n     * We will not add/remove/update the VTIMEZONE subcomponents\r\n     *  leading to invalid ICAL data...\r\n     * @private\r\n     * @param {String} propName     The property name\r\n     * @param {ICAL.Time} time      The time to set\r\n     */\n    _setTime: function _setTime(propName, time) {\n      var prop = this.component.getFirstProperty(propName);\n\n      if (!prop) {\n        prop = new ICAL.Property(propName);\n        this.component.addProperty(prop);\n      } // utc and local don't get a tzid\n\n\n      if (time.zone === ICAL.Timezone.localTimezone || time.zone === ICAL.Timezone.utcTimezone) {\n        // remove the tzid\n        prop.removeParameter('tzid');\n      } else {\n        prop.setParameter('tzid', time.zone.tzid);\n      }\n\n      prop.setValue(time);\n    },\n    _setProp: function _setProp(name, value) {\n      this.component.updatePropertyWithValue(name, value);\n    },\n    _firstProp: function _firstProp(name) {\n      return this.component.getFirstPropertyValue(name);\n    },\n\n    /**\r\n     * The string representation of this event.\r\n     * @return {String}\r\n     */\n    toString: function toString() {\n      return this.component.toString();\n    }\n  };\n\n  function compareRangeException(a, b) {\n    if (a[0] > b[0]) return 1;\n    if (b[0] > a[0]) return -1;\n    return 0;\n  }\n\n  return Event;\n}();\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\n\n/**\r\n * This symbol is further described later on\r\n * @ignore\r\n */\n\n\nICAL.ComponentParser = function () {\n  /**\r\n   * @classdesc\r\n   * The ComponentParser is used to process a String or jCal Object,\r\n   * firing callbacks for various found components, as well as completion.\r\n   *\r\n   * @example\r\n   * var options = {\r\n   *   // when false no events will be emitted for type\r\n   *   parseEvent: true,\r\n   *   parseTimezone: true\r\n   * };\r\n   *\r\n   * var parser = new ICAL.ComponentParser(options);\r\n   *\r\n   * parser.onevent(eventComponent) {\r\n   *   //...\r\n   * }\r\n   *\r\n   * // ontimezone, etc...\r\n   *\r\n   * parser.oncomplete = function() {\r\n   *\r\n   * };\r\n   *\r\n   * parser.process(stringOrComponent);\r\n   *\r\n   * @class\r\n   * @alias ICAL.ComponentParser\r\n   * @param {Object=} options        Component parser options\r\n   * @param {Boolean} options.parseEvent        Whether events should be parsed\r\n   * @param {Boolean} options.parseTimezeone    Whether timezones should be parsed\r\n   */\n  function ComponentParser(options) {\n    if (typeof options === 'undefined') {\n      options = {};\n    }\n\n    var key;\n\n    for (key in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(key)) {\n        this[key] = options[key];\n      }\n    }\n  }\n\n  ComponentParser.prototype = {\n    /**\r\n     * When true, parse events\r\n     *\r\n     * @type {Boolean}\r\n     */\n    parseEvent: true,\n\n    /**\r\n     * When true, parse timezones\r\n     *\r\n     * @type {Boolean}\r\n     */\n    parseTimezone: true,\n\n    /* SAX like events here for reference */\n\n    /**\r\n     * Fired when parsing is complete\r\n     * @callback\r\n     */\n    oncomplete:\n    /* istanbul ignore next */\n    function oncomplete() {},\n\n    /**\r\n     * Fired if an error occurs during parsing.\r\n     *\r\n     * @callback\r\n     * @param {Error} err details of error\r\n     */\n    onerror:\n    /* istanbul ignore next */\n    function onerror(err) {},\n\n    /**\r\n     * Fired when a top level component (VTIMEZONE) is found\r\n     *\r\n     * @callback\r\n     * @param {ICAL.Timezone} component     Timezone object\r\n     */\n    ontimezone:\n    /* istanbul ignore next */\n    function ontimezone(component) {},\n\n    /**\r\n     * Fired when a top level component (VEVENT) is found.\r\n     *\r\n     * @callback\r\n     * @param {ICAL.Event} component    Top level component\r\n     */\n    onevent:\n    /* istanbul ignore next */\n    function onevent(component) {},\n\n    /**\r\n     * Process a string or parse ical object.  This function itself will return\r\n     * nothing but will start the parsing process.\r\n     *\r\n     * Events must be registered prior to calling this method.\r\n     *\r\n     * @param {ICAL.Component|String|Object} ical      The component to process,\r\n     *        either in its final form, as a jCal Object, or string representation\r\n     */\n    process: function process(ical) {\n      //TODO: this is sync now in the future we will have a incremental parser.\n      if (typeof ical === 'string') {\n        ical = ICAL.parse(ical);\n      }\n\n      if (!(ical instanceof ICAL.Component)) {\n        ical = new ICAL.Component(ical);\n      }\n\n      var components = ical.getAllSubcomponents();\n      var i = 0;\n      var len = components.length;\n      var component;\n\n      for (; i < len; i++) {\n        component = components[i];\n\n        switch (component.name) {\n          case 'vtimezone':\n            if (this.parseTimezone) {\n              var tzid = component.getFirstPropertyValue('tzid');\n\n              if (tzid) {\n                this.ontimezone(new ICAL.Timezone({\n                  tzid: tzid,\n                  component: component\n                }));\n              }\n            }\n\n            break;\n\n          case 'vevent':\n            if (this.parseEvent) {\n              this.onevent(new ICAL.Event(component));\n            }\n\n            break;\n\n          default:\n            continue;\n        }\n      } //XXX: ideally we should do a \"nextTick\" here\n      //     so in all cases this is actually async.\n\n\n      this.oncomplete();\n    }\n  };\n  return ComponentParser;\n}();","map":{"version":3,"sources":["C:/Users/bdgcy/Axis/client/node_modules/ical.js/build/ical.js"],"names":["module","ICAL","exports","foldLength","newLineChar","helpers","updateTimezones","vcal","allsubs","properties","vtimezones","reqTzid","i","tzid","name","getAllSubcomponents","length","getFirstProperty","getFirstValue","concat","getAllProperties","getParameter","hasOwnProperty","removeSubcomponent","TimezoneService","has","addSubcomponent","get","component","isStrictlyNaN","number","isNaN","strictParseInt","string","result","parseInt","Error","formatClassType","data","type","undefined","unescapedIndexOf","buffer","search","pos","indexOf","binsearchInsert","list","seekVal","cmpfunc","low","high","mid","cmpval","Math","floor","dumpn","debug","console","consoleDumpn","input","log","geckoDumpn","dump","arguments","clone","aSrc","aDeep","Date","getTime","Array","isArray","arr","push","obj","Object","prototype","call","foldline","aLine","line","substr","pad2","pad","String","len","trunc","ceil","inherits","base","child","extra","F","extend","source","target","key","descr","getOwnPropertyDescriptor","defineProperty","design","FROM_ICAL_NEWLINE","TO_ICAL_NEWLINE","FROM_VCARD_NEWLINE","TO_VCARD_NEWLINE","createTextType","fromNewline","toNewline","matches","fromICAL","aValue","structuredEscape","replaceNewline","toICAL","regEx","RegExp","replace","str","DEFAULT_TYPE_TEXT","defaultType","DEFAULT_TYPE_TEXT_MULTI","multiValue","DEFAULT_TYPE_TEXT_STRUCTURED","structuredValue","DEFAULT_TYPE_INTEGER","DEFAULT_TYPE_DATETIME_DATE","allowedTypes","DEFAULT_TYPE_DATETIME","DEFAULT_TYPE_URI","DEFAULT_TYPE_UTCOFFSET","DEFAULT_TYPE_RECUR","DEFAULT_TYPE_DATE_ANDOR_TIME","replaceNewlineReplace","value","newline","commonProperties","commonValues","values","float","parsed","parseFloat","integer","decorate","UtcOffset","fromString","undecorate","toString","icalParams","allowXName","allowIanaToken","valueType","multiValueSeparateDQuote","icalValues","text","uri","aString","Binary","aBinary","aProp","strict","Time","fromDateString","date","fromDateTimeString","duration","Duration","period","parts","split","isValueString","join","Period","fromJSON","toJSON","recur","Recur","_stringToData","k","val","numericDayToIcalDay","toUpperCase","fromData","aRecur","time","icalProperties","detectType","vcardValues","VCardTime","fromDateAndOrTimeString","splitzone","_splitZone","zone","isFromIcal","lastChar","signChar","sign","timestamp","vcardParams","vcardProperties","vcard3Values","binary","vcard","vcard3Params","vcard3Properties","fn","n","nickname","photo","bday","adr","label","tel","email","mailer","tz","geo","title","role","logo","agent","org","note","prodid","rev","sound","class","icalSet","param","property","vcardSet","vcard3Set","defaultSet","components","vcard3","vevent","vtodo","vjournal","valarm","vtimezone","daylight","standard","icalendar","getDesignSet","componentName","isInDesign","stringify","LINE_ENDING","DEFAULT_VALUE_TYPE","jCal","designSet","props","propIdx","propLen","designSetName","comps","compIdx","compLen","noFold","jsName","params","paramName","map","_rfc6868Unescape","propertyValue","propDetails","isDefault","slice","delim","innerMulti","x","RFC6868_REPLACE_MAP","parse","CHAR","MULTIVALUE_DELIMITER","VALUE_DELIMITER","PARAM_DELIMITER","PARAM_NAME_DELIMITER","DEFAULT_PARAM_TYPE","ParserError","message","e","stack","shift","parser","state","root","_eachLine","err","_handleContentLine","valuePos","paramPos","lastParamIndex","lastValuePos","parsedParams","substring","toLowerCase","_parseParameters","newComponent","pop","propertyDetails","_parseMultiValue","_parseValue","start","lastParam","lcname","mvdelim","_rfc6868Escape","nextChar","extendedValue","nextPos","propValuePos","delimiter","lastPos","callback","firstChar","newlineOffset","trim","Component","PROPERTY_INDEX","COMPONENT_INDEX","NAME_INDEX","parent","_hydratedPropertyCount","_hydratedComponentCount","_designSet","parentDesign","_hydrateComponent","index","_components","comp","_hydrateProperty","_properties","prop","Property","getFirstSubcomponent","jCalLen","hasProperty","getFirstPropertyValue","_removeObjectByIndex","jCalIndex","cache","splice","_removeObject","nameOrObject","objects","cached","_removeAllObjects","idx","nameOrComp","removed","removeAllSubcomponents","addProperty","TypeError","removeProperty","addPropertyWithValue","setValue","updatePropertyWithValue","nameOrProp","removeAllProperties","PROP_INDEX","TYPE_INDEX","VALUE_INDEX","_parent","getDefaultType","_updateType","p","designSetChanged","designType","isDecorated","isMultiValue","isStructuredValue","_hydrateValue","_values","_decorate","_undecorate","_setDecoratedValue","getFirstParameter","parameters","setParameter","removeParameter","details","resetType","removeAllValues","getValues","setValues","icaltype","toICALString","aData","hours","minutes","factor","fromSeconds","toSeconds","_normalize","aSeconds","secs","abs","compare","icaltime_compare","other","a","b","options","instance","decodeValue","_b64_decode","setEncodedValue","_b64_encode","base64_encode","b64","o1","o2","o3","h1","h2","h3","h4","bits","ac","enc","tmp_arr","charCodeAt","charAt","r","base64_decode","dec","fromCharCode","icalperiod","wrappedJSObject","end","icalclass","getDuration","subtractDate","getEnd","addDuration","aLenient","fromDateOrDateTimeString","DURATION_LETTERS","icalduration","weeks","days","seconds","isNegative","propsToCopy","reset","aOther","thisSeconds","otherSeconds","normalize","icalduration_from_seconds","parseDurationChunk","letter","object","num","icalduration_from_string","aStr","dict","create","chunks","numeric","icalduration_from_data","OPTIONS","Timezone","icaltimezone","location","tznames","latitude","longitude","expandedUntilYear","changes","utcOffset","tt","utcTimezone","localTimezone","_ensureCoverage","year","tt_change","month","day","hour","minute","second","change_num","_findNearbyChange","change_num_to_use","step","change","prevUtcOffset","adjust_change","cmp","_compare_change_fn","zone_change","utcOffset_change","tmp_change","prev_zone_change","want_daylight","is_daylight","icaltimezone_find_nearby_change","aYear","_minimumExpansionYear","today","now","changesEndYear","EXTRA_COVERAGE","MAX_YEAR","subcomps","_expandComponent","sort","aComponent","dtstart","convert_tzoffset","offset","init_changes","changebase","rdatekey","rdate","isDate","rrule","until","adjust","iterator","occ","next","icaltimezone_compare_change_fn","convert_time","icaltimezone_convert_time","from_zone","to_zone","icaltimezone_fromData","icaltimezone_adjust_change","zones","count","keys","utc","Z","UTC","GMT","register","timezone","remove","icaltime","_time","_dowCache","_wnCache","_cachedUnixTime","_pendingNormalization","icaltime_reset","epochTime","resetTo","icaltime_resetTo","fromJSDate","icaltime_fromJSDate","aDate","useUTC","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","aZone","dayOfWeek","icaltime_dayOfWeek","aWeekStart","firstDow","SUNDAY","dowCacheKey","q","m","Y","h","dayOfYear","is_leap","isLeapYear","diypm","daysInYearPassedMonth","startOfWeek","endOfWeek","startOfMonth","endOfMonth","daysInMonth","startOfYear","endOfYear","startDoyWeek","aFirstDayOfWeek","delta","getDominicalLetter","nthWeekDay","icaltime_nthWeekDay","aDayOfWeek","aPos","weekday","otherDay","startDow","endDow","isNthWeekDay","dow","weekNumber","wnCacheKey","week1","dt","isoyear","weekOneStarts","daysBetween","answer","icaltime_add","aDuration","mult","icaltime_subtract","unixTime","toUnixTime","subtractDateTz","icaltime_subtract_abs","compareDateOnlyTz","icaltime_compareDateOnlyTz","attr","_cmp_attr","convertToZone","rc","copy","zone_equals","utc_offset","toJSDate","icaltime_normalize","icaltime_adjust","aExtraDays","aExtraHours","aExtraMinutes","aExtraSeconds","aTime","minutesOverflow","hoursOverflow","daysOverflow","yearsOverflow","fromUnixTime","epoch","ms","setupNormalizeAttributes","defineAttr","getTimeAttr","set","setTimeAttr","icaltime_daysInMonth","_daysInMonth","fromDayOfYear","icaltime_fromDayOfYear","aDayOfYear","doy","auto_normalize","fromStringv2","aProperty","t","icaltime_now","wkst","DEFAULT_WEEK_START","THURSDAY","yr","LTRS","dom","isLeap","MONDAY","TUESDAY","WEDNESDAY","FRIDAY","SATURDAY","apply","p2","y","d","mm","s","hasYear","hasMonth","hasDay","hasHour","hasMinute","hasSecond","datepart","timepart","aIcalType","part","v","tmz","tm","stoi","dtlen","tmlen","hasDashDate","hasDashTime","o","DOW_MAP","SU","MO","TU","WE","TH","FR","SA","REVERSE_DOW_MAP","COPY_PARTS","icalrecur","interval","freq","aStart","RecurIterator","rule","isFinite","isfinite","isByCount","isbycount","addComponent","addPart","aType","ucname","setComponent","aValues","getComponent","getNextOccurrence","aStartTime","aRecurrenceId","iter","cdt","uckey","partDesign","optionDesign","INTERVAL","icalDayToNumericDay","res","kparts","icalrecur_toString","parseNumericValue","min","max","toNumericDay","toIcalDay","VALID_DAY_NAMES","VALID_BYDAY_PART","ALLOWED_FREQ","FREQ","fmtIcal","COUNT","UNTIL","WKST","test","BYSECOND","bind","BYMINUTE","BYHOUR","BYDAY","BYMONTHDAY","BYYEARDAY","BYWEEKNO","BYMONTH","BYSETPOS","partArr","partArrIdx","partArrLen","icalrecur_iterator","completed","last","occurrence_number","by_indices","initialized","by_data","days_index","init","icalrecur_iterator_init","sort_byday_rules","setup_defaults","bydayParts","ruleDayOfWeek","wkdy","dayName","expand_year_days","increment_year","_nextByYearDay","has_by_data","tempLast","initLast","dayOfMonth","increment_month","_byDayAndMonthDay","icalrecur_iterator_next","before","valid","next_second","next_minute","next_hour","next_day","next_week","next_month","next_year","check_contracting_rules","next_generic","increment_second","inc","increment_generic","increment_minute","increment_hour","has_by_day","this_freq","increment_monthday","end_of_data","next_weekday_by_week","week_no","normalizeByMonthDayRules","rules","newRules","ruleIdx","isInit","byMonthDay","byDay","dateIdx","dateLen","dayLen","dataIsValid","self","lastDay","initMonth","nextMonth","monthsCounter","dayIdx","data_valid","setpos","setpos_total","last_day","is_day_in_byday","check_set_position","coded_day","match","aRuleType","aInterval","aDateAttr","aFollowingAttr","aPreviousIncr","has_by_rule","dta","years","aFactor","aNextIncrement","nextunit","validWeeks","monthIdx","first_week","last_week","weekIdx","weekno","partCount","t1","monthkey","t2","monthdaykey","t3","day_","month_","expand_by_day","first_dow","doy_offset","last_dow","set_pos_counter","by_month_day","spIndex","daycodedkey","month_day","first_matching_day","last_matching_day","expandedDays","daykey","days_list","tmp","start_dow","end_dow","end_year_day","tmp_start_doy","first","this_dow","icalrecur_sort_byday_rules","aRules","j","one","two","check_contract_restriction","indexMapValue","_indexMap","ruleMapValue","_expandMap","pass","CONTRACT","ruleType","bydatakey","weekNo","req","deftime","UNKNOWN","EXPAND","ILLEGAL","RecurExpansion","formatTime","item","compareTime","isRecurringComponent","ruleDates","exDates","complete","ruleIterators","ruleDateInc","exDateInc","exDate","ruleDate","_init","ruleOfDay","maxTries","currentTry","_nextRecurrenceIter","_nextRuleDay","_nextExDay","_extractDates","propertyName","handleProp","forEach","iters","iterTime","iterIdx","chosenIter","Event","_rangeExceptionCache","exceptions","rangeExceptions","strictExceptions","relateException","isRecurrenceException","event","THISANDFUTURE","uid","id","recurrenceId","modifiesFuture","compareRangeException","range","findRangeException","rangeItem","getOccurrenceDetails","occurrence","utcId","startDate","endDate","rangeExceptionId","exception","startDiff","original","newStart","startTime","isRecurring","getRecurrenceTypes","_firstProp","_setProp","_setTime","attendees","summary","description","organizer","sequence","propName","ComponentParser","parseEvent","parseTimezone","oncomplete","onerror","ontimezone","onevent","process","ical"],"mappings":"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","sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\r\n\r\n\r\n/* istanbul ignore next */\r\n/* jshint ignore:start */\r\nif (typeof module === 'object') {\r\n  // CommonJS, where exports may be different each time.\r\n  ICAL = module.exports;\r\n} else if (typeof ICAL !== 'object') {/* istanbul ignore next */\r\n  /** @ignore */\r\n  this.ICAL = {};\r\n}\r\n/* jshint ignore:end */\r\n\r\n\r\n/**\r\n * The number of characters before iCalendar line folding should occur\r\n * @type {Number}\r\n * @default 75\r\n */\r\nICAL.foldLength = 75;\r\n\r\n\r\n/**\r\n * The character(s) to be used for a newline. The default value is provided by\r\n * rfc5545.\r\n * @type {String}\r\n * @default \"\\r\\n\"\r\n */\r\nICAL.newLineChar = '\\r\\n';\r\n\r\n\r\n/**\r\n * Helper functions used in various places within ical.js\r\n * @namespace\r\n */\r\nICAL.helpers = {\r\n  /**\r\n   * Compiles a list of all referenced TZIDs in all subcomponents and\r\n   * removes any extra VTIMEZONE subcomponents. In addition, if any TZIDs\r\n   * are referenced by a component, but a VTIMEZONE does not exist,\r\n   * an attempt will be made to generate a VTIMEZONE using ICAL.TimezoneService.\r\n   *\r\n   * @param {ICAL.Component} vcal     The top-level VCALENDAR component.\r\n   * @return {ICAL.Component}         The ICAL.Component that was passed in.\r\n   */\r\n  updateTimezones: function(vcal) {\r\n    var allsubs, properties, vtimezones, reqTzid, i, tzid;\r\n\r\n    if (!vcal || vcal.name !== \"vcalendar\") {\r\n      //not a top-level vcalendar component\r\n      return vcal;\r\n    }\r\n\r\n    //Store vtimezone subcomponents in an object reference by tzid.\r\n    //Store properties from everything else in another array\r\n    allsubs = vcal.getAllSubcomponents();\r\n    properties = [];\r\n    vtimezones = {};\r\n    for (i = 0; i < allsubs.length; i++) {\r\n      if (allsubs[i].name === \"vtimezone\") {\r\n        tzid = allsubs[i].getFirstProperty(\"tzid\").getFirstValue();\r\n        vtimezones[tzid] = allsubs[i];\r\n      } else {\r\n        properties = properties.concat(allsubs[i].getAllProperties());\r\n      }\r\n    }\r\n\r\n    //create an object with one entry for each required tz\r\n    reqTzid = {};\r\n    for (i = 0; i < properties.length; i++) {\r\n      if ((tzid = properties[i].getParameter(\"tzid\"))) {\r\n        reqTzid[tzid] = true;\r\n      }\r\n    }\r\n\r\n    //delete any vtimezones that are not on the reqTzid list.\r\n    for (i in vtimezones) {\r\n      if (vtimezones.hasOwnProperty(i) && !reqTzid[i]) {\r\n        vcal.removeSubcomponent(vtimezones[i]);\r\n      }\r\n    }\r\n\r\n    //create any missing, but registered timezones\r\n    for (i in reqTzid) {\r\n      if (\r\n        reqTzid.hasOwnProperty(i) &&\r\n        !vtimezones[i] &&\r\n        ICAL.TimezoneService.has(i)\r\n      ) {\r\n        vcal.addSubcomponent(ICAL.TimezoneService.get(i).component);\r\n      }\r\n    }\r\n\r\n    return vcal;\r\n  },\r\n\r\n  /**\r\n   * Checks if the given type is of the number type and also NaN.\r\n   *\r\n   * @param {Number} number     The number to check\r\n   * @return {Boolean}          True, if the number is strictly NaN\r\n   */\r\n  isStrictlyNaN: function(number) {\r\n    return typeof(number) === 'number' && isNaN(number);\r\n  },\r\n\r\n  /**\r\n   * Parses a string value that is expected to be an integer, when the valid is\r\n   * not an integer throws a decoration error.\r\n   *\r\n   * @param {String} string     Raw string input\r\n   * @return {Number}           Parsed integer\r\n   */\r\n  strictParseInt: function(string) {\r\n    var result = parseInt(string, 10);\r\n\r\n    if (ICAL.helpers.isStrictlyNaN(result)) {\r\n      throw new Error(\r\n        'Could not extract integer from \"' + string + '\"'\r\n      );\r\n    }\r\n\r\n    return result;\r\n  },\r\n\r\n  /**\r\n   * Creates or returns a class instance of a given type with the initialization\r\n   * data if the data is not already an instance of the given type.\r\n   *\r\n   * @example\r\n   * var time = new ICAL.Time(...);\r\n   * var result = ICAL.helpers.formatClassType(time, ICAL.Time);\r\n   *\r\n   * (result instanceof ICAL.Time)\r\n   * // => true\r\n   *\r\n   * result = ICAL.helpers.formatClassType({}, ICAL.Time);\r\n   * (result isntanceof ICAL.Time)\r\n   * // => true\r\n   *\r\n   *\r\n   * @param {Object} data       object initialization data\r\n   * @param {Object} type       object type (like ICAL.Time)\r\n   * @return {?}                An instance of the found type.\r\n   */\r\n  formatClassType: function formatClassType(data, type) {\r\n    if (typeof(data) === 'undefined') {\r\n      return undefined;\r\n    }\r\n\r\n    if (data instanceof type) {\r\n      return data;\r\n    }\r\n    return new type(data);\r\n  },\r\n\r\n  /**\r\n   * Identical to indexOf but will only match values when they are not preceded\r\n   * by a backslash character.\r\n   *\r\n   * @param {String} buffer         String to search\r\n   * @param {String} search         Value to look for\r\n   * @param {Number} pos            Start position\r\n   * @return {Number}               The position, or -1 if not found\r\n   */\r\n  unescapedIndexOf: function(buffer, search, pos) {\r\n    while ((pos = buffer.indexOf(search, pos)) !== -1) {\r\n      if (pos > 0 && buffer[pos - 1] === '\\\\') {\r\n        pos += 1;\r\n      } else {\r\n        return pos;\r\n      }\r\n    }\r\n    return -1;\r\n  },\r\n\r\n  /**\r\n   * Find the index for insertion using binary search.\r\n   *\r\n   * @param {Array} list            The list to search\r\n   * @param {?} seekVal             The value to insert\r\n   * @param {function(?,?)} cmpfunc The comparison func, that can\r\n   *                                  compare two seekVals\r\n   * @return {Number}               The insert position\r\n   */\r\n  binsearchInsert: function(list, seekVal, cmpfunc) {\r\n    if (!list.length)\r\n      return 0;\r\n\r\n    var low = 0, high = list.length - 1,\r\n        mid, cmpval;\r\n\r\n    while (low <= high) {\r\n      mid = low + Math.floor((high - low) / 2);\r\n      cmpval = cmpfunc(seekVal, list[mid]);\r\n\r\n      if (cmpval < 0)\r\n        high = mid - 1;\r\n      else if (cmpval > 0)\r\n        low = mid + 1;\r\n      else\r\n        break;\r\n    }\r\n\r\n    if (cmpval < 0)\r\n      return mid; // insertion is displacing, so use mid outright.\r\n    else if (cmpval > 0)\r\n      return mid + 1;\r\n    else\r\n      return mid;\r\n  },\r\n\r\n  /**\r\n   * Convenience function for debug output\r\n   * @private\r\n   */\r\n  dumpn: /* istanbul ignore next */ function() {\r\n    if (!ICAL.debug) {\r\n      return;\r\n    }\r\n\r\n    if (typeof (console) !== 'undefined' && 'log' in console) {\r\n      ICAL.helpers.dumpn = function consoleDumpn(input) {\r\n        console.log(input);\r\n      };\r\n    } else {\r\n      ICAL.helpers.dumpn = function geckoDumpn(input) {\r\n        dump(input + '\\n');\r\n      };\r\n    }\r\n\r\n    ICAL.helpers.dumpn(arguments[0]);\r\n  },\r\n\r\n  /**\r\n   * Clone the passed object or primitive. By default a shallow clone will be\r\n   * executed.\r\n   *\r\n   * @param {*} aSrc            The thing to clone\r\n   * @param {Boolean=} aDeep    If true, a deep clone will be performed\r\n   * @return {*}                The copy of the thing\r\n   */\r\n  clone: function(aSrc, aDeep) {\r\n    if (!aSrc || typeof aSrc != \"object\") {\r\n      return aSrc;\r\n    } else if (aSrc instanceof Date) {\r\n      return new Date(aSrc.getTime());\r\n    } else if (\"clone\" in aSrc) {\r\n      return aSrc.clone();\r\n    } else if (Array.isArray(aSrc)) {\r\n      var arr = [];\r\n      for (var i = 0; i < aSrc.length; i++) {\r\n        arr.push(aDeep ? ICAL.helpers.clone(aSrc[i], true) : aSrc[i]);\r\n      }\r\n      return arr;\r\n    } else {\r\n      var obj = {};\r\n      for (var name in aSrc) {\r\n        // uses prototype method to allow use of Object.create(null);\r\n        /* istanbul ignore else */\r\n        if (Object.prototype.hasOwnProperty.call(aSrc, name)) {\r\n          if (aDeep) {\r\n            obj[name] = ICAL.helpers.clone(aSrc[name], true);\r\n          } else {\r\n            obj[name] = aSrc[name];\r\n          }\r\n        }\r\n      }\r\n      return obj;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Performs iCalendar line folding. A line ending character is inserted and\r\n   * the next line begins with a whitespace.\r\n   *\r\n   * @example\r\n   * SUMMARY:This line will be fold\r\n   *  ed right in the middle of a word.\r\n   *\r\n   * @param {String} aLine      The line to fold\r\n   * @return {String}           The folded line\r\n   */\r\n  foldline: function foldline(aLine) {\r\n    var result = \"\";\r\n    var line = aLine || \"\";\r\n\r\n    while (line.length) {\r\n      result += ICAL.newLineChar + \" \" + line.substr(0, ICAL.foldLength);\r\n      line = line.substr(ICAL.foldLength);\r\n    }\r\n    return result.substr(ICAL.newLineChar.length + 1);\r\n  },\r\n\r\n  /**\r\n   * Pads the given string or number with zeros so it will have at least two\r\n   * characters.\r\n   *\r\n   * @param {String|Number} data    The string or number to pad\r\n   * @return {String}               The number padded as a string\r\n   */\r\n  pad2: function pad(data) {\r\n    if (typeof(data) !== 'string') {\r\n      // handle fractions.\r\n      if (typeof(data) === 'number') {\r\n        data = parseInt(data);\r\n      }\r\n      data = String(data);\r\n    }\r\n\r\n    var len = data.length;\r\n\r\n    switch (len) {\r\n      case 0:\r\n        return '00';\r\n      case 1:\r\n        return '0' + data;\r\n      default:\r\n        return data;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Truncates the given number, correctly handling negative numbers.\r\n   *\r\n   * @param {Number} number     The number to truncate\r\n   * @return {Number}           The truncated number\r\n   */\r\n  trunc: function trunc(number) {\r\n    return (number < 0 ? Math.ceil(number) : Math.floor(number));\r\n  },\r\n\r\n  /**\r\n   * Poor-man's cross-browser inheritance for JavaScript. Doesn't support all\r\n   * the features, but enough for our usage.\r\n   *\r\n   * @param {Function} base     The base class constructor function.\r\n   * @param {Function} child    The child class constructor function.\r\n   * @param {Object} extra      Extends the prototype with extra properties\r\n   *                              and methods\r\n   */\r\n  inherits: function(base, child, extra) {\r\n    function F() {}\r\n    F.prototype = base.prototype;\r\n    child.prototype = new F();\r\n\r\n    if (extra) {\r\n      ICAL.helpers.extend(extra, child.prototype);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Poor-man's cross-browser object extension. Doesn't support all the\r\n   * features, but enough for our usage. Note that the target's properties are\r\n   * not overwritten with the source properties.\r\n   *\r\n   * @example\r\n   * var child = ICAL.helpers.extend(parent, {\r\n   *   \"bar\": 123\r\n   * });\r\n   *\r\n   * @param {Object} source     The object to extend\r\n   * @param {Object} target     The object to extend with\r\n   * @return {Object}           Returns the target.\r\n   */\r\n  extend: function(source, target) {\r\n    for (var key in source) {\r\n      var descr = Object.getOwnPropertyDescriptor(source, key);\r\n      if (descr && !Object.getOwnPropertyDescriptor(target, key)) {\r\n        Object.defineProperty(target, key, descr);\r\n      }\r\n    }\r\n    return target;\r\n  }\r\n};\r\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\r\n\r\n/** @namespace ICAL */\r\n\r\n\r\n/**\r\n * This symbol is further described later on\r\n * @ignore\r\n */\r\nICAL.design = (function() {\r\n  'use strict';\r\n\r\n  var FROM_ICAL_NEWLINE = /\\\\\\\\|\\\\;|\\\\,|\\\\[Nn]/g;\r\n  var TO_ICAL_NEWLINE = /\\\\|;|,|\\n/g;\r\n  var FROM_VCARD_NEWLINE = /\\\\\\\\|\\\\,|\\\\[Nn]/g;\r\n  var TO_VCARD_NEWLINE = /\\\\|,|\\n/g;\r\n\r\n  function createTextType(fromNewline, toNewline) {\r\n    var result = {\r\n      matches: /.*/,\r\n\r\n      fromICAL: function(aValue, structuredEscape) {\r\n        return replaceNewline(aValue, fromNewline, structuredEscape);\r\n      },\r\n\r\n      toICAL: function(aValue, structuredEscape) {\r\n        var regEx = toNewline;\r\n        if (structuredEscape)\r\n          regEx = new RegExp(regEx.source + '|' + structuredEscape);\r\n        return aValue.replace(regEx, function(str) {\r\n          switch (str) {\r\n          case \"\\\\\":\r\n            return \"\\\\\\\\\";\r\n          case \";\":\r\n            return \"\\\\;\";\r\n          case \",\":\r\n            return \"\\\\,\";\r\n          case \"\\n\":\r\n            return \"\\\\n\";\r\n          /* istanbul ignore next */\r\n          default:\r\n            return str;\r\n          }\r\n        });\r\n      }\r\n    };\r\n    return result;\r\n  }\r\n\r\n  // default types used multiple times\r\n  var DEFAULT_TYPE_TEXT = { defaultType: \"text\" };\r\n  var DEFAULT_TYPE_TEXT_MULTI = { defaultType: \"text\", multiValue: \",\" };\r\n  var DEFAULT_TYPE_TEXT_STRUCTURED = { defaultType: \"text\", structuredValue: \";\" };\r\n  var DEFAULT_TYPE_INTEGER = { defaultType: \"integer\" };\r\n  var DEFAULT_TYPE_DATETIME_DATE = { defaultType: \"date-time\", allowedTypes: [\"date-time\", \"date\"] };\r\n  var DEFAULT_TYPE_DATETIME = { defaultType: \"date-time\" };\r\n  var DEFAULT_TYPE_URI = { defaultType: \"uri\" };\r\n  var DEFAULT_TYPE_UTCOFFSET = { defaultType: \"utc-offset\" };\r\n  var DEFAULT_TYPE_RECUR = { defaultType: \"recur\" };\r\n  var DEFAULT_TYPE_DATE_ANDOR_TIME = { defaultType: \"date-and-or-time\", allowedTypes: [\"date-time\", \"date\", \"text\"] };\r\n\r\n  function replaceNewlineReplace(string) {\r\n    switch (string) {\r\n      case \"\\\\\\\\\":\r\n        return \"\\\\\";\r\n      case \"\\\\;\":\r\n        return \";\";\r\n      case \"\\\\,\":\r\n        return \",\";\r\n      case \"\\\\n\":\r\n      case \"\\\\N\":\r\n        return \"\\n\";\r\n      /* istanbul ignore next */\r\n      default:\r\n        return string;\r\n    }\r\n  }\r\n\r\n  function replaceNewline(value, newline, structuredEscape) {\r\n    // avoid regex when possible.\r\n    if (value.indexOf('\\\\') === -1) {\r\n      return value;\r\n    }\r\n    if (structuredEscape)\r\n      newline = new RegExp(newline.source + '|\\\\\\\\' + structuredEscape);\r\n    return value.replace(newline, replaceNewlineReplace);\r\n  }\r\n\r\n  var commonProperties = {\r\n    \"categories\": DEFAULT_TYPE_TEXT_MULTI,\r\n    \"url\": DEFAULT_TYPE_URI,\r\n    \"version\": DEFAULT_TYPE_TEXT,\r\n    \"uid\": DEFAULT_TYPE_TEXT\r\n  };\r\n\r\n  var commonValues = {\r\n    \"boolean\": {\r\n      values: [\"TRUE\", \"FALSE\"],\r\n\r\n      fromICAL: function(aValue) {\r\n        switch (aValue) {\r\n          case 'TRUE':\r\n            return true;\r\n          case 'FALSE':\r\n            return false;\r\n          default:\r\n            //TODO: parser warning\r\n            return false;\r\n        }\r\n      },\r\n\r\n      toICAL: function(aValue) {\r\n        if (aValue) {\r\n          return 'TRUE';\r\n        }\r\n        return 'FALSE';\r\n      }\r\n\r\n    },\r\n    float: {\r\n      matches: /^[+-]?\\d+\\.\\d+$/,\r\n\r\n      fromICAL: function(aValue) {\r\n        var parsed = parseFloat(aValue);\r\n        if (ICAL.helpers.isStrictlyNaN(parsed)) {\r\n          // TODO: parser warning\r\n          return 0.0;\r\n        }\r\n        return parsed;\r\n      },\r\n\r\n      toICAL: function(aValue) {\r\n        return String(aValue);\r\n      }\r\n    },\r\n    integer: {\r\n      fromICAL: function(aValue) {\r\n        var parsed = parseInt(aValue);\r\n        if (ICAL.helpers.isStrictlyNaN(parsed)) {\r\n          return 0;\r\n        }\r\n        return parsed;\r\n      },\r\n\r\n      toICAL: function(aValue) {\r\n        return String(aValue);\r\n      }\r\n    },\r\n    \"utc-offset\": {\r\n      toICAL: function(aValue) {\r\n        if (aValue.length < 7) {\r\n          // no seconds\r\n          // -0500\r\n          return aValue.substr(0, 3) +\r\n                 aValue.substr(4, 2);\r\n        } else {\r\n          // seconds\r\n          // -050000\r\n          return aValue.substr(0, 3) +\r\n                 aValue.substr(4, 2) +\r\n                 aValue.substr(7, 2);\r\n        }\r\n      },\r\n\r\n      fromICAL: function(aValue) {\r\n        if (aValue.length < 6) {\r\n          // no seconds\r\n          // -05:00\r\n          return aValue.substr(0, 3) + ':' +\r\n                 aValue.substr(3, 2);\r\n        } else {\r\n          // seconds\r\n          // -05:00:00\r\n          return aValue.substr(0, 3) + ':' +\r\n                 aValue.substr(3, 2) + ':' +\r\n                 aValue.substr(5, 2);\r\n        }\r\n      },\r\n\r\n      decorate: function(aValue) {\r\n        return ICAL.UtcOffset.fromString(aValue);\r\n      },\r\n\r\n      undecorate: function(aValue) {\r\n        return aValue.toString();\r\n      }\r\n    }\r\n  };\r\n\r\n  var icalParams = {\r\n    // Although the syntax is DQUOTE uri DQUOTE, I don't think we should\r\n    // enfoce anything aside from it being a valid content line.\r\n    //\r\n    // At least some params require - if multi values are used - DQUOTEs\r\n    // for each of its values - e.g. delegated-from=\"uri1\",\"uri2\"\r\n    // To indicate this, I introduced the new k/v pair\r\n    // multiValueSeparateDQuote: true\r\n    //\r\n    // \"ALTREP\": { ... },\r\n\r\n    // CN just wants a param-value\r\n    // \"CN\": { ... }\r\n\r\n    \"cutype\": {\r\n      values: [\"INDIVIDUAL\", \"GROUP\", \"RESOURCE\", \"ROOM\", \"UNKNOWN\"],\r\n      allowXName: true,\r\n      allowIanaToken: true\r\n    },\r\n\r\n    \"delegated-from\": {\r\n      valueType: \"cal-address\",\r\n      multiValue: \",\",\r\n      multiValueSeparateDQuote: true\r\n    },\r\n    \"delegated-to\": {\r\n      valueType: \"cal-address\",\r\n      multiValue: \",\",\r\n      multiValueSeparateDQuote: true\r\n    },\r\n    // \"DIR\": { ... }, // See ALTREP\r\n    \"encoding\": {\r\n      values: [\"8BIT\", \"BASE64\"]\r\n    },\r\n    // \"FMTTYPE\": { ... }, // See ALTREP\r\n    \"fbtype\": {\r\n      values: [\"FREE\", \"BUSY\", \"BUSY-UNAVAILABLE\", \"BUSY-TENTATIVE\"],\r\n      allowXName: true,\r\n      allowIanaToken: true\r\n    },\r\n    // \"LANGUAGE\": { ... }, // See ALTREP\r\n    \"member\": {\r\n      valueType: \"cal-address\",\r\n      multiValue: \",\",\r\n      multiValueSeparateDQuote: true\r\n    },\r\n    \"partstat\": {\r\n      // TODO These values are actually different per-component\r\n      values: [\"NEEDS-ACTION\", \"ACCEPTED\", \"DECLINED\", \"TENTATIVE\",\r\n               \"DELEGATED\", \"COMPLETED\", \"IN-PROCESS\"],\r\n      allowXName: true,\r\n      allowIanaToken: true\r\n    },\r\n    \"range\": {\r\n      values: [\"THISLANDFUTURE\"]\r\n    },\r\n    \"related\": {\r\n      values: [\"START\", \"END\"]\r\n    },\r\n    \"reltype\": {\r\n      values: [\"PARENT\", \"CHILD\", \"SIBLING\"],\r\n      allowXName: true,\r\n      allowIanaToken: true\r\n    },\r\n    \"role\": {\r\n      values: [\"REQ-PARTICIPANT\", \"CHAIR\",\r\n               \"OPT-PARTICIPANT\", \"NON-PARTICIPANT\"],\r\n      allowXName: true,\r\n      allowIanaToken: true\r\n    },\r\n    \"rsvp\": {\r\n      values: [\"TRUE\", \"FALSE\"]\r\n    },\r\n    \"sent-by\": {\r\n      valueType: \"cal-address\"\r\n    },\r\n    \"tzid\": {\r\n      matches: /^\\//\r\n    },\r\n    \"value\": {\r\n      // since the value here is a 'type' lowercase is used.\r\n      values: [\"binary\", \"boolean\", \"cal-address\", \"date\", \"date-time\",\r\n               \"duration\", \"float\", \"integer\", \"period\", \"recur\", \"text\",\r\n               \"time\", \"uri\", \"utc-offset\"],\r\n      allowXName: true,\r\n      allowIanaToken: true\r\n    }\r\n  };\r\n\r\n  // When adding a value here, be sure to add it to the parameter types!\r\n  var icalValues = ICAL.helpers.extend(commonValues, {\r\n    text: createTextType(FROM_ICAL_NEWLINE, TO_ICAL_NEWLINE),\r\n\r\n    uri: {\r\n      // TODO\r\n      /* ... */\r\n    },\r\n\r\n    \"binary\": {\r\n      decorate: function(aString) {\r\n        return ICAL.Binary.fromString(aString);\r\n      },\r\n\r\n      undecorate: function(aBinary) {\r\n        return aBinary.toString();\r\n      }\r\n    },\r\n    \"cal-address\": {\r\n      // needs to be an uri\r\n    },\r\n    \"date\": {\r\n      decorate: function(aValue, aProp) {\r\n        if (design.strict) {\r\n          return ICAL.Time.fromDateString(aValue, aProp);\r\n        } else {\r\n          return ICAL.Time.fromString(aValue, aProp);\r\n        }\r\n      },\r\n\r\n      /**\r\n       * undecorates a time object.\r\n       */\r\n      undecorate: function(aValue) {\r\n        return aValue.toString();\r\n      },\r\n\r\n      fromICAL: function(aValue) {\r\n        // from: 20120901\r\n        // to: 2012-09-01\r\n        if (!design.strict && aValue.length >= 15) {\r\n          // This is probably a date-time, e.g. 20120901T130000Z\r\n          return icalValues[\"date-time\"].fromICAL(aValue);\r\n        } else {\r\n          return aValue.substr(0, 4) + '-' +\r\n                 aValue.substr(4, 2) + '-' +\r\n                 aValue.substr(6, 2);\r\n        }\r\n      },\r\n\r\n      toICAL: function(aValue) {\r\n        // from: 2012-09-01\r\n        // to: 20120901\r\n        var len = aValue.length;\r\n\r\n        if (len == 10) {\r\n          return aValue.substr(0, 4) +\r\n                 aValue.substr(5, 2) +\r\n                 aValue.substr(8, 2);\r\n        } else if (len >= 19) {\r\n          return icalValues[\"date-time\"].toICAL(aValue);\r\n        } else {\r\n          //TODO: serialize warning?\r\n          return aValue;\r\n        }\r\n\r\n      }\r\n    },\r\n    \"date-time\": {\r\n      fromICAL: function(aValue) {\r\n        // from: 20120901T130000\r\n        // to: 2012-09-01T13:00:00\r\n        if (!design.strict && aValue.length == 8) {\r\n          // This is probably a date, e.g. 20120901\r\n          return icalValues.date.fromICAL(aValue);\r\n        } else {\r\n          var result = aValue.substr(0, 4) + '-' +\r\n                       aValue.substr(4, 2) + '-' +\r\n                       aValue.substr(6, 2) + 'T' +\r\n                       aValue.substr(9, 2) + ':' +\r\n                       aValue.substr(11, 2) + ':' +\r\n                       aValue.substr(13, 2);\r\n\r\n          if (aValue[15] && aValue[15] === 'Z') {\r\n            result += 'Z';\r\n          }\r\n\r\n          return result;\r\n        }\r\n      },\r\n\r\n      toICAL: function(aValue) {\r\n        // from: 2012-09-01T13:00:00\r\n        // to: 20120901T130000\r\n        var len = aValue.length;\r\n\r\n        if (len == 10 && !design.strict) {\r\n          return icalValues.date.toICAL(aValue);\r\n        } else if (len >= 19) {\r\n          var result = aValue.substr(0, 4) +\r\n                       aValue.substr(5, 2) +\r\n                       // grab the (DDTHH) segment\r\n                       aValue.substr(8, 5) +\r\n                       // MM\r\n                       aValue.substr(14, 2) +\r\n                       // SS\r\n                       aValue.substr(17, 2);\r\n\r\n          if (aValue[19] && aValue[19] === 'Z') {\r\n            result += 'Z';\r\n          }\r\n          return result;\r\n        } else {\r\n          // TODO: error\r\n          return aValue;\r\n        }\r\n      },\r\n\r\n      decorate: function(aValue, aProp) {\r\n        if (design.strict) {\r\n          return ICAL.Time.fromDateTimeString(aValue, aProp);\r\n        } else {\r\n          return ICAL.Time.fromString(aValue, aProp);\r\n        }\r\n      },\r\n\r\n      undecorate: function(aValue) {\r\n        return aValue.toString();\r\n      }\r\n    },\r\n    duration: {\r\n      decorate: function(aValue) {\r\n        return ICAL.Duration.fromString(aValue);\r\n      },\r\n      undecorate: function(aValue) {\r\n        return aValue.toString();\r\n      }\r\n    },\r\n    period: {\r\n\r\n      fromICAL: function(string) {\r\n        var parts = string.split('/');\r\n        parts[0] = icalValues['date-time'].fromICAL(parts[0]);\r\n\r\n        if (!ICAL.Duration.isValueString(parts[1])) {\r\n          parts[1] = icalValues['date-time'].fromICAL(parts[1]);\r\n        }\r\n\r\n        return parts;\r\n      },\r\n\r\n      toICAL: function(parts) {\r\n        if (!design.strict && parts[0].length == 10) {\r\n          parts[0] = icalValues.date.toICAL(parts[0]);\r\n        } else {\r\n          parts[0] = icalValues['date-time'].toICAL(parts[0]);\r\n        }\r\n\r\n        if (!ICAL.Duration.isValueString(parts[1])) {\r\n          if (!design.strict && parts[1].length == 10) {\r\n            parts[1] = icalValues.date.toICAL(parts[1]);\r\n          } else {\r\n            parts[1] = icalValues['date-time'].toICAL(parts[1]);\r\n          }\r\n        }\r\n\r\n        return parts.join(\"/\");\r\n      },\r\n\r\n      decorate: function(aValue, aProp) {\r\n        return ICAL.Period.fromJSON(aValue, aProp, !design.strict);\r\n      },\r\n\r\n      undecorate: function(aValue) {\r\n        return aValue.toJSON();\r\n      }\r\n    },\r\n    recur: {\r\n      fromICAL: function(string) {\r\n        return ICAL.Recur._stringToData(string, true);\r\n      },\r\n\r\n      toICAL: function(data) {\r\n        var str = \"\";\r\n        for (var k in data) {\r\n          /* istanbul ignore if */\r\n          if (!Object.prototype.hasOwnProperty.call(data, k)) {\r\n            continue;\r\n          }\r\n          var val = data[k];\r\n          if (k == \"until\") {\r\n            if (val.length > 10) {\r\n              val = icalValues['date-time'].toICAL(val);\r\n            } else {\r\n              val = icalValues.date.toICAL(val);\r\n            }\r\n          } else if (k == \"wkst\") {\r\n            if (typeof val === 'number') {\r\n              val = ICAL.Recur.numericDayToIcalDay(val);\r\n            }\r\n          } else if (Array.isArray(val)) {\r\n            val = val.join(\",\");\r\n          }\r\n          str += k.toUpperCase() + \"=\" + val + \";\";\r\n        }\r\n        return str.substr(0, str.length - 1);\r\n      },\r\n\r\n      decorate: function decorate(aValue) {\r\n        return ICAL.Recur.fromData(aValue);\r\n      },\r\n\r\n      undecorate: function(aRecur) {\r\n        return aRecur.toJSON();\r\n      }\r\n    },\r\n\r\n    time: {\r\n      fromICAL: function(aValue) {\r\n        // from: MMHHSS(Z)?\r\n        // to: HH:MM:SS(Z)?\r\n        if (aValue.length < 6) {\r\n          // TODO: parser exception?\r\n          return aValue;\r\n        }\r\n\r\n        // HH::MM::SSZ?\r\n        var result = aValue.substr(0, 2) + ':' +\r\n                     aValue.substr(2, 2) + ':' +\r\n                     aValue.substr(4, 2);\r\n\r\n        if (aValue[6] === 'Z') {\r\n          result += 'Z';\r\n        }\r\n\r\n        return result;\r\n      },\r\n\r\n      toICAL: function(aValue) {\r\n        // from: HH:MM:SS(Z)?\r\n        // to: MMHHSS(Z)?\r\n        if (aValue.length < 8) {\r\n          //TODO: error\r\n          return aValue;\r\n        }\r\n\r\n        var result = aValue.substr(0, 2) +\r\n                     aValue.substr(3, 2) +\r\n                     aValue.substr(6, 2);\r\n\r\n        if (aValue[8] === 'Z') {\r\n          result += 'Z';\r\n        }\r\n\r\n        return result;\r\n      }\r\n    }\r\n  });\r\n\r\n  var icalProperties = ICAL.helpers.extend(commonProperties, {\r\n\r\n    \"action\": DEFAULT_TYPE_TEXT,\r\n    \"attach\": { defaultType: \"uri\" },\r\n    \"attendee\": { defaultType: \"cal-address\" },\r\n    \"calscale\": DEFAULT_TYPE_TEXT,\r\n    \"class\": DEFAULT_TYPE_TEXT,\r\n    \"comment\": DEFAULT_TYPE_TEXT,\r\n    \"completed\": DEFAULT_TYPE_DATETIME,\r\n    \"contact\": DEFAULT_TYPE_TEXT,\r\n    \"created\": DEFAULT_TYPE_DATETIME,\r\n    \"description\": DEFAULT_TYPE_TEXT,\r\n    \"dtend\": DEFAULT_TYPE_DATETIME_DATE,\r\n    \"dtstamp\": DEFAULT_TYPE_DATETIME,\r\n    \"dtstart\": DEFAULT_TYPE_DATETIME_DATE,\r\n    \"due\": DEFAULT_TYPE_DATETIME_DATE,\r\n    \"duration\": { defaultType: \"duration\" },\r\n    \"exdate\": {\r\n      defaultType: \"date-time\",\r\n      allowedTypes: [\"date-time\", \"date\"],\r\n      multiValue: ','\r\n    },\r\n    \"exrule\": DEFAULT_TYPE_RECUR,\r\n    \"freebusy\": { defaultType: \"period\", multiValue: \",\" },\r\n    \"geo\": { defaultType: \"float\", structuredValue: \";\" },\r\n    \"last-modified\": DEFAULT_TYPE_DATETIME,\r\n    \"location\": DEFAULT_TYPE_TEXT,\r\n    \"method\": DEFAULT_TYPE_TEXT,\r\n    \"organizer\": { defaultType: \"cal-address\" },\r\n    \"percent-complete\": DEFAULT_TYPE_INTEGER,\r\n    \"priority\": DEFAULT_TYPE_INTEGER,\r\n    \"prodid\": DEFAULT_TYPE_TEXT,\r\n    \"related-to\": DEFAULT_TYPE_TEXT,\r\n    \"repeat\": DEFAULT_TYPE_INTEGER,\r\n    \"rdate\": {\r\n      defaultType: \"date-time\",\r\n      allowedTypes: [\"date-time\", \"date\", \"period\"],\r\n      multiValue: ',',\r\n      detectType: function(string) {\r\n        if (string.indexOf('/') !== -1) {\r\n          return 'period';\r\n        }\r\n        return (string.indexOf('T') === -1) ? 'date' : 'date-time';\r\n      }\r\n    },\r\n    \"recurrence-id\": DEFAULT_TYPE_DATETIME_DATE,\r\n    \"resources\": DEFAULT_TYPE_TEXT_MULTI,\r\n    \"request-status\": DEFAULT_TYPE_TEXT_STRUCTURED,\r\n    \"rrule\": DEFAULT_TYPE_RECUR,\r\n    \"sequence\": DEFAULT_TYPE_INTEGER,\r\n    \"status\": DEFAULT_TYPE_TEXT,\r\n    \"summary\": DEFAULT_TYPE_TEXT,\r\n    \"transp\": DEFAULT_TYPE_TEXT,\r\n    \"trigger\": { defaultType: \"duration\", allowedTypes: [\"duration\", \"date-time\"] },\r\n    \"tzoffsetfrom\": DEFAULT_TYPE_UTCOFFSET,\r\n    \"tzoffsetto\": DEFAULT_TYPE_UTCOFFSET,\r\n    \"tzurl\": DEFAULT_TYPE_URI,\r\n    \"tzid\": DEFAULT_TYPE_TEXT,\r\n    \"tzname\": DEFAULT_TYPE_TEXT\r\n  });\r\n\r\n  // When adding a value here, be sure to add it to the parameter types!\r\n  var vcardValues = ICAL.helpers.extend(commonValues, {\r\n    text: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\r\n    uri: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),\r\n\r\n    date: {\r\n      decorate: function(aValue) {\r\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date\");\r\n      },\r\n      undecorate: function(aValue) {\r\n        return aValue.toString();\r\n      },\r\n      fromICAL: function(aValue) {\r\n        if (aValue.length == 8) {\r\n          return icalValues.date.fromICAL(aValue);\r\n        } else if (aValue[0] == '-' && aValue.length == 6) {\r\n          return aValue.substr(0, 4) + '-' + aValue.substr(4);\r\n        } else {\r\n          return aValue;\r\n        }\r\n      },\r\n      toICAL: function(aValue) {\r\n        if (aValue.length == 10) {\r\n          return icalValues.date.toICAL(aValue);\r\n        } else if (aValue[0] == '-' && aValue.length == 7) {\r\n          return aValue.substr(0, 4) + aValue.substr(5);\r\n        } else {\r\n          return aValue;\r\n        }\r\n      }\r\n    },\r\n\r\n    time: {\r\n      decorate: function(aValue) {\r\n        return ICAL.VCardTime.fromDateAndOrTimeString(\"T\" + aValue, \"time\");\r\n      },\r\n      undecorate: function(aValue) {\r\n        return aValue.toString();\r\n      },\r\n      fromICAL: function(aValue) {\r\n        var splitzone = vcardValues.time._splitZone(aValue, true);\r\n        var zone = splitzone[0], value = splitzone[1];\r\n\r\n        //console.log(\"SPLIT: \",splitzone);\r\n\r\n        if (value.length == 6) {\r\n          value = value.substr(0, 2) + ':' +\r\n                  value.substr(2, 2) + ':' +\r\n                  value.substr(4, 2);\r\n        } else if (value.length == 4 && value[0] != '-') {\r\n          value = value.substr(0, 2) + ':' + value.substr(2, 2);\r\n        } else if (value.length == 5) {\r\n          value = value.substr(0, 3) + ':' + value.substr(3, 2);\r\n        }\r\n\r\n        if (zone.length == 5 && (zone[0] == '-' || zone[0] == '+')) {\r\n          zone = zone.substr(0, 3) + ':' + zone.substr(3);\r\n        }\r\n\r\n        return value + zone;\r\n      },\r\n\r\n      toICAL: function(aValue) {\r\n        var splitzone = vcardValues.time._splitZone(aValue);\r\n        var zone = splitzone[0], value = splitzone[1];\r\n\r\n        if (value.length == 8) {\r\n          value = value.substr(0, 2) +\r\n                  value.substr(3, 2) +\r\n                  value.substr(6, 2);\r\n        } else if (value.length == 5 && value[0] != '-') {\r\n          value = value.substr(0, 2) + value.substr(3, 2);\r\n        } else if (value.length == 6) {\r\n          value = value.substr(0, 3) + value.substr(4, 2);\r\n        }\r\n\r\n        if (zone.length == 6 && (zone[0] == '-' || zone[0] == '+')) {\r\n          zone = zone.substr(0, 3) + zone.substr(4);\r\n        }\r\n\r\n        return value + zone;\r\n      },\r\n\r\n      _splitZone: function(aValue, isFromIcal) {\r\n        var lastChar = aValue.length - 1;\r\n        var signChar = aValue.length - (isFromIcal ? 5 : 6);\r\n        var sign = aValue[signChar];\r\n        var zone, value;\r\n\r\n        if (aValue[lastChar] == 'Z') {\r\n          zone = aValue[lastChar];\r\n          value = aValue.substr(0, lastChar);\r\n        } else if (aValue.length > 6 && (sign == '-' || sign == '+')) {\r\n          zone = aValue.substr(signChar);\r\n          value = aValue.substr(0, signChar);\r\n        } else {\r\n          zone = \"\";\r\n          value = aValue;\r\n        }\r\n\r\n        return [zone, value];\r\n      }\r\n    },\r\n\r\n    \"date-time\": {\r\n      decorate: function(aValue) {\r\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date-time\");\r\n      },\r\n\r\n      undecorate: function(aValue) {\r\n        return aValue.toString();\r\n      },\r\n\r\n      fromICAL: function(aValue) {\r\n        return vcardValues['date-and-or-time'].fromICAL(aValue);\r\n      },\r\n\r\n      toICAL: function(aValue) {\r\n        return vcardValues['date-and-or-time'].toICAL(aValue);\r\n      }\r\n    },\r\n\r\n    \"date-and-or-time\": {\r\n      decorate: function(aValue) {\r\n        return ICAL.VCardTime.fromDateAndOrTimeString(aValue, \"date-and-or-time\");\r\n      },\r\n\r\n      undecorate: function(aValue) {\r\n        return aValue.toString();\r\n      },\r\n\r\n      fromICAL: function(aValue) {\r\n        var parts = aValue.split('T');\r\n        return (parts[0] ? vcardValues.date.fromICAL(parts[0]) : '') +\r\n               (parts[1] ? 'T' + vcardValues.time.fromICAL(parts[1]) : '');\r\n      },\r\n\r\n      toICAL: function(aValue) {\r\n        var parts = aValue.split('T');\r\n        return vcardValues.date.toICAL(parts[0]) +\r\n               (parts[1] ? 'T' + vcardValues.time.toICAL(parts[1]) : '');\r\n\r\n      }\r\n    },\r\n    timestamp: icalValues['date-time'],\r\n    \"language-tag\": {\r\n      matches: /^[a-zA-Z0-9-]+$/ // Could go with a more strict regex here\r\n    }\r\n  });\r\n\r\n  var vcardParams = {\r\n    \"type\": {\r\n      valueType: \"text\",\r\n      multiValue: \",\"\r\n    },\r\n    \"value\": {\r\n      // since the value here is a 'type' lowercase is used.\r\n      values: [\"text\", \"uri\", \"date\", \"time\", \"date-time\", \"date-and-or-time\",\r\n               \"timestamp\", \"boolean\", \"integer\", \"float\", \"utc-offset\",\r\n               \"language-tag\"],\r\n      allowXName: true,\r\n      allowIanaToken: true\r\n    }\r\n  };\r\n\r\n  var vcardProperties = ICAL.helpers.extend(commonProperties, {\r\n    \"adr\": { defaultType: \"text\", structuredValue: \";\", multiValue: \",\" },\r\n    \"anniversary\": DEFAULT_TYPE_DATE_ANDOR_TIME,\r\n    \"bday\": DEFAULT_TYPE_DATE_ANDOR_TIME,\r\n    \"caladruri\": DEFAULT_TYPE_URI,\r\n    \"caluri\": DEFAULT_TYPE_URI,\r\n    \"clientpidmap\": DEFAULT_TYPE_TEXT_STRUCTURED,\r\n    \"email\": DEFAULT_TYPE_TEXT,\r\n    \"fburl\": DEFAULT_TYPE_URI,\r\n    \"fn\": DEFAULT_TYPE_TEXT,\r\n    \"gender\": DEFAULT_TYPE_TEXT_STRUCTURED,\r\n    \"geo\": DEFAULT_TYPE_URI,\r\n    \"impp\": DEFAULT_TYPE_URI,\r\n    \"key\": DEFAULT_TYPE_URI,\r\n    \"kind\": DEFAULT_TYPE_TEXT,\r\n    \"lang\": { defaultType: \"language-tag\" },\r\n    \"logo\": DEFAULT_TYPE_URI,\r\n    \"member\": DEFAULT_TYPE_URI,\r\n    \"n\": { defaultType: \"text\", structuredValue: \";\", multiValue: \",\" },\r\n    \"nickname\": DEFAULT_TYPE_TEXT_MULTI,\r\n    \"note\": DEFAULT_TYPE_TEXT,\r\n    \"org\": { defaultType: \"text\", structuredValue: \";\" },\r\n    \"photo\": DEFAULT_TYPE_URI,\r\n    \"related\": DEFAULT_TYPE_URI,\r\n    \"rev\": { defaultType: \"timestamp\" },\r\n    \"role\": DEFAULT_TYPE_TEXT,\r\n    \"sound\": DEFAULT_TYPE_URI,\r\n    \"source\": DEFAULT_TYPE_URI,\r\n    \"tel\": { defaultType: \"uri\", allowedTypes: [\"uri\", \"text\"] },\r\n    \"title\": DEFAULT_TYPE_TEXT,\r\n    \"tz\": { defaultType: \"text\", allowedTypes: [\"text\", \"utc-offset\", \"uri\"] },\r\n    \"xml\": DEFAULT_TYPE_TEXT\r\n  });\r\n\r\n  var vcard3Values = ICAL.helpers.extend(commonValues, {\r\n    binary: icalValues.binary,\r\n    date: vcardValues.date,\r\n    \"date-time\": vcardValues[\"date-time\"],\r\n    \"phone-number\": {\r\n      // TODO\r\n      /* ... */\r\n    },\r\n    uri: icalValues.uri,\r\n    text: icalValues.text,\r\n    time: icalValues.time,\r\n    vcard: icalValues.text,\r\n    \"utc-offset\": {\r\n      toICAL: function(aValue) {\r\n        return aValue.substr(0, 7);\r\n      },\r\n\r\n      fromICAL: function(aValue) {\r\n        return aValue.substr(0, 7);\r\n      },\r\n\r\n      decorate: function(aValue) {\r\n        return ICAL.UtcOffset.fromString(aValue);\r\n      },\r\n\r\n      undecorate: function(aValue) {\r\n        return aValue.toString();\r\n      }\r\n    }\r\n  });\r\n\r\n  var vcard3Params = {\r\n    \"type\": {\r\n      valueType: \"text\",\r\n      multiValue: \",\"\r\n    },\r\n    \"value\": {\r\n      // since the value here is a 'type' lowercase is used.\r\n      values: [\"text\", \"uri\", \"date\", \"date-time\", \"phone-number\", \"time\",\r\n               \"boolean\", \"integer\", \"float\", \"utc-offset\", \"vcard\", \"binary\"],\r\n      allowXName: true,\r\n      allowIanaToken: true\r\n    }\r\n  };\r\n\r\n  var vcard3Properties = ICAL.helpers.extend(commonProperties, {\r\n    fn: DEFAULT_TYPE_TEXT,\r\n    n: { defaultType: \"text\", structuredValue: \";\", multiValue: \",\" },\r\n    nickname: DEFAULT_TYPE_TEXT_MULTI,\r\n    photo: { defaultType: \"binary\", allowedTypes: [\"binary\", \"uri\"] },\r\n    bday: {\r\n      defaultType: \"date-time\",\r\n      allowedTypes: [\"date-time\", \"date\"],\r\n      detectType: function(string) {\r\n        return (string.indexOf('T') === -1) ? 'date' : 'date-time';\r\n      }\r\n    },\r\n\r\n    adr: { defaultType: \"text\", structuredValue: \";\", multiValue: \",\" },\r\n    label: DEFAULT_TYPE_TEXT,\r\n\r\n    tel: { defaultType: \"phone-number\" },\r\n    email: DEFAULT_TYPE_TEXT,\r\n    mailer: DEFAULT_TYPE_TEXT,\r\n\r\n    tz: { defaultType: \"utc-offset\", allowedTypes: [\"utc-offset\", \"text\"] },\r\n    geo: { defaultType: \"float\", structuredValue: \";\" },\r\n\r\n    title: DEFAULT_TYPE_TEXT,\r\n    role: DEFAULT_TYPE_TEXT,\r\n    logo: { defaultType: \"binary\", allowedTypes: [\"binary\", \"uri\"] },\r\n    agent: { defaultType: \"vcard\", allowedTypes: [\"vcard\", \"text\", \"uri\"] },\r\n    org: DEFAULT_TYPE_TEXT_STRUCTURED,\r\n\r\n    note: DEFAULT_TYPE_TEXT_MULTI,\r\n    prodid: DEFAULT_TYPE_TEXT,\r\n    rev: {\r\n      defaultType: \"date-time\",\r\n      allowedTypes: [\"date-time\", \"date\"],\r\n      detectType: function(string) {\r\n        return (string.indexOf('T') === -1) ? 'date' : 'date-time';\r\n      }\r\n    },\r\n    \"sort-string\": DEFAULT_TYPE_TEXT,\r\n    sound: { defaultType: \"binary\", allowedTypes: [\"binary\", \"uri\"] },\r\n\r\n    class: DEFAULT_TYPE_TEXT,\r\n    key: { defaultType: \"binary\", allowedTypes: [\"binary\", \"text\"] }\r\n  });\r\n\r\n  /**\r\n   * iCalendar design set\r\n   * @type {ICAL.design.designSet}\r\n   */\r\n  var icalSet = {\r\n    value: icalValues,\r\n    param: icalParams,\r\n    property: icalProperties\r\n  };\r\n\r\n  /**\r\n   * vCard 4.0 design set\r\n   * @type {ICAL.design.designSet}\r\n   */\r\n  var vcardSet = {\r\n    value: vcardValues,\r\n    param: vcardParams,\r\n    property: vcardProperties\r\n  };\r\n\r\n  /**\r\n   * vCard 3.0 design set\r\n   * @type {ICAL.design.designSet}\r\n   */\r\n  var vcard3Set = {\r\n    value: vcard3Values,\r\n    param: vcard3Params,\r\n    property: vcard3Properties\r\n  };\r\n\r\n  /**\r\n   * The design data, used by the parser to determine types for properties and\r\n   * other metadata needed to produce correct jCard/jCal data.\r\n   *\r\n   * @alias ICAL.design\r\n   * @namespace\r\n   */\r\n  var design = {\r\n    /**\r\n     * A designSet describes value, parameter and property data. It is used by\r\n     * ther parser and stringifier in components and properties to determine they\r\n     * should be represented.\r\n     *\r\n     * @typedef {Object} designSet\r\n     * @memberOf ICAL.design\r\n     * @property {Object} value       Definitions for value types, keys are type names\r\n     * @property {Object} param       Definitions for params, keys are param names\r\n     * @property {Object} property    Defintions for properties, keys are property names\r\n     */\r\n\r\n    /**\r\n     * Can be set to false to make the parser more lenient.\r\n     */\r\n    strict: true,\r\n\r\n    /**\r\n     * The default set for new properties and components if none is specified.\r\n     * @type {ICAL.design.designSet}\r\n     */\r\n    defaultSet: icalSet,\r\n\r\n    /**\r\n     * The default type for unknown properties\r\n     * @type {String}\r\n     */\r\n    defaultType: 'unknown',\r\n\r\n    /**\r\n     * Holds the design set for known top-level components\r\n     *\r\n     * @type {Object}\r\n     * @property {ICAL.design.designSet} vcard       vCard VCARD\r\n     * @property {ICAL.design.designSet} vevent      iCalendar VEVENT\r\n     * @property {ICAL.design.designSet} vtodo       iCalendar VTODO\r\n     * @property {ICAL.design.designSet} vjournal    iCalendar VJOURNAL\r\n     * @property {ICAL.design.designSet} valarm      iCalendar VALARM\r\n     * @property {ICAL.design.designSet} vtimezone   iCalendar VTIMEZONE\r\n     * @property {ICAL.design.designSet} daylight    iCalendar DAYLIGHT\r\n     * @property {ICAL.design.designSet} standard    iCalendar STANDARD\r\n     *\r\n     * @example\r\n     * var propertyName = 'fn';\r\n     * var componentDesign = ICAL.design.components.vcard;\r\n     * var propertyDetails = componentDesign.property[propertyName];\r\n     * if (propertyDetails.defaultType == 'text') {\r\n     *   // Yep, sure is...\r\n     * }\r\n     */\r\n    components: {\r\n      vcard: vcardSet,\r\n      vcard3: vcard3Set,\r\n      vevent: icalSet,\r\n      vtodo: icalSet,\r\n      vjournal: icalSet,\r\n      valarm: icalSet,\r\n      vtimezone: icalSet,\r\n      daylight: icalSet,\r\n      standard: icalSet\r\n    },\r\n\r\n\r\n    /**\r\n     * The design set for iCalendar (rfc5545/rfc7265) components.\r\n     * @type {ICAL.design.designSet}\r\n     */\r\n    icalendar: icalSet,\r\n\r\n    /**\r\n     * The design set for vCard (rfc6350/rfc7095) components.\r\n     * @type {ICAL.design.designSet}\r\n     */\r\n    vcard: vcardSet,\r\n\r\n    /**\r\n     * The design set for vCard (rfc2425/rfc2426/rfc7095) components.\r\n     * @type {ICAL.design.designSet}\r\n     */\r\n    vcard3: vcard3Set,\r\n\r\n    /**\r\n     * Gets the design set for the given component name.\r\n     *\r\n     * @param {String} componentName        The name of the component\r\n     * @return {ICAL.design.designSet}      The design set for the component\r\n     */\r\n    getDesignSet: function(componentName) {\r\n      var isInDesign = componentName && componentName in design.components;\r\n      return isInDesign ? design.components[componentName] : design.defaultSet;\r\n    }\r\n  };\r\n\r\n  return design;\r\n}());\r\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\r\n\r\n\r\n/**\r\n * Contains various functions to convert jCal and jCard data back into\r\n * iCalendar and vCard.\r\n * @namespace\r\n */\r\nICAL.stringify = (function() {\r\n  'use strict';\r\n\r\n  var LINE_ENDING = '\\r\\n';\r\n  var DEFAULT_VALUE_TYPE = 'unknown';\r\n\r\n  var design = ICAL.design;\r\n  var helpers = ICAL.helpers;\r\n\r\n  /**\r\n   * Convert a full jCal/jCard array into a iCalendar/vCard string.\r\n   *\r\n   * @function ICAL.stringify\r\n   * @variation function\r\n   * @param {Array} jCal    The jCal/jCard document\r\n   * @return {String}       The stringified iCalendar/vCard document\r\n   */\r\n  function stringify(jCal) {\r\n    if (typeof jCal[0] == \"string\") {\r\n      // This is a single component\r\n      jCal = [jCal];\r\n    }\r\n\r\n    var i = 0;\r\n    var len = jCal.length;\r\n    var result = '';\r\n\r\n    for (; i < len; i++) {\r\n      result += stringify.component(jCal[i]) + LINE_ENDING;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Converts an jCal component array into a ICAL string.\r\n   * Recursive will resolve sub-components.\r\n   *\r\n   * Exact component/property order is not saved all\r\n   * properties will come before subcomponents.\r\n   *\r\n   * @function ICAL.stringify.component\r\n   * @param {Array} component\r\n   *        jCal/jCard fragment of a component\r\n   * @param {ICAL.design.designSet} designSet\r\n   *        The design data to use for this component\r\n   * @return {String}       The iCalendar/vCard string\r\n   */\r\n  stringify.component = function(component, designSet) {\r\n    var name = component[0].toUpperCase();\r\n    var result = 'BEGIN:' + name + LINE_ENDING;\r\n\r\n    var props = component[1];\r\n    var propIdx = 0;\r\n    var propLen = props.length;\r\n\r\n    var designSetName = component[0];\r\n    // rfc6350 requires that in vCard 4.0 the first component is the VERSION\r\n    // component with as value 4.0, note that 3.0 does not have this requirement.\r\n    if (designSetName === 'vcard' && component[1].length > 0 &&\r\n            !(component[1][0][0] === \"version\" && component[1][0][3] === \"4.0\")) {\r\n      designSetName = \"vcard3\";\r\n    }\r\n    designSet = designSet || design.getDesignSet(designSetName);\r\n\r\n    for (; propIdx < propLen; propIdx++) {\r\n      result += stringify.property(props[propIdx], designSet) + LINE_ENDING;\r\n    }\r\n\r\n    // Ignore subcomponents if none exist, e.g. in vCard.\r\n    var comps = component[2] || [];\r\n    var compIdx = 0;\r\n    var compLen = comps.length;\r\n\r\n    for (; compIdx < compLen; compIdx++) {\r\n      result += stringify.component(comps[compIdx], designSet) + LINE_ENDING;\r\n    }\r\n\r\n    result += 'END:' + name;\r\n    return result;\r\n  };\r\n\r\n  /**\r\n   * Converts a single jCal/jCard property to a iCalendar/vCard string.\r\n   *\r\n   * @function ICAL.stringify.property\r\n   * @param {Array} property\r\n   *        jCal/jCard property array\r\n   * @param {ICAL.design.designSet} designSet\r\n   *        The design data to use for this property\r\n   * @param {Boolean} noFold\r\n   *        If true, the line is not folded\r\n   * @return {String}       The iCalendar/vCard string\r\n   */\r\n  stringify.property = function(property, designSet, noFold) {\r\n    var name = property[0].toUpperCase();\r\n    var jsName = property[0];\r\n    var params = property[1];\r\n\r\n    var line = name;\r\n\r\n    var paramName;\r\n    for (paramName in params) {\r\n      var value = params[paramName];\r\n\r\n      /* istanbul ignore else */\r\n      if (params.hasOwnProperty(paramName)) {\r\n        var multiValue = (paramName in designSet.param) && designSet.param[paramName].multiValue;\r\n        if (multiValue && Array.isArray(value)) {\r\n          if (designSet.param[paramName].multiValueSeparateDQuote) {\r\n            multiValue = '\"' + multiValue + '\"';\r\n          }\r\n          value = value.map(stringify._rfc6868Unescape);\r\n          value = stringify.multiValue(value, multiValue, \"unknown\", null, designSet);\r\n        } else {\r\n          value = stringify._rfc6868Unescape(value);\r\n        }\r\n\r\n\r\n        line += ';' + paramName.toUpperCase();\r\n        line += '=' + stringify.propertyValue(value);\r\n      }\r\n    }\r\n\r\n    if (property.length === 3) {\r\n      // If there are no values, we must assume a blank value\r\n      return line + ':';\r\n    }\r\n\r\n    var valueType = property[2];\r\n\r\n    if (!designSet) {\r\n      designSet = design.defaultSet;\r\n    }\r\n\r\n    var propDetails;\r\n    var multiValue = false;\r\n    var structuredValue = false;\r\n    var isDefault = false;\r\n\r\n    if (jsName in designSet.property) {\r\n      propDetails = designSet.property[jsName];\r\n\r\n      if ('multiValue' in propDetails) {\r\n        multiValue = propDetails.multiValue;\r\n      }\r\n\r\n      if (('structuredValue' in propDetails) && Array.isArray(property[3])) {\r\n        structuredValue = propDetails.structuredValue;\r\n      }\r\n\r\n      if ('defaultType' in propDetails) {\r\n        if (valueType === propDetails.defaultType) {\r\n          isDefault = true;\r\n        }\r\n      } else {\r\n        if (valueType === DEFAULT_VALUE_TYPE) {\r\n          isDefault = true;\r\n        }\r\n      }\r\n    } else {\r\n      if (valueType === DEFAULT_VALUE_TYPE) {\r\n        isDefault = true;\r\n      }\r\n    }\r\n\r\n    // push the VALUE property if type is not the default\r\n    // for the current property.\r\n    if (!isDefault) {\r\n      // value will never contain ;/:/, so we don't escape it here.\r\n      line += ';VALUE=' + valueType.toUpperCase();\r\n    }\r\n\r\n    line += ':';\r\n\r\n    if (multiValue && structuredValue) {\r\n      line += stringify.multiValue(\r\n        property[3], structuredValue, valueType, multiValue, designSet, structuredValue\r\n      );\r\n    } else if (multiValue) {\r\n      line += stringify.multiValue(\r\n        property.slice(3), multiValue, valueType, null, designSet, false\r\n      );\r\n    } else if (structuredValue) {\r\n      line += stringify.multiValue(\r\n        property[3], structuredValue, valueType, null, designSet, structuredValue\r\n      );\r\n    } else {\r\n      line += stringify.value(property[3], valueType, designSet, false);\r\n    }\r\n\r\n    return noFold ? line : ICAL.helpers.foldline(line);\r\n  };\r\n\r\n  /**\r\n   * Handles escaping of property values that may contain:\r\n   *\r\n   *    COLON (:), SEMICOLON (;), or COMMA (,)\r\n   *\r\n   * If any of the above are present the result is wrapped\r\n   * in double quotes.\r\n   *\r\n   * @function ICAL.stringify.propertyValue\r\n   * @param {String} value      Raw property value\r\n   * @return {String}           Given or escaped value when needed\r\n   */\r\n  stringify.propertyValue = function(value) {\r\n\r\n    if ((helpers.unescapedIndexOf(value, ',') === -1) &&\r\n        (helpers.unescapedIndexOf(value, ':') === -1) &&\r\n        (helpers.unescapedIndexOf(value, ';') === -1)) {\r\n\r\n      return value;\r\n    }\r\n\r\n    return '\"' + value + '\"';\r\n  };\r\n\r\n  /**\r\n   * Converts an array of ical values into a single\r\n   * string based on a type and a delimiter value (like \",\").\r\n   *\r\n   * @function ICAL.stringify.multiValue\r\n   * @param {Array} values      List of values to convert\r\n   * @param {String} delim      Used to join the values (\",\", \";\", \":\")\r\n   * @param {String} type       Lowecase ical value type\r\n   *        (like boolean, date-time, etc..)\r\n   * @param {?String} innerMulti If set, each value will again be processed\r\n   *        Used for structured values\r\n   * @param {ICAL.design.designSet} designSet\r\n   *        The design data to use for this property\r\n   *\r\n   * @return {String}           iCalendar/vCard string for value\r\n   */\r\n  stringify.multiValue = function(values, delim, type, innerMulti, designSet, structuredValue) {\r\n    var result = '';\r\n    var len = values.length;\r\n    var i = 0;\r\n\r\n    for (; i < len; i++) {\r\n      if (innerMulti && Array.isArray(values[i])) {\r\n        result += stringify.multiValue(values[i], innerMulti, type, null, designSet, structuredValue);\r\n      } else {\r\n        result += stringify.value(values[i], type, designSet, structuredValue);\r\n      }\r\n\r\n      if (i !== (len - 1)) {\r\n        result += delim;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  /**\r\n   * Processes a single ical value runs the associated \"toICAL\" method from the\r\n   * design value type if available to convert the value.\r\n   *\r\n   * @function ICAL.stringify.value\r\n   * @param {String|Number} value       A formatted value\r\n   * @param {String} type               Lowercase iCalendar/vCard value type\r\n   *  (like boolean, date-time, etc..)\r\n   * @return {String}                   iCalendar/vCard value for single value\r\n   */\r\n  stringify.value = function(value, type, designSet, structuredValue) {\r\n    if (type in designSet.value && 'toICAL' in designSet.value[type]) {\r\n      return designSet.value[type].toICAL(value, structuredValue);\r\n    }\r\n    return value;\r\n  };\r\n\r\n  /**\r\n   * Internal helper for rfc6868. Exposing this on ICAL.stringify so that\r\n   * hackers can disable the rfc6868 parsing if the really need to.\r\n   *\r\n   * @param {String} val        The value to unescape\r\n   * @return {String}           The escaped value\r\n   */\r\n  stringify._rfc6868Unescape = function(val) {\r\n    return val.replace(/[\\n^\"]/g, function(x) {\r\n      return RFC6868_REPLACE_MAP[x];\r\n    });\r\n  };\r\n  var RFC6868_REPLACE_MAP = { '\"': \"^'\", \"\\n\": \"^n\", \"^\": \"^^\" };\r\n\r\n  return stringify;\r\n}());\r\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\r\n\r\n\r\n/**\r\n * Contains various functions to parse iCalendar and vCard data.\r\n * @namespace\r\n */\r\nICAL.parse = (function() {\r\n  'use strict';\r\n\r\n  var CHAR = /[^ \\t]/;\r\n  var MULTIVALUE_DELIMITER = ',';\r\n  var VALUE_DELIMITER = ':';\r\n  var PARAM_DELIMITER = ';';\r\n  var PARAM_NAME_DELIMITER = '=';\r\n  var DEFAULT_VALUE_TYPE = 'unknown';\r\n  var DEFAULT_PARAM_TYPE = 'text';\r\n\r\n  var design = ICAL.design;\r\n  var helpers = ICAL.helpers;\r\n\r\n  /**\r\n   * An error that occurred during parsing.\r\n   *\r\n   * @param {String} message        The error message\r\n   * @memberof ICAL.parse\r\n   * @extends {Error}\r\n   * @class\r\n   */\r\n  function ParserError(message) {\r\n    this.message = message;\r\n    this.name = 'ParserError';\r\n\r\n    try {\r\n      throw new Error();\r\n    } catch (e) {\r\n      if (e.stack) {\r\n        var split = e.stack.split('\\n');\r\n        split.shift();\r\n        this.stack = split.join('\\n');\r\n      }\r\n    }\r\n  }\r\n\r\n  ParserError.prototype = Error.prototype;\r\n\r\n  /**\r\n   * Parses iCalendar or vCard data into a raw jCal object. Consult\r\n   * documentation on the {@tutorial layers|layers of parsing} for more\r\n   * details.\r\n   *\r\n   * @function ICAL.parse\r\n   * @variation function\r\n   * @todo Fix the API to be more clear on the return type\r\n   * @param {String} input      The string data to parse\r\n   * @return {Object|Object[]}  A single jCal object, or an array thereof\r\n   */\r\n  function parser(input) {\r\n    var state = {};\r\n    var root = state.component = [];\r\n\r\n    state.stack = [root];\r\n\r\n    parser._eachLine(input, function(err, line) {\r\n      parser._handleContentLine(line, state);\r\n    });\r\n\r\n\r\n    // when there are still items on the stack\r\n    // throw a fatal error, a component was not closed\r\n    // correctly in that case.\r\n    if (state.stack.length > 1) {\r\n      throw new ParserError(\r\n        'invalid ical body. component began but did not end'\r\n      );\r\n    }\r\n\r\n    state = null;\r\n\r\n    return (root.length == 1 ? root[0] : root);\r\n  }\r\n\r\n  /**\r\n   * Parse an iCalendar property value into the jCal for a single property\r\n   *\r\n   * @function ICAL.parse.property\r\n   * @param {String} str\r\n   *   The iCalendar property string to parse\r\n   * @param {ICAL.design.designSet=} designSet\r\n   *   The design data to use for this property\r\n   * @return {Object}\r\n   *   The jCal Object containing the property\r\n   */\r\n  parser.property = function(str, designSet) {\r\n    var state = {\r\n      component: [[], []],\r\n      designSet: designSet || design.defaultSet\r\n    };\r\n    parser._handleContentLine(str, state);\r\n    return state.component[1][0];\r\n  };\r\n\r\n  /**\r\n   * Convenience method to parse a component. You can use ICAL.parse() directly\r\n   * instead.\r\n   *\r\n   * @function ICAL.parse.component\r\n   * @see ICAL.parse(function)\r\n   * @param {String} str    The iCalendar component string to parse\r\n   * @return {Object}       The jCal Object containing the component\r\n   */\r\n  parser.component = function(str) {\r\n    return parser(str);\r\n  };\r\n\r\n  // classes & constants\r\n  parser.ParserError = ParserError;\r\n\r\n  /**\r\n   * The state for parsing content lines from an iCalendar/vCard string.\r\n   *\r\n   * @private\r\n   * @memberof ICAL.parse\r\n   * @typedef {Object} parserState\r\n   * @property {ICAL.design.designSet} designSet    The design set to use for parsing\r\n   * @property {ICAL.Component[]} stack             The stack of components being processed\r\n   * @property {ICAL.Component} component           The currently active component\r\n   */\r\n\r\n\r\n  /**\r\n   * Handles a single line of iCalendar/vCard, updating the state.\r\n   *\r\n   * @private\r\n   * @function ICAL.parse._handleContentLine\r\n   * @param {String} line               The content line to process\r\n   * @param {ICAL.parse.parserState}    The current state of the line parsing\r\n   */\r\n  parser._handleContentLine = function(line, state) {\r\n    // break up the parts of the line\r\n    var valuePos = line.indexOf(VALUE_DELIMITER);\r\n    var paramPos = line.indexOf(PARAM_DELIMITER);\r\n\r\n    var lastParamIndex;\r\n    var lastValuePos;\r\n\r\n    // name of property or begin/end\r\n    var name;\r\n    var value;\r\n    // params is only overridden if paramPos !== -1.\r\n    // we can't do params = params || {} later on\r\n    // because it sacrifices ops.\r\n    var params = {};\r\n\r\n    /**\r\n     * Different property cases\r\n     *\r\n     *\r\n     * 1. RRULE:FREQ=foo\r\n     *    // FREQ= is not a param but the value\r\n     *\r\n     * 2. ATTENDEE;ROLE=REQ-PARTICIPANT;\r\n     *    // ROLE= is a param because : has not happened yet\r\n     */\r\n      // when the parameter delimiter is after the\r\n      // value delimiter then its not a parameter.\r\n\r\n    if ((paramPos !== -1 && valuePos !== -1)) {\r\n      // when the parameter delimiter is after the\r\n      // value delimiter then its not a parameter.\r\n      if (paramPos > valuePos) {\r\n        paramPos = -1;\r\n      }\r\n    }\r\n\r\n    var parsedParams;\r\n    if (paramPos !== -1) {\r\n      name = line.substring(0, paramPos).toLowerCase();\r\n      parsedParams = parser._parseParameters(line.substring(paramPos), 0, state.designSet);\r\n      if (parsedParams[2] == -1) {\r\n        throw new ParserError(\"Invalid parameters in '\" + line + \"'\");\r\n      }\r\n      params = parsedParams[0];\r\n      lastParamIndex = parsedParams[1].length + parsedParams[2] + paramPos;\r\n      if ((lastValuePos =\r\n        line.substring(lastParamIndex).indexOf(VALUE_DELIMITER)) !== -1) {\r\n        value = line.substring(lastParamIndex + lastValuePos + 1);\r\n      } else {\r\n        throw new ParserError(\"Missing parameter value in '\" + line + \"'\");\r\n      }\r\n    } else if (valuePos !== -1) {\r\n      // without parmeters (BEGIN:VCAENDAR, CLASS:PUBLIC)\r\n      name = line.substring(0, valuePos).toLowerCase();\r\n      value = line.substring(valuePos + 1);\r\n\r\n      if (name === 'begin') {\r\n        var newComponent = [value.toLowerCase(), [], []];\r\n        if (state.stack.length === 1) {\r\n          state.component.push(newComponent);\r\n        } else {\r\n          state.component[2].push(newComponent);\r\n        }\r\n        state.stack.push(state.component);\r\n        state.component = newComponent;\r\n        if (!state.designSet) {\r\n          state.designSet = design.getDesignSet(state.component[0]);\r\n        }\r\n        return;\r\n      } else if (name === 'end') {\r\n        state.component = state.stack.pop();\r\n        return;\r\n      }\r\n      // If its not begin/end, then this is a property with an empty value,\r\n      // which should be considered valid.\r\n    } else {\r\n      /**\r\n       * Invalid line.\r\n       * The rational to throw an error is we will\r\n       * never be certain that the rest of the file\r\n       * is sane and its unlikely that we can serialize\r\n       * the result correctly either.\r\n       */\r\n      throw new ParserError(\r\n        'invalid line (no token \";\" or \":\") \"' + line + '\"'\r\n      );\r\n    }\r\n\r\n    var valueType;\r\n    var multiValue = false;\r\n    var structuredValue = false;\r\n    var propertyDetails;\r\n\r\n    if (name in state.designSet.property) {\r\n      propertyDetails = state.designSet.property[name];\r\n\r\n      if ('multiValue' in propertyDetails) {\r\n        multiValue = propertyDetails.multiValue;\r\n      }\r\n\r\n      if ('structuredValue' in propertyDetails) {\r\n        structuredValue = propertyDetails.structuredValue;\r\n      }\r\n\r\n      if (value && 'detectType' in propertyDetails) {\r\n        valueType = propertyDetails.detectType(value);\r\n      }\r\n    }\r\n\r\n    // attempt to determine value\r\n    if (!valueType) {\r\n      if (!('value' in params)) {\r\n        if (propertyDetails) {\r\n          valueType = propertyDetails.defaultType;\r\n        } else {\r\n          valueType = DEFAULT_VALUE_TYPE;\r\n        }\r\n      } else {\r\n        // possible to avoid this?\r\n        valueType = params.value.toLowerCase();\r\n      }\r\n    }\r\n\r\n    delete params.value;\r\n\r\n    /**\r\n     * Note on `var result` juggling:\r\n     *\r\n     * I observed that building the array in pieces has adverse\r\n     * effects on performance, so where possible we inline the creation.\r\n     * Its a little ugly but resulted in ~2000 additional ops/sec.\r\n     */\r\n\r\n    var result;\r\n    if (multiValue && structuredValue) {\r\n      value = parser._parseMultiValue(value, structuredValue, valueType, [], multiValue, state.designSet, structuredValue);\r\n      result = [name, params, valueType, value];\r\n    } else if (multiValue) {\r\n      result = [name, params, valueType];\r\n      parser._parseMultiValue(value, multiValue, valueType, result, null, state.designSet, false);\r\n    } else if (structuredValue) {\r\n      value = parser._parseMultiValue(value, structuredValue, valueType, [], null, state.designSet, structuredValue);\r\n      result = [name, params, valueType, value];\r\n    } else {\r\n      value = parser._parseValue(value, valueType, state.designSet, false);\r\n      result = [name, params, valueType, value];\r\n    }\r\n    // rfc6350 requires that in vCard 4.0 the first component is the VERSION\r\n    // component with as value 4.0, note that 3.0 does not have this requirement.\r\n    if (state.component[0] === 'vcard' && state.component[1].length === 0 &&\r\n            !(name === 'version' && value === '4.0')) {\r\n      state.designSet = design.getDesignSet(\"vcard3\");\r\n    }\r\n    state.component[1].push(result);\r\n  };\r\n\r\n  /**\r\n   * Parse a value from the raw value into the jCard/jCal value.\r\n   *\r\n   * @private\r\n   * @function ICAL.parse._parseValue\r\n   * @param {String} value          Original value\r\n   * @param {String} type           Type of value\r\n   * @param {Object} designSet      The design data to use for this value\r\n   * @return {Object} varies on type\r\n   */\r\n  parser._parseValue = function(value, type, designSet, structuredValue) {\r\n    if (type in designSet.value && 'fromICAL' in designSet.value[type]) {\r\n      return designSet.value[type].fromICAL(value, structuredValue);\r\n    }\r\n    return value;\r\n  };\r\n\r\n  /**\r\n   * Parse parameters from a string to object.\r\n   *\r\n   * @function ICAL.parse._parseParameters\r\n   * @private\r\n   * @param {String} line           A single unfolded line\r\n   * @param {Numeric} start         Position to start looking for properties\r\n   * @param {Object} designSet      The design data to use for this property\r\n   * @return {Object} key/value pairs\r\n   */\r\n  parser._parseParameters = function(line, start, designSet) {\r\n    var lastParam = start;\r\n    var pos = 0;\r\n    var delim = PARAM_NAME_DELIMITER;\r\n    var result = {};\r\n    var name, lcname;\r\n    var value, valuePos = -1;\r\n    var type, multiValue, mvdelim;\r\n\r\n    // find the next '=' sign\r\n    // use lastParam and pos to find name\r\n    // check if \" is used if so get value from \"->\"\r\n    // then increment pos to find next ;\r\n\r\n    while ((pos !== false) &&\r\n           (pos = helpers.unescapedIndexOf(line, delim, pos + 1)) !== -1) {\r\n\r\n      name = line.substr(lastParam + 1, pos - lastParam - 1);\r\n      if (name.length == 0) {\r\n        throw new ParserError(\"Empty parameter name in '\" + line + \"'\");\r\n      }\r\n      lcname = name.toLowerCase();\r\n      mvdelim = false;\r\n      multiValue = false;\r\n\r\n      if (lcname in designSet.param && designSet.param[lcname].valueType) {\r\n        type = designSet.param[lcname].valueType;\r\n      } else {\r\n        type = DEFAULT_PARAM_TYPE;\r\n      }\r\n\r\n      if (lcname in designSet.param) {\r\n        multiValue = designSet.param[lcname].multiValue;\r\n        if (designSet.param[lcname].multiValueSeparateDQuote) {\r\n          mvdelim = parser._rfc6868Escape('\"' + multiValue + '\"');\r\n        }\r\n      }\r\n\r\n      var nextChar = line[pos + 1];\r\n      if (nextChar === '\"') {\r\n        valuePos = pos + 2;\r\n        pos = helpers.unescapedIndexOf(line, '\"', valuePos);\r\n        if (multiValue && pos != -1) {\r\n            var extendedValue = true;\r\n            while (extendedValue) {\r\n              if (line[pos + 1] == multiValue && line[pos + 2] == '\"') {\r\n                pos = helpers.unescapedIndexOf(line, '\"', pos + 3);\r\n              } else {\r\n                extendedValue = false;\r\n              }\r\n            }\r\n          }\r\n        if (pos === -1) {\r\n          throw new ParserError(\r\n            'invalid line (no matching double quote) \"' + line + '\"'\r\n          );\r\n        }\r\n        value = line.substr(valuePos, pos - valuePos);\r\n        lastParam = helpers.unescapedIndexOf(line, PARAM_DELIMITER, pos);\r\n        if (lastParam === -1) {\r\n          pos = false;\r\n        }\r\n      } else {\r\n        valuePos = pos + 1;\r\n\r\n        // move to next \";\"\r\n        var nextPos = helpers.unescapedIndexOf(line, PARAM_DELIMITER, valuePos);\r\n        var propValuePos = helpers.unescapedIndexOf(line, VALUE_DELIMITER, valuePos);\r\n        if (propValuePos !== -1 && nextPos > propValuePos) {\r\n          // this is a delimiter in the property value, let's stop here\r\n          nextPos = propValuePos;\r\n          pos = false;\r\n        } else if (nextPos === -1) {\r\n          // no \";\"\r\n          if (propValuePos === -1) {\r\n            nextPos = line.length;\r\n          } else {\r\n            nextPos = propValuePos;\r\n          }\r\n          pos = false;\r\n        } else {\r\n          lastParam = nextPos;\r\n          pos = nextPos;\r\n        }\r\n\r\n        value = line.substr(valuePos, nextPos - valuePos);\r\n      }\r\n\r\n      value = parser._rfc6868Escape(value);\r\n      if (multiValue) {\r\n        var delimiter = mvdelim || multiValue;\r\n        value = parser._parseMultiValue(value, delimiter, type, [], null, designSet);\r\n      } else {\r\n        value = parser._parseValue(value, type, designSet);\r\n      }\r\n\r\n      if (multiValue && (lcname in result)) {\r\n        if (Array.isArray(result[lcname])) {\r\n          result[lcname].push(value);\r\n        } else {\r\n          result[lcname] = [\r\n            result[lcname],\r\n            value\r\n          ];\r\n        }\r\n      } else {\r\n        result[lcname] = value;\r\n      }\r\n    }\r\n    return [result, value, valuePos];\r\n  };\r\n\r\n  /**\r\n   * Internal helper for rfc6868. Exposing this on ICAL.parse so that\r\n   * hackers can disable the rfc6868 parsing if the really need to.\r\n   *\r\n   * @function ICAL.parse._rfc6868Escape\r\n   * @param {String} val        The value to escape\r\n   * @return {String}           The escaped value\r\n   */\r\n  parser._rfc6868Escape = function(val) {\r\n    return val.replace(/\\^['n^]/g, function(x) {\r\n      return RFC6868_REPLACE_MAP[x];\r\n    });\r\n  };\r\n  var RFC6868_REPLACE_MAP = { \"^'\": '\"', \"^n\": \"\\n\", \"^^\": \"^\" };\r\n\r\n  /**\r\n   * Parse a multi value string. This function is used either for parsing\r\n   * actual multi-value property's values, or for handling parameter values. It\r\n   * can be used for both multi-value properties and structured value properties.\r\n   *\r\n   * @private\r\n   * @function ICAL.parse._parseMultiValue\r\n   * @param {String} buffer     The buffer containing the full value\r\n   * @param {String} delim      The multi-value delimiter\r\n   * @param {String} type       The value type to be parsed\r\n   * @param {Array.<?>} result        The array to append results to, varies on value type\r\n   * @param {String} innerMulti The inner delimiter to split each value with\r\n   * @param {ICAL.design.designSet} designSet   The design data for this value\r\n   * @return {?|Array.<?>}            Either an array of results, or the first result\r\n   */\r\n  parser._parseMultiValue = function(buffer, delim, type, result, innerMulti, designSet, structuredValue) {\r\n    var pos = 0;\r\n    var lastPos = 0;\r\n    var value;\r\n    if (delim.length === 0) {\r\n      return buffer;\r\n    }\r\n\r\n    // split each piece\r\n    while ((pos = helpers.unescapedIndexOf(buffer, delim, lastPos)) !== -1) {\r\n      value = buffer.substr(lastPos, pos - lastPos);\r\n      if (innerMulti) {\r\n        value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);\r\n      } else {\r\n        value = parser._parseValue(value, type, designSet, structuredValue);\r\n      }\r\n      result.push(value);\r\n      lastPos = pos + delim.length;\r\n    }\r\n\r\n    // on the last piece take the rest of string\r\n    value = buffer.substr(lastPos);\r\n    if (innerMulti) {\r\n      value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);\r\n    } else {\r\n      value = parser._parseValue(value, type, designSet, structuredValue);\r\n    }\r\n    result.push(value);\r\n\r\n    return result.length == 1 ? result[0] : result;\r\n  };\r\n\r\n  /**\r\n   * Process a complete buffer of iCalendar/vCard data line by line, correctly\r\n   * unfolding content. Each line will be processed with the given callback\r\n   *\r\n   * @private\r\n   * @function ICAL.parse._eachLine\r\n   * @param {String} buffer                         The buffer to process\r\n   * @param {function(?String, String)} callback    The callback for each line\r\n   */\r\n  parser._eachLine = function(buffer, callback) {\r\n    var len = buffer.length;\r\n    var lastPos = buffer.search(CHAR);\r\n    var pos = lastPos;\r\n    var line;\r\n    var firstChar;\r\n\r\n    var newlineOffset;\r\n\r\n    do {\r\n      pos = buffer.indexOf('\\n', lastPos) + 1;\r\n\r\n      if (pos > 1 && buffer[pos - 2] === '\\r') {\r\n        newlineOffset = 2;\r\n      } else {\r\n        newlineOffset = 1;\r\n      }\r\n\r\n      if (pos === 0) {\r\n        pos = len;\r\n        newlineOffset = 0;\r\n      }\r\n\r\n      firstChar = buffer[lastPos];\r\n\r\n      if (firstChar === ' ' || firstChar === '\\t') {\r\n        // add to line\r\n        line += buffer.substr(\r\n          lastPos + 1,\r\n          pos - lastPos - (newlineOffset + 1)\r\n        );\r\n      } else {\r\n        if (line)\r\n          callback(null, line);\r\n        // push line\r\n        line = buffer.substr(\r\n          lastPos,\r\n          pos - lastPos - newlineOffset\r\n        );\r\n      }\r\n\r\n      lastPos = pos;\r\n    } while (pos !== len);\r\n\r\n    // extra ending line\r\n    line = line.trim();\r\n\r\n    if (line.length)\r\n      callback(null, line);\r\n  };\r\n\r\n  return parser;\r\n\r\n}());\r\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\r\n\r\n\r\n/**\r\n * This symbol is further described later on\r\n * @ignore\r\n */\r\nICAL.Component = (function() {\r\n  'use strict';\r\n\r\n  var PROPERTY_INDEX = 1;\r\n  var COMPONENT_INDEX = 2;\r\n  var NAME_INDEX = 0;\r\n\r\n  /**\r\n   * @classdesc\r\n   * Wraps a jCal component, adding convenience methods to add, remove and\r\n   * update subcomponents and properties.\r\n   *\r\n   * @class\r\n   * @alias ICAL.Component\r\n   * @param {Array|String} jCal         Raw jCal component data OR name of new\r\n   *                                      component\r\n   * @param {ICAL.Component} parent     Parent component to associate\r\n   */\r\n  function Component(jCal, parent) {\r\n    if (typeof(jCal) === 'string') {\r\n      // jCal spec (name, properties, components)\r\n      jCal = [jCal, [], []];\r\n    }\r\n\r\n    // mostly for legacy reasons.\r\n    this.jCal = jCal;\r\n\r\n    this.parent = parent || null;\r\n  }\r\n\r\n  Component.prototype = {\r\n    /**\r\n     * Hydrated properties are inserted into the _properties array at the same\r\n     * position as in the jCal array, so its possible the array contains\r\n     * undefined values for unhydrdated properties. To avoid iterating the\r\n     * array when checking if all properties have been hydrated, we save the\r\n     * count here.\r\n     *\r\n     * @type {Number}\r\n     * @private\r\n     */\r\n    _hydratedPropertyCount: 0,\r\n\r\n    /**\r\n     * The same count as for _hydratedPropertyCount, but for subcomponents\r\n     *\r\n     * @type {Number}\r\n     * @private\r\n     */\r\n    _hydratedComponentCount: 0,\r\n\r\n    /**\r\n     * The name of this component\r\n     * @readonly\r\n     */\r\n    get name() {\r\n      return this.jCal[NAME_INDEX];\r\n    },\r\n\r\n    /**\r\n     * The design set for this component, e.g. icalendar vs vcard\r\n     *\r\n     * @type {ICAL.design.designSet}\r\n     * @private\r\n     */\r\n    get _designSet() {\r\n      var parentDesign = this.parent && this.parent._designSet;\r\n      return parentDesign || ICAL.design.getDesignSet(this.name);\r\n    },\r\n\r\n    _hydrateComponent: function(index) {\r\n      if (!this._components) {\r\n        this._components = [];\r\n        this._hydratedComponentCount = 0;\r\n      }\r\n\r\n      if (this._components[index]) {\r\n        return this._components[index];\r\n      }\r\n\r\n      var comp = new Component(\r\n        this.jCal[COMPONENT_INDEX][index],\r\n        this\r\n      );\r\n\r\n      this._hydratedComponentCount++;\r\n      return (this._components[index] = comp);\r\n    },\r\n\r\n    _hydrateProperty: function(index) {\r\n      if (!this._properties) {\r\n        this._properties = [];\r\n        this._hydratedPropertyCount = 0;\r\n      }\r\n\r\n      if (this._properties[index]) {\r\n        return this._properties[index];\r\n      }\r\n\r\n      var prop = new ICAL.Property(\r\n        this.jCal[PROPERTY_INDEX][index],\r\n        this\r\n      );\r\n\r\n      this._hydratedPropertyCount++;\r\n      return (this._properties[index] = prop);\r\n    },\r\n\r\n    /**\r\n     * Finds first sub component, optionally filtered by name.\r\n     *\r\n     * @param {String=} name        Optional name to filter by\r\n     * @return {?ICAL.Component}     The found subcomponent\r\n     */\r\n    getFirstSubcomponent: function(name) {\r\n      if (name) {\r\n        var i = 0;\r\n        var comps = this.jCal[COMPONENT_INDEX];\r\n        var len = comps.length;\r\n\r\n        for (; i < len; i++) {\r\n          if (comps[i][NAME_INDEX] === name) {\r\n            var result = this._hydrateComponent(i);\r\n            return result;\r\n          }\r\n        }\r\n      } else {\r\n        if (this.jCal[COMPONENT_INDEX].length) {\r\n          return this._hydrateComponent(0);\r\n        }\r\n      }\r\n\r\n      // ensure we return a value (strict mode)\r\n      return null;\r\n    },\r\n\r\n    /**\r\n     * Finds all sub components, optionally filtering by name.\r\n     *\r\n     * @param {String=} name            Optional name to filter by\r\n     * @return {ICAL.Component[]}       The found sub components\r\n     */\r\n    getAllSubcomponents: function(name) {\r\n      var jCalLen = this.jCal[COMPONENT_INDEX].length;\r\n      var i = 0;\r\n\r\n      if (name) {\r\n        var comps = this.jCal[COMPONENT_INDEX];\r\n        var result = [];\r\n\r\n        for (; i < jCalLen; i++) {\r\n          if (name === comps[i][NAME_INDEX]) {\r\n            result.push(\r\n              this._hydrateComponent(i)\r\n            );\r\n          }\r\n        }\r\n        return result;\r\n      } else {\r\n        if (!this._components ||\r\n            (this._hydratedComponentCount !== jCalLen)) {\r\n          for (; i < jCalLen; i++) {\r\n            this._hydrateComponent(i);\r\n          }\r\n        }\r\n\r\n        return this._components || [];\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Returns true when a named property exists.\r\n     *\r\n     * @param {String} name     The property name\r\n     * @return {Boolean}        True, when property is found\r\n     */\r\n    hasProperty: function(name) {\r\n      var props = this.jCal[PROPERTY_INDEX];\r\n      var len = props.length;\r\n\r\n      var i = 0;\r\n      for (; i < len; i++) {\r\n        // 0 is property name\r\n        if (props[i][NAME_INDEX] === name) {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      return false;\r\n    },\r\n\r\n    /**\r\n     * Finds the first property, optionally with the given name.\r\n     *\r\n     * @param {String=} name        Lowercase property name\r\n     * @return {?ICAL.Property}     The found property\r\n     */\r\n    getFirstProperty: function(name) {\r\n      if (name) {\r\n        var i = 0;\r\n        var props = this.jCal[PROPERTY_INDEX];\r\n        var len = props.length;\r\n\r\n        for (; i < len; i++) {\r\n          if (props[i][NAME_INDEX] === name) {\r\n            var result = this._hydrateProperty(i);\r\n            return result;\r\n          }\r\n        }\r\n      } else {\r\n        if (this.jCal[PROPERTY_INDEX].length) {\r\n          return this._hydrateProperty(0);\r\n        }\r\n      }\r\n\r\n      return null;\r\n    },\r\n\r\n    /**\r\n     * Returns first property's value, if available.\r\n     *\r\n     * @param {String=} name    Lowercase property name\r\n     * @return {?String}        The found property value.\r\n     */\r\n    getFirstPropertyValue: function(name) {\r\n      var prop = this.getFirstProperty(name);\r\n      if (prop) {\r\n        return prop.getFirstValue();\r\n      }\r\n\r\n      return null;\r\n    },\r\n\r\n    /**\r\n     * Get all properties in the component, optionally filtered by name.\r\n     *\r\n     * @param {String=} name        Lowercase property name\r\n     * @return {ICAL.Property[]}    List of properties\r\n     */\r\n    getAllProperties: function(name) {\r\n      var jCalLen = this.jCal[PROPERTY_INDEX].length;\r\n      var i = 0;\r\n\r\n      if (name) {\r\n        var props = this.jCal[PROPERTY_INDEX];\r\n        var result = [];\r\n\r\n        for (; i < jCalLen; i++) {\r\n          if (name === props[i][NAME_INDEX]) {\r\n            result.push(\r\n              this._hydrateProperty(i)\r\n            );\r\n          }\r\n        }\r\n        return result;\r\n      } else {\r\n        if (!this._properties ||\r\n            (this._hydratedPropertyCount !== jCalLen)) {\r\n          for (; i < jCalLen; i++) {\r\n            this._hydrateProperty(i);\r\n          }\r\n        }\r\n\r\n        return this._properties || [];\r\n      }\r\n    },\r\n\r\n    _removeObjectByIndex: function(jCalIndex, cache, index) {\r\n      cache = cache || [];\r\n      // remove cached version\r\n      if (cache[index]) {\r\n        var obj = cache[index];\r\n        if (\"parent\" in obj) {\r\n            obj.parent = null;\r\n        }\r\n      }\r\n\r\n      cache.splice(index, 1);\r\n\r\n      // remove it from the jCal\r\n      this.jCal[jCalIndex].splice(index, 1);\r\n    },\r\n\r\n    _removeObject: function(jCalIndex, cache, nameOrObject) {\r\n      var i = 0;\r\n      var objects = this.jCal[jCalIndex];\r\n      var len = objects.length;\r\n      var cached = this[cache];\r\n\r\n      if (typeof(nameOrObject) === 'string') {\r\n        for (; i < len; i++) {\r\n          if (objects[i][NAME_INDEX] === nameOrObject) {\r\n            this._removeObjectByIndex(jCalIndex, cached, i);\r\n            return true;\r\n          }\r\n        }\r\n      } else if (cached) {\r\n        for (; i < len; i++) {\r\n          if (cached[i] && cached[i] === nameOrObject) {\r\n            this._removeObjectByIndex(jCalIndex, cached, i);\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n\r\n      return false;\r\n    },\r\n\r\n    _removeAllObjects: function(jCalIndex, cache, name) {\r\n      var cached = this[cache];\r\n\r\n      // Unfortunately we have to run through all children to reset their\r\n      // parent property.\r\n      var objects = this.jCal[jCalIndex];\r\n      var i = objects.length - 1;\r\n\r\n      // descending search required because splice\r\n      // is used and will effect the indices.\r\n      for (; i >= 0; i--) {\r\n        if (!name || objects[i][NAME_INDEX] === name) {\r\n          this._removeObjectByIndex(jCalIndex, cached, i);\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Adds a single sub component.\r\n     *\r\n     * @param {ICAL.Component} component        The component to add\r\n     * @return {ICAL.Component}                 The passed in component\r\n     */\r\n    addSubcomponent: function(component) {\r\n      if (!this._components) {\r\n        this._components = [];\r\n        this._hydratedComponentCount = 0;\r\n      }\r\n\r\n      if (component.parent) {\r\n        component.parent.removeSubcomponent(component);\r\n      }\r\n\r\n      var idx = this.jCal[COMPONENT_INDEX].push(component.jCal);\r\n      this._components[idx - 1] = component;\r\n      this._hydratedComponentCount++;\r\n      component.parent = this;\r\n      return component;\r\n    },\r\n\r\n    /**\r\n     * Removes a single component by name or the instance of a specific\r\n     * component.\r\n     *\r\n     * @param {ICAL.Component|String} nameOrComp    Name of component, or component\r\n     * @return {Boolean}                            True when comp is removed\r\n     */\r\n    removeSubcomponent: function(nameOrComp) {\r\n      var removed = this._removeObject(COMPONENT_INDEX, '_components', nameOrComp);\r\n      if (removed) {\r\n        this._hydratedComponentCount--;\r\n      }\r\n      return removed;\r\n    },\r\n\r\n    /**\r\n     * Removes all components or (if given) all components by a particular\r\n     * name.\r\n     *\r\n     * @param {String=} name            Lowercase component name\r\n     */\r\n    removeAllSubcomponents: function(name) {\r\n      var removed = this._removeAllObjects(COMPONENT_INDEX, '_components', name);\r\n      this._hydratedComponentCount = 0;\r\n      return removed;\r\n    },\r\n\r\n    /**\r\n     * Adds an {@link ICAL.Property} to the component.\r\n     *\r\n     * @param {ICAL.Property} property      The property to add\r\n     * @return {ICAL.Property}              The passed in property\r\n     */\r\n    addProperty: function(property) {\r\n      if (!(property instanceof ICAL.Property)) {\r\n        throw new TypeError('must instance of ICAL.Property');\r\n      }\r\n\r\n      if (!this._properties) {\r\n        this._properties = [];\r\n        this._hydratedPropertyCount = 0;\r\n      }\r\n\r\n      if (property.parent) {\r\n        property.parent.removeProperty(property);\r\n      }\r\n\r\n      var idx = this.jCal[PROPERTY_INDEX].push(property.jCal);\r\n      this._properties[idx - 1] = property;\r\n      this._hydratedPropertyCount++;\r\n      property.parent = this;\r\n      return property;\r\n    },\r\n\r\n    /**\r\n     * Helper method to add a property with a value to the component.\r\n     *\r\n     * @param {String}               name         Property name to add\r\n     * @param {String|Number|Object} value        Property value\r\n     * @return {ICAL.Property}                    The created property\r\n     */\r\n    addPropertyWithValue: function(name, value) {\r\n      var prop = new ICAL.Property(name);\r\n      prop.setValue(value);\r\n\r\n      this.addProperty(prop);\r\n\r\n      return prop;\r\n    },\r\n\r\n    /**\r\n     * Helper method that will update or create a property of the given name\r\n     * and sets its value. If multiple properties with the given name exist,\r\n     * only the first is updated.\r\n     *\r\n     * @param {String}               name         Property name to update\r\n     * @param {String|Number|Object} value        Property value\r\n     * @return {ICAL.Property}                    The created property\r\n     */\r\n    updatePropertyWithValue: function(name, value) {\r\n      var prop = this.getFirstProperty(name);\r\n\r\n      if (prop) {\r\n        prop.setValue(value);\r\n      } else {\r\n        prop = this.addPropertyWithValue(name, value);\r\n      }\r\n\r\n      return prop;\r\n    },\r\n\r\n    /**\r\n     * Removes a single property by name or the instance of the specific\r\n     * property.\r\n     *\r\n     * @param {String|ICAL.Property} nameOrProp     Property name or instance to remove\r\n     * @return {Boolean}                            True, when deleted\r\n     */\r\n    removeProperty: function(nameOrProp) {\r\n      var removed = this._removeObject(PROPERTY_INDEX, '_properties', nameOrProp);\r\n      if (removed) {\r\n        this._hydratedPropertyCount--;\r\n      }\r\n      return removed;\r\n    },\r\n\r\n    /**\r\n     * Removes all properties associated with this component, optionally\r\n     * filtered by name.\r\n     *\r\n     * @param {String=} name        Lowercase property name\r\n     * @return {Boolean}            True, when deleted\r\n     */\r\n    removeAllProperties: function(name) {\r\n      var removed = this._removeAllObjects(PROPERTY_INDEX, '_properties', name);\r\n      this._hydratedPropertyCount = 0;\r\n      return removed;\r\n    },\r\n\r\n    /**\r\n     * Returns the Object representation of this component. The returned object\r\n     * is a live jCal object and should be cloned if modified.\r\n     * @return {Object}\r\n     */\r\n    toJSON: function() {\r\n      return this.jCal;\r\n    },\r\n\r\n    /**\r\n     * The string representation of this component.\r\n     * @return {String}\r\n     */\r\n    toString: function() {\r\n      return ICAL.stringify.component(\r\n        this.jCal, this._designSet\r\n      );\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Create an {@link ICAL.Component} by parsing the passed iCalendar string.\r\n   *\r\n   * @param {String} str        The iCalendar string to parse\r\n   */\r\n  Component.fromString = function(str) {\r\n    return new Component(ICAL.parse.component(str));\r\n  };\r\n\r\n  return Component;\r\n}());\r\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\r\n\r\n\r\n/**\r\n * This symbol is further described later on\r\n * @ignore\r\n */\r\nICAL.Property = (function() {\r\n  'use strict';\r\n\r\n  var NAME_INDEX = 0;\r\n  var PROP_INDEX = 1;\r\n  var TYPE_INDEX = 2;\r\n  var VALUE_INDEX = 3;\r\n\r\n  var design = ICAL.design;\r\n\r\n  /**\r\n   * @classdesc\r\n   * Provides a layer on top of the raw jCal object for manipulating a single\r\n   * property, with its parameters and value.\r\n   *\r\n   * @description\r\n   * Its important to note that mutations done in the wrapper\r\n   * directly mutate the jCal object used to initialize.\r\n   *\r\n   * Can also be used to create new properties by passing\r\n   * the name of the property (as a String).\r\n   *\r\n   * @class\r\n   * @alias ICAL.Property\r\n   * @param {Array|String} jCal         Raw jCal representation OR\r\n   *  the new name of the property\r\n   *\r\n   * @param {ICAL.Component=} parent    Parent component\r\n   */\r\n  function Property(jCal, parent) {\r\n    this._parent = parent || null;\r\n\r\n    if (typeof(jCal) === 'string') {\r\n      // We are creating the property by name and need to detect the type\r\n      this.jCal = [jCal, {}, design.defaultType];\r\n      this.jCal[TYPE_INDEX] = this.getDefaultType();\r\n    } else {\r\n      this.jCal = jCal;\r\n    }\r\n    this._updateType();\r\n  }\r\n\r\n  Property.prototype = {\r\n\r\n    /**\r\n     * The value type for this property\r\n     * @readonly\r\n     * @type {String}\r\n     */\r\n    get type() {\r\n      return this.jCal[TYPE_INDEX];\r\n    },\r\n\r\n    /**\r\n     * The name of this property, in lowercase.\r\n     * @readonly\r\n     * @type {String}\r\n     */\r\n    get name() {\r\n      return this.jCal[NAME_INDEX];\r\n    },\r\n\r\n    /**\r\n     * The parent component for this property.\r\n     * @type {ICAL.Component}\r\n     */\r\n    get parent() {\r\n      return this._parent;\r\n    },\r\n\r\n    set parent(p) {\r\n      // Before setting the parent, check if the design set has changed. If it\r\n      // has, we later need to update the type if it was unknown before.\r\n      var designSetChanged = !this._parent || (p && p._designSet != this._parent._designSet);\r\n\r\n      this._parent = p;\r\n\r\n      if (this.type == design.defaultType && designSetChanged) {\r\n        this.jCal[TYPE_INDEX] = this.getDefaultType();\r\n        this._updateType();\r\n      }\r\n\r\n      return p;\r\n    },\r\n\r\n    /**\r\n     * The design set for this property, e.g. icalendar vs vcard\r\n     *\r\n     * @type {ICAL.design.designSet}\r\n     * @private\r\n     */\r\n    get _designSet() {\r\n      return this.parent ? this.parent._designSet : design.defaultSet;\r\n    },\r\n\r\n    /**\r\n     * Updates the type metadata from the current jCal type and design set.\r\n     *\r\n     * @private\r\n     */\r\n    _updateType: function() {\r\n      var designSet = this._designSet;\r\n\r\n      if (this.type in designSet.value) {\r\n        var designType = designSet.value[this.type];\r\n\r\n        if ('decorate' in designSet.value[this.type]) {\r\n          this.isDecorated = true;\r\n        } else {\r\n          this.isDecorated = false;\r\n        }\r\n\r\n        if (this.name in designSet.property) {\r\n          this.isMultiValue = ('multiValue' in designSet.property[this.name]);\r\n          this.isStructuredValue = ('structuredValue' in designSet.property[this.name]);\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Hydrate a single value. The act of hydrating means turning the raw jCal\r\n     * value into a potentially wrapped object, for example {@link ICAL.Time}.\r\n     *\r\n     * @private\r\n     * @param {Number} index        The index of the value to hydrate\r\n     * @return {Object}             The decorated value.\r\n     */\r\n    _hydrateValue: function(index) {\r\n      if (this._values && this._values[index]) {\r\n        return this._values[index];\r\n      }\r\n\r\n      // for the case where there is no value.\r\n      if (this.jCal.length <= (VALUE_INDEX + index)) {\r\n        return null;\r\n      }\r\n\r\n      if (this.isDecorated) {\r\n        if (!this._values) {\r\n          this._values = [];\r\n        }\r\n        return (this._values[index] = this._decorate(\r\n          this.jCal[VALUE_INDEX + index]\r\n        ));\r\n      } else {\r\n        return this.jCal[VALUE_INDEX + index];\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Decorate a single value, returning its wrapped object. This is used by\r\n     * the hydrate function to actually wrap the value.\r\n     *\r\n     * @private\r\n     * @param {?} value         The value to decorate\r\n     * @return {Object}         The decorated value\r\n     */\r\n    _decorate: function(value) {\r\n      return this._designSet.value[this.type].decorate(value, this);\r\n    },\r\n\r\n    /**\r\n     * Undecorate a single value, returning its raw jCal data.\r\n     *\r\n     * @private\r\n     * @param {Object} value         The value to undecorate\r\n     * @return {?}                   The undecorated value\r\n     */\r\n    _undecorate: function(value) {\r\n      return this._designSet.value[this.type].undecorate(value, this);\r\n    },\r\n\r\n    /**\r\n     * Sets the value at the given index while also hydrating it. The passed\r\n     * value can either be a decorated or undecorated value.\r\n     *\r\n     * @private\r\n     * @param {?} value             The value to set\r\n     * @param {Number} index        The index to set it at\r\n     */\r\n    _setDecoratedValue: function(value, index) {\r\n      if (!this._values) {\r\n        this._values = [];\r\n      }\r\n\r\n      if (typeof(value) === 'object' && 'icaltype' in value) {\r\n        // decorated value\r\n        this.jCal[VALUE_INDEX + index] = this._undecorate(value);\r\n        this._values[index] = value;\r\n      } else {\r\n        // undecorated value\r\n        this.jCal[VALUE_INDEX + index] = value;\r\n        this._values[index] = this._decorate(value);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Gets a parameter on the property.\r\n     *\r\n     * @param {String}        name   Property name (lowercase)\r\n     * @return {Array|String}        Property value\r\n     */\r\n    getParameter: function(name) {\r\n      if (name in this.jCal[PROP_INDEX]) {\r\n        return this.jCal[PROP_INDEX][name];\r\n      } else {\r\n        return undefined;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Gets first parameter on the property.\r\n     *\r\n     * @param {String}        name   Property name (lowercase)\r\n     * @return {String}        Property value\r\n     */\r\n    getFirstParameter: function(name) {\r\n      var parameters = this.getParameter(name);\r\n\r\n      if (Array.isArray(parameters)) {\r\n        return parameters[0];\r\n      }\r\n\r\n      return parameters;\r\n    },\r\n\r\n    /**\r\n     * Sets a parameter on the property.\r\n     *\r\n     * @param {String}       name     The parameter name\r\n     * @param {Array|String} value    The parameter value\r\n     */\r\n    setParameter: function(name, value) {\r\n      var lcname = name.toLowerCase();\r\n      if (typeof value === \"string\" &&\r\n          lcname in this._designSet.param &&\r\n          'multiValue' in this._designSet.param[lcname]) {\r\n          value = [value];\r\n      }\r\n      this.jCal[PROP_INDEX][name] = value;\r\n    },\r\n\r\n    /**\r\n     * Removes a parameter\r\n     *\r\n     * @param {String} name     The parameter name\r\n     */\r\n    removeParameter: function(name) {\r\n      delete this.jCal[PROP_INDEX][name];\r\n    },\r\n\r\n    /**\r\n     * Get the default type based on this property's name.\r\n     *\r\n     * @return {String}     The default type for this property\r\n     */\r\n    getDefaultType: function() {\r\n      var name = this.jCal[NAME_INDEX];\r\n      var designSet = this._designSet;\r\n\r\n      if (name in designSet.property) {\r\n        var details = designSet.property[name];\r\n        if ('defaultType' in details) {\r\n          return details.defaultType;\r\n        }\r\n      }\r\n      return design.defaultType;\r\n    },\r\n\r\n    /**\r\n     * Sets type of property and clears out any existing values of the current\r\n     * type.\r\n     *\r\n     * @param {String} type     New iCAL type (see design.*.values)\r\n     */\r\n    resetType: function(type) {\r\n      this.removeAllValues();\r\n      this.jCal[TYPE_INDEX] = type;\r\n      this._updateType();\r\n    },\r\n\r\n    /**\r\n     * Finds the first property value.\r\n     *\r\n     * @return {String}         First property value\r\n     */\r\n    getFirstValue: function() {\r\n      return this._hydrateValue(0);\r\n    },\r\n\r\n    /**\r\n     * Gets all values on the property.\r\n     *\r\n     * NOTE: this creates an array during each call.\r\n     *\r\n     * @return {Array}          List of values\r\n     */\r\n    getValues: function() {\r\n      var len = this.jCal.length - VALUE_INDEX;\r\n\r\n      if (len < 1) {\r\n        // its possible for a property to have no value.\r\n        return [];\r\n      }\r\n\r\n      var i = 0;\r\n      var result = [];\r\n\r\n      for (; i < len; i++) {\r\n        result[i] = this._hydrateValue(i);\r\n      }\r\n\r\n      return result;\r\n    },\r\n\r\n    /**\r\n     * Removes all values from this property\r\n     */\r\n    removeAllValues: function() {\r\n      if (this._values) {\r\n        this._values.length = 0;\r\n      }\r\n      this.jCal.length = 3;\r\n    },\r\n\r\n    /**\r\n     * Sets the values of the property.  Will overwrite the existing values.\r\n     * This can only be used for multi-value properties.\r\n     *\r\n     * @param {Array} values    An array of values\r\n     */\r\n    setValues: function(values) {\r\n      if (!this.isMultiValue) {\r\n        throw new Error(\r\n          this.name + ': does not not support mulitValue.\\n' +\r\n          'override isMultiValue'\r\n        );\r\n      }\r\n\r\n      var len = values.length;\r\n      var i = 0;\r\n      this.removeAllValues();\r\n\r\n      if (len > 0 &&\r\n          typeof(values[0]) === 'object' &&\r\n          'icaltype' in values[0]) {\r\n        this.resetType(values[0].icaltype);\r\n      }\r\n\r\n      if (this.isDecorated) {\r\n        for (; i < len; i++) {\r\n          this._setDecoratedValue(values[i], i);\r\n        }\r\n      } else {\r\n        for (; i < len; i++) {\r\n          this.jCal[VALUE_INDEX + i] = values[i];\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Sets the current value of the property. If this is a multi-value\r\n     * property, all other values will be removed.\r\n     *\r\n     * @param {String|Object} value     New property value.\r\n     */\r\n    setValue: function(value) {\r\n      this.removeAllValues();\r\n      if (typeof(value) === 'object' && 'icaltype' in value) {\r\n        this.resetType(value.icaltype);\r\n      }\r\n\r\n      if (this.isDecorated) {\r\n        this._setDecoratedValue(value, 0);\r\n      } else {\r\n        this.jCal[VALUE_INDEX] = value;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Returns the Object representation of this component. The returned object\r\n     * is a live jCal object and should be cloned if modified.\r\n     * @return {Object}\r\n     */\r\n    toJSON: function() {\r\n      return this.jCal;\r\n    },\r\n\r\n    /**\r\n     * The string representation of this component.\r\n     * @return {String}\r\n     */\r\n    toICALString: function() {\r\n      return ICAL.stringify.property(\r\n        this.jCal, this._designSet, true\r\n      );\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Create an {@link ICAL.Property} by parsing the passed iCalendar string.\r\n   *\r\n   * @param {String} str                        The iCalendar string to parse\r\n   * @param {ICAL.design.designSet=} designSet  The design data to use for this property\r\n   * @return {ICAL.Property}                    The created iCalendar property\r\n   */\r\n  Property.fromString = function(str, designSet) {\r\n    return new Property(ICAL.parse.property(str, designSet));\r\n  };\r\n\r\n  return Property;\r\n}());\r\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\r\n\r\n\r\n/**\r\n * This symbol is further described later on\r\n * @ignore\r\n */\r\nICAL.UtcOffset = (function() {\r\n\r\n  /**\r\n   * @classdesc\r\n   * This class represents the \"duration\" value type, with various calculation\r\n   * and manipulation methods.\r\n   *\r\n   * @class\r\n   * @alias ICAL.UtcOffset\r\n   * @param {Object} aData          An object with members of the utc offset\r\n   * @param {Number=} aData.hours   The hours for the utc offset\r\n   * @param {Number=} aData.minutes The minutes in the utc offset\r\n   * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\r\n   */\r\n  function UtcOffset(aData) {\r\n    this.fromData(aData);\r\n  }\r\n\r\n  UtcOffset.prototype = {\r\n\r\n    /**\r\n     * The hours in the utc-offset\r\n     * @type {Number}\r\n     */\r\n    hours: 0,\r\n\r\n    /**\r\n     * The minutes in the utc-offset\r\n     * @type {Number}\r\n     */\r\n    minutes: 0,\r\n\r\n    /**\r\n     * The sign of the utc offset, 1 for positive offset, -1 for negative\r\n     * offsets.\r\n     * @type {Number}\r\n     */\r\n    factor: 1,\r\n\r\n    /**\r\n     * The type name, to be used in the jCal object.\r\n     * @constant\r\n     * @type {String}\r\n     * @default \"utc-offset\"\r\n     */\r\n    icaltype: \"utc-offset\",\r\n\r\n    /**\r\n     * Returns a clone of the utc offset object.\r\n     *\r\n     * @return {ICAL.UtcOffset}     The cloned object\r\n     */\r\n    clone: function() {\r\n      return ICAL.UtcOffset.fromSeconds(this.toSeconds());\r\n    },\r\n\r\n    /**\r\n     * Sets up the current instance using members from the passed data object.\r\n     *\r\n     * @param {Object} aData          An object with members of the utc offset\r\n     * @param {Number=} aData.hours   The hours for the utc offset\r\n     * @param {Number=} aData.minutes The minutes in the utc offset\r\n     * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1\r\n     */\r\n    fromData: function(aData) {\r\n      if (aData) {\r\n        for (var key in aData) {\r\n          /* istanbul ignore else */\r\n          if (aData.hasOwnProperty(key)) {\r\n            this[key] = aData[key];\r\n          }\r\n        }\r\n      }\r\n      this._normalize();\r\n    },\r\n\r\n    /**\r\n     * Sets up the current instance from the given seconds value. The seconds\r\n     * value is truncated to the minute. Offsets are wrapped when the world\r\n     * ends, the hour after UTC+14:00 is UTC-12:00.\r\n     *\r\n     * @param {Number} aSeconds         The seconds to convert into an offset\r\n     */\r\n    fromSeconds: function(aSeconds) {\r\n      var secs = Math.abs(aSeconds);\r\n\r\n      this.factor = aSeconds < 0 ? -1 : 1;\r\n      this.hours = ICAL.helpers.trunc(secs / 3600);\r\n\r\n      secs -= (this.hours * 3600);\r\n      this.minutes = ICAL.helpers.trunc(secs / 60);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Convert the current offset to a value in seconds\r\n     *\r\n     * @return {Number}                 The offset in seconds\r\n     */\r\n    toSeconds: function() {\r\n      return this.factor * (60 * this.minutes + 3600 * this.hours);\r\n    },\r\n\r\n    /**\r\n     * Compare this utc offset with another one.\r\n     *\r\n     * @param {ICAL.UtcOffset} other        The other offset to compare with\r\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\r\n     */\r\n    compare: function icaltime_compare(other) {\r\n      var a = this.toSeconds();\r\n      var b = other.toSeconds();\r\n      return (a > b) - (b > a);\r\n    },\r\n\r\n    _normalize: function() {\r\n      // Range: 97200 seconds (with 1 hour inbetween)\r\n      var secs = this.toSeconds();\r\n      var factor = this.factor;\r\n      while (secs < -43200) { // = UTC-12:00\r\n        secs += 97200;\r\n      }\r\n      while (secs > 50400) { // = UTC+14:00\r\n        secs -= 97200;\r\n      }\r\n\r\n      this.fromSeconds(secs);\r\n\r\n      // Avoid changing the factor when on zero seconds\r\n      if (secs == 0) {\r\n        this.factor = factor;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * The iCalendar string representation of this utc-offset.\r\n     * @return {String}\r\n     */\r\n    toICALString: function() {\r\n      return ICAL.design.icalendar.value['utc-offset'].toICAL(this.toString());\r\n    },\r\n\r\n    /**\r\n     * The string representation of this utc-offset.\r\n     * @return {String}\r\n     */\r\n    toString: function toString() {\r\n      return (this.factor == 1 ? \"+\" : \"-\") +\r\n              ICAL.helpers.pad2(this.hours) + ':' +\r\n              ICAL.helpers.pad2(this.minutes);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed string.\r\n   *\r\n   * @param {String} aString    The string to parse\r\n   * @return {ICAL.Duration}    The created utc-offset instance\r\n   */\r\n  UtcOffset.fromString = function(aString) {\r\n    // -05:00\r\n    var options = {};\r\n    //TODO: support seconds per rfc5545 ?\r\n    options.factor = (aString[0] === '+') ? 1 : -1;\r\n    options.hours = ICAL.helpers.strictParseInt(aString.substr(1, 2));\r\n    options.minutes = ICAL.helpers.strictParseInt(aString.substr(4, 2));\r\n\r\n    return new ICAL.UtcOffset(options);\r\n  };\r\n\r\n  /**\r\n   * Creates a new {@link ICAL.UtcOffset} instance from the passed seconds\r\n   * value.\r\n   *\r\n   * @param {Number} aSeconds       The number of seconds to convert\r\n   */\r\n  UtcOffset.fromSeconds = function(aSeconds) {\r\n    var instance = new UtcOffset();\r\n    instance.fromSeconds(aSeconds);\r\n    return instance;\r\n  };\r\n\r\n  return UtcOffset;\r\n}());\r\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\r\n\r\n\r\n/**\r\n * This symbol is further described later on\r\n * @ignore\r\n */\r\nICAL.Binary = (function() {\r\n\r\n  /**\r\n   * @classdesc\r\n   * Represents the BINARY value type, which contains extra methods for\r\n   * encoding and decoding.\r\n   *\r\n   * @class\r\n   * @alias ICAL.Binary\r\n   * @param {String} aValue     The binary data for this value\r\n   */\r\n  function Binary(aValue) {\r\n    this.value = aValue;\r\n  }\r\n\r\n  Binary.prototype = {\r\n    /**\r\n     * The type name, to be used in the jCal object.\r\n     * @default \"binary\"\r\n     * @constant\r\n     */\r\n    icaltype: \"binary\",\r\n\r\n    /**\r\n     * Base64 decode the current value\r\n     *\r\n     * @return {String}         The base64-decoded value\r\n     */\r\n    decodeValue: function decodeValue() {\r\n      return this._b64_decode(this.value);\r\n    },\r\n\r\n    /**\r\n     * Encodes the passed parameter with base64 and sets the internal\r\n     * value to the result.\r\n     *\r\n     * @param {String} aValue      The raw binary value to encode\r\n     */\r\n    setEncodedValue: function setEncodedValue(aValue) {\r\n      this.value = this._b64_encode(aValue);\r\n    },\r\n\r\n    _b64_encode: function base64_encode(data) {\r\n      // http://kevin.vanzonneveld.net\r\n      // +   original by: Tyler Akins (http://rumkin.com)\r\n      // +   improved by: Bayron Guevara\r\n      // +   improved by: Thunder.m\r\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\r\n      // +   bugfixed by: Pellentesque Malesuada\r\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\r\n      // +   improved by: Rafał Kukawski (http://kukawski.pl)\r\n      // *     example 1: base64_encode('Kevin van Zonneveld');\r\n      // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='\r\n      // mozilla has this native\r\n      // - but breaks in 2.0.0.12!\r\n      //if (typeof this.window['atob'] == 'function') {\r\n      //    return atob(data);\r\n      //}\r\n      var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\r\n                \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\r\n      var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,\r\n        ac = 0,\r\n        enc = \"\",\r\n        tmp_arr = [];\r\n\r\n      if (!data) {\r\n        return data;\r\n      }\r\n\r\n      do { // pack three octets into four hexets\r\n        o1 = data.charCodeAt(i++);\r\n        o2 = data.charCodeAt(i++);\r\n        o3 = data.charCodeAt(i++);\r\n\r\n        bits = o1 << 16 | o2 << 8 | o3;\r\n\r\n        h1 = bits >> 18 & 0x3f;\r\n        h2 = bits >> 12 & 0x3f;\r\n        h3 = bits >> 6 & 0x3f;\r\n        h4 = bits & 0x3f;\r\n\r\n        // use hexets to index into b64, and append result to encoded string\r\n        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\r\n      } while (i < data.length);\r\n\r\n      enc = tmp_arr.join('');\r\n\r\n      var r = data.length % 3;\r\n\r\n      return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);\r\n\r\n    },\r\n\r\n    _b64_decode: function base64_decode(data) {\r\n      // http://kevin.vanzonneveld.net\r\n      // +   original by: Tyler Akins (http://rumkin.com)\r\n      // +   improved by: Thunder.m\r\n      // +      input by: Aman Gupta\r\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\r\n      // +   bugfixed by: Onno Marsman\r\n      // +   bugfixed by: Pellentesque Malesuada\r\n      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\r\n      // +      input by: Brett Zamir (http://brett-zamir.me)\r\n      // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\r\n      // *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');\r\n      // *     returns 1: 'Kevin van Zonneveld'\r\n      // mozilla has this native\r\n      // - but breaks in 2.0.0.12!\r\n      //if (typeof this.window['btoa'] == 'function') {\r\n      //    return btoa(data);\r\n      //}\r\n      var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\r\n                \"abcdefghijklmnopqrstuvwxyz0123456789+/=\";\r\n      var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,\r\n        ac = 0,\r\n        dec = \"\",\r\n        tmp_arr = [];\r\n\r\n      if (!data) {\r\n        return data;\r\n      }\r\n\r\n      data += '';\r\n\r\n      do { // unpack four hexets into three octets using index points in b64\r\n        h1 = b64.indexOf(data.charAt(i++));\r\n        h2 = b64.indexOf(data.charAt(i++));\r\n        h3 = b64.indexOf(data.charAt(i++));\r\n        h4 = b64.indexOf(data.charAt(i++));\r\n\r\n        bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\r\n\r\n        o1 = bits >> 16 & 0xff;\r\n        o2 = bits >> 8 & 0xff;\r\n        o3 = bits & 0xff;\r\n\r\n        if (h3 == 64) {\r\n          tmp_arr[ac++] = String.fromCharCode(o1);\r\n        } else if (h4 == 64) {\r\n          tmp_arr[ac++] = String.fromCharCode(o1, o2);\r\n        } else {\r\n          tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);\r\n        }\r\n      } while (i < data.length);\r\n\r\n      dec = tmp_arr.join('');\r\n\r\n      return dec;\r\n    },\r\n\r\n    /**\r\n     * The string representation of this value\r\n     * @return {String}\r\n     */\r\n    toString: function() {\r\n      return this.value;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Creates a binary value from the given string.\r\n   *\r\n   * @param {String} aString        The binary value string\r\n   * @return {ICAL.Binary}          The binary value instance\r\n   */\r\n  Binary.fromString = function(aString) {\r\n    return new Binary(aString);\r\n  };\r\n\r\n  return Binary;\r\n}());\r\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\r\n\r\n\r\n\r\n(function() {\r\n  /**\r\n   * @classdesc\r\n   * This class represents the \"period\" value type, with various calculation\r\n   * and manipulation methods.\r\n   *\r\n   * @description\r\n   * The passed data object cannot contain both and end date and a duration.\r\n   *\r\n   * @class\r\n   * @param {Object} aData                  An object with members of the period\r\n   * @param {ICAL.Time=} aData.start        The start of the period\r\n   * @param {ICAL.Time=} aData.end          The end of the period\r\n   * @param {ICAL.Duration=} aData.duration The duration of the period\r\n   */\r\n  ICAL.Period = function icalperiod(aData) {\r\n    this.wrappedJSObject = this;\r\n\r\n    if (aData && 'start' in aData) {\r\n      if (aData.start && !(aData.start instanceof ICAL.Time)) {\r\n        throw new TypeError('.start must be an instance of ICAL.Time');\r\n      }\r\n      this.start = aData.start;\r\n    }\r\n\r\n    if (aData && aData.end && aData.duration) {\r\n      throw new Error('cannot accept both end and duration');\r\n    }\r\n\r\n    if (aData && 'end' in aData) {\r\n      if (aData.end && !(aData.end instanceof ICAL.Time)) {\r\n        throw new TypeError('.end must be an instance of ICAL.Time');\r\n      }\r\n      this.end = aData.end;\r\n    }\r\n\r\n    if (aData && 'duration' in aData) {\r\n      if (aData.duration && !(aData.duration instanceof ICAL.Duration)) {\r\n        throw new TypeError('.duration must be an instance of ICAL.Duration');\r\n      }\r\n      this.duration = aData.duration;\r\n    }\r\n  };\r\n\r\n  ICAL.Period.prototype = {\r\n\r\n    /**\r\n     * The start of the period\r\n     * @type {ICAL.Time}\r\n     */\r\n    start: null,\r\n\r\n    /**\r\n     * The end of the period\r\n     * @type {ICAL.Time}\r\n     */\r\n    end: null,\r\n\r\n    /**\r\n     * The duration of the period\r\n     * @type {ICAL.Duration}\r\n     */\r\n    duration: null,\r\n\r\n    /**\r\n     * The class identifier.\r\n     * @constant\r\n     * @type {String}\r\n     * @default \"icalperiod\"\r\n     */\r\n    icalclass: \"icalperiod\",\r\n\r\n    /**\r\n     * The type name, to be used in the jCal object.\r\n     * @constant\r\n     * @type {String}\r\n     * @default \"period\"\r\n     */\r\n    icaltype: \"period\",\r\n\r\n    /**\r\n     * Returns a clone of the duration object.\r\n     *\r\n     * @return {ICAL.Period}      The cloned object\r\n     */\r\n    clone: function() {\r\n      return ICAL.Period.fromData({\r\n        start: this.start ? this.start.clone() : null,\r\n        end: this.end ? this.end.clone() : null,\r\n        duration: this.duration ? this.duration.clone() : null\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Calculates the duration of the period, either directly or by subtracting\r\n     * start from end date.\r\n     *\r\n     * @return {ICAL.Duration}      The calculated duration\r\n     */\r\n    getDuration: function duration() {\r\n      if (this.duration) {\r\n        return this.duration;\r\n      } else {\r\n        return this.end.subtractDate(this.start);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Calculates the end date of the period, either directly or by adding\r\n     * duration to start date.\r\n     *\r\n     * @return {ICAL.Time}          The calculated end date\r\n     */\r\n    getEnd: function() {\r\n      if (this.end) {\r\n        return this.end;\r\n      } else {\r\n        var end = this.start.clone();\r\n        end.addDuration(this.duration);\r\n        return end;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * The string representation of this period.\r\n     * @return {String}\r\n     */\r\n    toString: function toString() {\r\n      return this.start + \"/\" + (this.end || this.duration);\r\n    },\r\n\r\n    /**\r\n     * The jCal representation of this period type.\r\n     * @return {Object}\r\n     */\r\n    toJSON: function() {\r\n      return [this.start.toString(), (this.end || this.duration).toString()];\r\n    },\r\n\r\n    /**\r\n     * The iCalendar string representation of this period.\r\n     * @return {String}\r\n     */\r\n    toICALString: function() {\r\n      return this.start.toICALString() + \"/\" +\r\n             (this.end || this.duration).toICALString();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Creates a new {@link ICAL.Period} instance from the passed string.\r\n   *\r\n   * @param {String} str            The string to parse\r\n   * @param {ICAL.Property} prop    The property this period will be on\r\n   * @return {ICAL.Period}          The created period instance\r\n   */\r\n  ICAL.Period.fromString = function fromString(str, prop) {\r\n    var parts = str.split('/');\r\n\r\n    if (parts.length !== 2) {\r\n      throw new Error(\r\n        'Invalid string value: \"' + str + '\" must contain a \"/\" char.'\r\n      );\r\n    }\r\n\r\n    var options = {\r\n      start: ICAL.Time.fromDateTimeString(parts[0], prop)\r\n    };\r\n\r\n    var end = parts[1];\r\n\r\n    if (ICAL.Duration.isValueString(end)) {\r\n      options.duration = ICAL.Duration.fromString(end);\r\n    } else {\r\n      options.end = ICAL.Time.fromDateTimeString(end, prop);\r\n    }\r\n\r\n    return new ICAL.Period(options);\r\n  };\r\n\r\n  /**\r\n   * Creates a new {@link ICAL.Period} instance from the given data object.\r\n   * The passed data object cannot contain both and end date and a duration.\r\n   *\r\n   * @param {Object} aData                  An object with members of the period\r\n   * @param {ICAL.Time=} aData.start        The start of the period\r\n   * @param {ICAL.Time=} aData.end          The end of the period\r\n   * @param {ICAL.Duration=} aData.duration The duration of the period\r\n   * @return {ICAL.Period}                  The period instance\r\n   */\r\n  ICAL.Period.fromData = function fromData(aData) {\r\n    return new ICAL.Period(aData);\r\n  };\r\n\r\n  /**\r\n   * Returns a new period instance from the given jCal data array. The first\r\n   * member is always the start date string, the second member is either a\r\n   * duration or end date string.\r\n   *\r\n   * @param {Array<String,String>} aData    The jCal data array\r\n   * @param {ICAL.Property} aProp           The property this jCal data is on\r\n   * @param {Boolean} aLenient              If true, data value can be both date and date-time\r\n   * @return {ICAL.Period}                  The period instance\r\n   */\r\n  ICAL.Period.fromJSON = function(aData, aProp, aLenient) {\r\n    function fromDateOrDateTimeString(aValue, aProp) {\r\n      if (aLenient) {\r\n        return ICAL.Time.fromString(aValue, aProp);\r\n      } else {\r\n        return ICAL.Time.fromDateTimeString(aValue, aProp);\r\n      }\r\n    }\r\n\r\n    if (ICAL.Duration.isValueString(aData[1])) {\r\n      return ICAL.Period.fromData({\r\n        start: fromDateOrDateTimeString(aData[0], aProp),\r\n        duration: ICAL.Duration.fromString(aData[1])\r\n      });\r\n    } else {\r\n      return ICAL.Period.fromData({\r\n        start: fromDateOrDateTimeString(aData[0], aProp),\r\n        end: fromDateOrDateTimeString(aData[1], aProp)\r\n      });\r\n    }\r\n  };\r\n})();\r\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\r\n\r\n\r\n\r\n(function() {\r\n  var DURATION_LETTERS = /([PDWHMTS]{1,1})/;\r\n\r\n  /**\r\n   * @classdesc\r\n   * This class represents the \"duration\" value type, with various calculation\r\n   * and manipulation methods.\r\n   *\r\n   * @class\r\n   * @alias ICAL.Duration\r\n   * @param {Object} data               An object with members of the duration\r\n   * @param {Number} data.weeks         Duration in weeks\r\n   * @param {Number} data.days          Duration in days\r\n   * @param {Number} data.hours         Duration in hours\r\n   * @param {Number} data.minutes       Duration in minutes\r\n   * @param {Number} data.seconds       Duration in seconds\r\n   * @param {Boolean} data.isNegative   If true, the duration is negative\r\n   */\r\n  ICAL.Duration = function icalduration(data) {\r\n    this.wrappedJSObject = this;\r\n    this.fromData(data);\r\n  };\r\n\r\n  ICAL.Duration.prototype = {\r\n    /**\r\n     * The weeks in this duration\r\n     * @type {Number}\r\n     * @default 0\r\n     */\r\n    weeks: 0,\r\n\r\n    /**\r\n     * The days in this duration\r\n     * @type {Number}\r\n     * @default 0\r\n     */\r\n    days: 0,\r\n\r\n    /**\r\n     * The days in this duration\r\n     * @type {Number}\r\n     * @default 0\r\n     */\r\n    hours: 0,\r\n\r\n    /**\r\n     * The minutes in this duration\r\n     * @type {Number}\r\n     * @default 0\r\n     */\r\n    minutes: 0,\r\n\r\n    /**\r\n     * The seconds in this duration\r\n     * @type {Number}\r\n     * @default 0\r\n     */\r\n    seconds: 0,\r\n\r\n    /**\r\n     * The seconds in this duration\r\n     * @type {Boolean}\r\n     * @default false\r\n     */\r\n    isNegative: false,\r\n\r\n    /**\r\n     * The class identifier.\r\n     * @constant\r\n     * @type {String}\r\n     * @default \"icalduration\"\r\n     */\r\n    icalclass: \"icalduration\",\r\n\r\n    /**\r\n     * The type name, to be used in the jCal object.\r\n     * @constant\r\n     * @type {String}\r\n     * @default \"duration\"\r\n     */\r\n    icaltype: \"duration\",\r\n\r\n    /**\r\n     * Returns a clone of the duration object.\r\n     *\r\n     * @return {ICAL.Duration}      The cloned object\r\n     */\r\n    clone: function clone() {\r\n      return ICAL.Duration.fromData(this);\r\n    },\r\n\r\n    /**\r\n     * The duration value expressed as a number of seconds.\r\n     *\r\n     * @return {Number}             The duration value in seconds\r\n     */\r\n    toSeconds: function toSeconds() {\r\n      var seconds = this.seconds + 60 * this.minutes + 3600 * this.hours +\r\n                    86400 * this.days + 7 * 86400 * this.weeks;\r\n      return (this.isNegative ? -seconds : seconds);\r\n    },\r\n\r\n    /**\r\n     * Reads the passed seconds value into this duration object. Afterwards,\r\n     * members like {@link ICAL.Duration#days days} and {@link ICAL.Duration#weeks weeks} will be set up\r\n     * accordingly.\r\n     *\r\n     * @param {Number} aSeconds     The duration value in seconds\r\n     * @return {ICAL.Duration}      Returns this instance\r\n     */\r\n    fromSeconds: function fromSeconds(aSeconds) {\r\n      var secs = Math.abs(aSeconds);\r\n\r\n      this.isNegative = (aSeconds < 0);\r\n      this.days = ICAL.helpers.trunc(secs / 86400);\r\n\r\n      // If we have a flat number of weeks, use them.\r\n      if (this.days % 7 == 0) {\r\n        this.weeks = this.days / 7;\r\n        this.days = 0;\r\n      } else {\r\n        this.weeks = 0;\r\n      }\r\n\r\n      secs -= (this.days + 7 * this.weeks) * 86400;\r\n\r\n      this.hours = ICAL.helpers.trunc(secs / 3600);\r\n      secs -= this.hours * 3600;\r\n\r\n      this.minutes = ICAL.helpers.trunc(secs / 60);\r\n      secs -= this.minutes * 60;\r\n\r\n      this.seconds = secs;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Sets up the current instance using members from the passed data object.\r\n     *\r\n     * @param {Object} aData               An object with members of the duration\r\n     * @param {Number} aData.weeks         Duration in weeks\r\n     * @param {Number} aData.days          Duration in days\r\n     * @param {Number} aData.hours         Duration in hours\r\n     * @param {Number} aData.minutes       Duration in minutes\r\n     * @param {Number} aData.seconds       Duration in seconds\r\n     * @param {Boolean} aData.isNegative   If true, the duration is negative\r\n     */\r\n    fromData: function fromData(aData) {\r\n      var propsToCopy = [\"weeks\", \"days\", \"hours\",\r\n                         \"minutes\", \"seconds\", \"isNegative\"];\r\n      for (var key in propsToCopy) {\r\n        /* istanbul ignore if */\r\n        if (!propsToCopy.hasOwnProperty(key)) {\r\n          continue;\r\n        }\r\n        var prop = propsToCopy[key];\r\n        if (aData && prop in aData) {\r\n          this[prop] = aData[prop];\r\n        } else {\r\n          this[prop] = 0;\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Resets the duration instance to the default values, i.e. PT0S\r\n     */\r\n    reset: function reset() {\r\n      this.isNegative = false;\r\n      this.weeks = 0;\r\n      this.days = 0;\r\n      this.hours = 0;\r\n      this.minutes = 0;\r\n      this.seconds = 0;\r\n    },\r\n\r\n    /**\r\n     * Compares the duration instance with another one.\r\n     *\r\n     * @param {ICAL.Duration} aOther        The instance to compare with\r\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\r\n     */\r\n    compare: function compare(aOther) {\r\n      var thisSeconds = this.toSeconds();\r\n      var otherSeconds = aOther.toSeconds();\r\n      return (thisSeconds > otherSeconds) - (thisSeconds < otherSeconds);\r\n    },\r\n\r\n    /**\r\n     * Normalizes the duration instance. For example, a duration with a value\r\n     * of 61 seconds will be normalized to 1 minute and 1 second.\r\n     */\r\n    normalize: function normalize() {\r\n      this.fromSeconds(this.toSeconds());\r\n    },\r\n\r\n    /**\r\n     * The string representation of this duration.\r\n     * @return {String}\r\n     */\r\n    toString: function toString() {\r\n      if (this.toSeconds() == 0) {\r\n        return \"PT0S\";\r\n      } else {\r\n        var str = \"\";\r\n        if (this.isNegative) str += \"-\";\r\n        str += \"P\";\r\n        if (this.weeks) str += this.weeks + \"W\";\r\n        if (this.days) str += this.days + \"D\";\r\n\r\n        if (this.hours || this.minutes || this.seconds) {\r\n          str += \"T\";\r\n          if (this.hours) str += this.hours + \"H\";\r\n          if (this.minutes) str += this.minutes + \"M\";\r\n          if (this.seconds) str += this.seconds + \"S\";\r\n        }\r\n        return str;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * The iCalendar string representation of this duration.\r\n     * @return {String}\r\n     */\r\n    toICALString: function() {\r\n      return this.toString();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Returns a new ICAL.Duration instance from the passed seconds value.\r\n   *\r\n   * @param {Number} aSeconds       The seconds to create the instance from\r\n   * @return {ICAL.Duration}        The newly created duration instance\r\n   */\r\n  ICAL.Duration.fromSeconds = function icalduration_from_seconds(aSeconds) {\r\n    return (new ICAL.Duration()).fromSeconds(aSeconds);\r\n  };\r\n\r\n  /**\r\n   * Internal helper function to handle a chunk of a duration.\r\n   *\r\n   * @param {String} letter type of duration chunk\r\n   * @param {String} number numeric value or -/+\r\n   * @param {Object} dict target to assign values to\r\n   */\r\n  function parseDurationChunk(letter, number, object) {\r\n    var type;\r\n    switch (letter) {\r\n      case 'P':\r\n        if (number && number === '-') {\r\n          object.isNegative = true;\r\n        } else {\r\n          object.isNegative = false;\r\n        }\r\n        // period\r\n        break;\r\n      case 'D':\r\n        type = 'days';\r\n        break;\r\n      case 'W':\r\n        type = 'weeks';\r\n        break;\r\n      case 'H':\r\n        type = 'hours';\r\n        break;\r\n      case 'M':\r\n        type = 'minutes';\r\n        break;\r\n      case 'S':\r\n        type = 'seconds';\r\n        break;\r\n      default:\r\n        // Not a valid chunk\r\n        return 0;\r\n    }\r\n\r\n    if (type) {\r\n      if (!number && number !== 0) {\r\n        throw new Error(\r\n          'invalid duration value: Missing number before \"' + letter + '\"'\r\n        );\r\n      }\r\n      var num = parseInt(number, 10);\r\n      if (ICAL.helpers.isStrictlyNaN(num)) {\r\n        throw new Error(\r\n          'invalid duration value: Invalid number \"' + number + '\" before \"' + letter + '\"'\r\n        );\r\n      }\r\n      object[type] = num;\r\n    }\r\n\r\n    return 1;\r\n  }\r\n\r\n  /**\r\n   * Checks if the given string is an iCalendar duration value.\r\n   *\r\n   * @param {String} value      The raw ical value\r\n   * @return {Boolean}          True, if the given value is of the\r\n   *                              duration ical type\r\n   */\r\n  ICAL.Duration.isValueString = function(string) {\r\n    return (string[0] === 'P' || string[1] === 'P');\r\n  };\r\n\r\n  /**\r\n   * Creates a new {@link ICAL.Duration} instance from the passed string.\r\n   *\r\n   * @param {String} aStr       The string to parse\r\n   * @return {ICAL.Duration}    The created duration instance\r\n   */\r\n  ICAL.Duration.fromString = function icalduration_from_string(aStr) {\r\n    var pos = 0;\r\n    var dict = Object.create(null);\r\n    var chunks = 0;\r\n\r\n    while ((pos = aStr.search(DURATION_LETTERS)) !== -1) {\r\n      var type = aStr[pos];\r\n      var numeric = aStr.substr(0, pos);\r\n      aStr = aStr.substr(pos + 1);\r\n\r\n      chunks += parseDurationChunk(type, numeric, dict);\r\n    }\r\n\r\n    if (chunks < 2) {\r\n      // There must be at least a chunk with \"P\" and some unit chunk\r\n      throw new Error(\r\n        'invalid duration value: Not enough duration components in \"' + aStr + '\"'\r\n      );\r\n    }\r\n\r\n    return new ICAL.Duration(dict);\r\n  };\r\n\r\n  /**\r\n   * Creates a new ICAL.Duration instance from the given data object.\r\n   *\r\n   * @param {Object} aData               An object with members of the duration\r\n   * @param {Number} aData.weeks         Duration in weeks\r\n   * @param {Number} aData.days          Duration in days\r\n   * @param {Number} aData.hours         Duration in hours\r\n   * @param {Number} aData.minutes       Duration in minutes\r\n   * @param {Number} aData.seconds       Duration in seconds\r\n   * @param {Boolean} aData.isNegative   If true, the duration is negative\r\n   * @return {ICAL.Duration}             The createad duration instance\r\n   */\r\n  ICAL.Duration.fromData = function icalduration_from_data(aData) {\r\n    return new ICAL.Duration(aData);\r\n  };\r\n})();\r\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2012 */\r\n\r\n\r\n\r\n(function() {\r\n  var OPTIONS = [\"tzid\", \"location\", \"tznames\",\r\n                 \"latitude\", \"longitude\"];\r\n\r\n  /**\r\n   * @classdesc\r\n   * Timezone representation, created by passing in a tzid and component.\r\n   *\r\n   * @example\r\n   * var vcalendar;\r\n   * var timezoneComp = vcalendar.getFirstSubcomponent('vtimezone');\r\n   * var tzid = timezoneComp.getFirstPropertyValue('tzid');\r\n   *\r\n   * var timezone = new ICAL.Timezone({\r\n   *   component: timezoneComp,\r\n   *   tzid\r\n   * });\r\n   *\r\n   * @class\r\n   * @param {ICAL.Component|Object} data options for class\r\n   * @param {String|ICAL.Component} data.component\r\n   *        If data is a simple object, then this member can be set to either a\r\n   *        string containing the component data, or an already parsed\r\n   *        ICAL.Component\r\n   * @param {String} data.tzid      The timezone identifier\r\n   * @param {String} data.location  The timezone locationw\r\n   * @param {String} data.tznames   An alternative string representation of the\r\n   *                                  timezone\r\n   * @param {Number} data.latitude  The latitude of the timezone\r\n   * @param {Number} data.longitude The longitude of the timezone\r\n   */\r\n  ICAL.Timezone = function icaltimezone(data) {\r\n    this.wrappedJSObject = this;\r\n    this.fromData(data);\r\n  };\r\n\r\n  ICAL.Timezone.prototype = {\r\n\r\n    /**\r\n     * Timezone identifier\r\n     * @type {String}\r\n     */\r\n    tzid: \"\",\r\n\r\n    /**\r\n     * Timezone location\r\n     * @type {String}\r\n     */\r\n    location: \"\",\r\n\r\n    /**\r\n     * Alternative timezone name, for the string representation\r\n     * @type {String}\r\n     */\r\n    tznames: \"\",\r\n\r\n    /**\r\n     * The primary latitude for the timezone.\r\n     * @type {Number}\r\n     */\r\n    latitude: 0.0,\r\n\r\n    /**\r\n     * The primary longitude for the timezone.\r\n     * @type {Number}\r\n     */\r\n    longitude: 0.0,\r\n\r\n    /**\r\n     * The vtimezone component for this timezone.\r\n     * @type {ICAL.Component}\r\n     */\r\n    component: null,\r\n\r\n    /**\r\n     * The year this timezone has been expanded to. All timezone transition\r\n     * dates until this year are known and can be used for calculation\r\n     *\r\n     * @private\r\n     * @type {Number}\r\n     */\r\n    expandedUntilYear: 0,\r\n\r\n    /**\r\n     * The class identifier.\r\n     * @constant\r\n     * @type {String}\r\n     * @default \"icaltimezone\"\r\n     */\r\n    icalclass: \"icaltimezone\",\r\n\r\n    /**\r\n     * Sets up the current instance using members from the passed data object.\r\n     *\r\n     * @param {ICAL.Component|Object} aData options for class\r\n     * @param {String|ICAL.Component} aData.component\r\n     *        If aData is a simple object, then this member can be set to either a\r\n     *        string containing the component data, or an already parsed\r\n     *        ICAL.Component\r\n     * @param {String} aData.tzid      The timezone identifier\r\n     * @param {String} aData.location  The timezone locationw\r\n     * @param {String} aData.tznames   An alternative string representation of the\r\n     *                                  timezone\r\n     * @param {Number} aData.latitude  The latitude of the timezone\r\n     * @param {Number} aData.longitude The longitude of the timezone\r\n     */\r\n    fromData: function fromData(aData) {\r\n      this.expandedUntilYear = 0;\r\n      this.changes = [];\r\n\r\n      if (aData instanceof ICAL.Component) {\r\n        // Either a component is passed directly\r\n        this.component = aData;\r\n      } else {\r\n        // Otherwise the component may be in the data object\r\n        if (aData && \"component\" in aData) {\r\n          if (typeof aData.component == \"string\") {\r\n            // If a string was passed, parse it as a component\r\n            var jCal = ICAL.parse(aData.component);\r\n            this.component = new ICAL.Component(jCal);\r\n          } else if (aData.component instanceof ICAL.Component) {\r\n            // If it was a component already, then just set it\r\n            this.component = aData.component;\r\n          } else {\r\n            // Otherwise just null out the component\r\n            this.component = null;\r\n          }\r\n        }\r\n\r\n        // Copy remaining passed properties\r\n        for (var key in OPTIONS) {\r\n          /* istanbul ignore else */\r\n          if (OPTIONS.hasOwnProperty(key)) {\r\n            var prop = OPTIONS[key];\r\n            if (aData && prop in aData) {\r\n              this[prop] = aData[prop];\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // If we have a component but no TZID, attempt to get it from the\r\n      // component's properties.\r\n      if (this.component instanceof ICAL.Component && !this.tzid) {\r\n        this.tzid = this.component.getFirstPropertyValue('tzid');\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Finds the utcOffset the given time would occur in this timezone.\r\n     *\r\n     * @param {ICAL.Time} tt        The time to check for\r\n     * @return {Number} utc offset in seconds\r\n     */\r\n    utcOffset: function utcOffset(tt) {\r\n      if (this == ICAL.Timezone.utcTimezone || this == ICAL.Timezone.localTimezone) {\r\n        return 0;\r\n      }\r\n\r\n      this._ensureCoverage(tt.year);\r\n\r\n      if (!this.changes.length) {\r\n        return 0;\r\n      }\r\n\r\n      var tt_change = {\r\n        year: tt.year,\r\n        month: tt.month,\r\n        day: tt.day,\r\n        hour: tt.hour,\r\n        minute: tt.minute,\r\n        second: tt.second\r\n      };\r\n\r\n      var change_num = this._findNearbyChange(tt_change);\r\n      var change_num_to_use = -1;\r\n      var step = 1;\r\n\r\n      // TODO: replace with bin search?\r\n      for (;;) {\r\n        var change = ICAL.helpers.clone(this.changes[change_num], true);\r\n        if (change.utcOffset < change.prevUtcOffset) {\r\n          ICAL.Timezone.adjust_change(change, 0, 0, 0, change.utcOffset);\r\n        } else {\r\n          ICAL.Timezone.adjust_change(change, 0, 0, 0,\r\n                                          change.prevUtcOffset);\r\n        }\r\n\r\n        var cmp = ICAL.Timezone._compare_change_fn(tt_change, change);\r\n\r\n        if (cmp >= 0) {\r\n          change_num_to_use = change_num;\r\n        } else {\r\n          step = -1;\r\n        }\r\n\r\n        if (step == -1 && change_num_to_use != -1) {\r\n          break;\r\n        }\r\n\r\n        change_num += step;\r\n\r\n        if (change_num < 0) {\r\n          return 0;\r\n        }\r\n\r\n        if (change_num >= this.changes.length) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      var zone_change = this.changes[change_num_to_use];\r\n      var utcOffset_change = zone_change.utcOffset - zone_change.prevUtcOffset;\r\n\r\n      if (utcOffset_change < 0 && change_num_to_use > 0) {\r\n        var tmp_change = ICAL.helpers.clone(zone_change, true);\r\n        ICAL.Timezone.adjust_change(tmp_change, 0, 0, 0,\r\n                                        tmp_change.prevUtcOffset);\r\n\r\n        if (ICAL.Timezone._compare_change_fn(tt_change, tmp_change) < 0) {\r\n          var prev_zone_change = this.changes[change_num_to_use - 1];\r\n\r\n          var want_daylight = false; // TODO\r\n\r\n          if (zone_change.is_daylight != want_daylight &&\r\n              prev_zone_change.is_daylight == want_daylight) {\r\n            zone_change = prev_zone_change;\r\n          }\r\n        }\r\n      }\r\n\r\n      // TODO return is_daylight?\r\n      return zone_change.utcOffset;\r\n    },\r\n\r\n    _findNearbyChange: function icaltimezone_find_nearby_change(change) {\r\n      // find the closest match\r\n      var idx = ICAL.helpers.binsearchInsert(\r\n        this.changes,\r\n        change,\r\n        ICAL.Timezone._compare_change_fn\r\n      );\r\n\r\n      if (idx >= this.changes.length) {\r\n        return this.changes.length - 1;\r\n      }\r\n\r\n      return idx;\r\n    },\r\n\r\n    _ensureCoverage: function(aYear) {\r\n      if (ICAL.Timezone._minimumExpansionYear == -1) {\r\n        var today = ICAL.Time.now();\r\n        ICAL.Timezone._minimumExpansionYear = today.year;\r\n      }\r\n\r\n      var changesEndYear = aYear;\r\n      if (changesEndYear < ICAL.Timezone._minimumExpansionYear) {\r\n        changesEndYear = ICAL.Timezone._minimumExpansionYear;\r\n      }\r\n\r\n      changesEndYear += ICAL.Timezone.EXTRA_COVERAGE;\r\n\r\n      if (changesEndYear > ICAL.Timezone.MAX_YEAR) {\r\n        changesEndYear = ICAL.Timezone.MAX_YEAR;\r\n      }\r\n\r\n      if (!this.changes.length || this.expandedUntilYear < aYear) {\r\n        var subcomps = this.component.getAllSubcomponents();\r\n        var compLen = subcomps.length;\r\n        var compIdx = 0;\r\n\r\n        for (; compIdx < compLen; compIdx++) {\r\n          this._expandComponent(\r\n            subcomps[compIdx], changesEndYear, this.changes\r\n          );\r\n        }\r\n\r\n        this.changes.sort(ICAL.Timezone._compare_change_fn);\r\n        this.expandedUntilYear = changesEndYear;\r\n      }\r\n    },\r\n\r\n    _expandComponent: function(aComponent, aYear, changes) {\r\n      if (!aComponent.hasProperty(\"dtstart\") ||\r\n          !aComponent.hasProperty(\"tzoffsetto\") ||\r\n          !aComponent.hasProperty(\"tzoffsetfrom\")) {\r\n        return null;\r\n      }\r\n\r\n      var dtstart = aComponent.getFirstProperty(\"dtstart\").getFirstValue();\r\n      var change;\r\n\r\n      function convert_tzoffset(offset) {\r\n        return offset.factor * (offset.hours * 3600 + offset.minutes * 60);\r\n      }\r\n\r\n      function init_changes() {\r\n        var changebase = {};\r\n        changebase.is_daylight = (aComponent.name == \"daylight\");\r\n        changebase.utcOffset = convert_tzoffset(\r\n          aComponent.getFirstProperty(\"tzoffsetto\").getFirstValue()\r\n        );\r\n\r\n        changebase.prevUtcOffset = convert_tzoffset(\r\n          aComponent.getFirstProperty(\"tzoffsetfrom\").getFirstValue()\r\n        );\r\n\r\n        return changebase;\r\n      }\r\n\r\n      if (!aComponent.hasProperty(\"rrule\") && !aComponent.hasProperty(\"rdate\")) {\r\n        change = init_changes();\r\n        change.year = dtstart.year;\r\n        change.month = dtstart.month;\r\n        change.day = dtstart.day;\r\n        change.hour = dtstart.hour;\r\n        change.minute = dtstart.minute;\r\n        change.second = dtstart.second;\r\n\r\n        ICAL.Timezone.adjust_change(change, 0, 0, 0,\r\n                                        -change.prevUtcOffset);\r\n        changes.push(change);\r\n      } else {\r\n        var props = aComponent.getAllProperties(\"rdate\");\r\n        for (var rdatekey in props) {\r\n          /* istanbul ignore if */\r\n          if (!props.hasOwnProperty(rdatekey)) {\r\n            continue;\r\n          }\r\n          var rdate = props[rdatekey];\r\n          var time = rdate.getFirstValue();\r\n          change = init_changes();\r\n\r\n          change.year = time.year;\r\n          change.month = time.month;\r\n          change.day = time.day;\r\n\r\n          if (time.isDate) {\r\n            change.hour = dtstart.hour;\r\n            change.minute = dtstart.minute;\r\n            change.second = dtstart.second;\r\n\r\n            if (dtstart.zone != ICAL.Timezone.utcTimezone) {\r\n              ICAL.Timezone.adjust_change(change, 0, 0, 0,\r\n                                              -change.prevUtcOffset);\r\n            }\r\n          } else {\r\n            change.hour = time.hour;\r\n            change.minute = time.minute;\r\n            change.second = time.second;\r\n\r\n            if (time.zone != ICAL.Timezone.utcTimezone) {\r\n              ICAL.Timezone.adjust_change(change, 0, 0, 0,\r\n                                              -change.prevUtcOffset);\r\n            }\r\n          }\r\n\r\n          changes.push(change);\r\n        }\r\n\r\n        var rrule = aComponent.getFirstProperty(\"rrule\");\r\n\r\n        if (rrule) {\r\n          rrule = rrule.getFirstValue();\r\n          change = init_changes();\r\n\r\n          if (rrule.until && rrule.until.zone == ICAL.Timezone.utcTimezone) {\r\n            rrule.until.adjust(0, 0, 0, change.prevUtcOffset);\r\n            rrule.until.zone = ICAL.Timezone.localTimezone;\r\n          }\r\n\r\n          var iterator = rrule.iterator(dtstart);\r\n\r\n          var occ;\r\n          while ((occ = iterator.next())) {\r\n            change = init_changes();\r\n            if (occ.year > aYear || !occ) {\r\n              break;\r\n            }\r\n\r\n            change.year = occ.year;\r\n            change.month = occ.month;\r\n            change.day = occ.day;\r\n            change.hour = occ.hour;\r\n            change.minute = occ.minute;\r\n            change.second = occ.second;\r\n            change.isDate = occ.isDate;\r\n\r\n            ICAL.Timezone.adjust_change(change, 0, 0, 0,\r\n                                            -change.prevUtcOffset);\r\n            changes.push(change);\r\n          }\r\n        }\r\n      }\r\n\r\n      return changes;\r\n    },\r\n\r\n    /**\r\n     * The string representation of this timezone.\r\n     * @return {String}\r\n     */\r\n    toString: function toString() {\r\n      return (this.tznames ? this.tznames : this.tzid);\r\n    }\r\n  };\r\n\r\n  ICAL.Timezone._compare_change_fn = function icaltimezone_compare_change_fn(a, b) {\r\n    if (a.year < b.year) return -1;\r\n    else if (a.year > b.year) return 1;\r\n\r\n    if (a.month < b.month) return -1;\r\n    else if (a.month > b.month) return 1;\r\n\r\n    if (a.day < b.day) return -1;\r\n    else if (a.day > b.day) return 1;\r\n\r\n    if (a.hour < b.hour) return -1;\r\n    else if (a.hour > b.hour) return 1;\r\n\r\n    if (a.minute < b.minute) return -1;\r\n    else if (a.minute > b.minute) return 1;\r\n\r\n    if (a.second < b.second) return -1;\r\n    else if (a.second > b.second) return 1;\r\n\r\n    return 0;\r\n  };\r\n\r\n  /**\r\n   * Convert the date/time from one zone to the next.\r\n   *\r\n   * @param {ICAL.Time} tt                  The time to convert\r\n   * @param {ICAL.Timezone} from_zone       The source zone to convert from\r\n   * @param {ICAL.Timezone} to_zone         The target zone to convert to\r\n   * @return {ICAL.Time}                    The converted date/time object\r\n   */\r\n  ICAL.Timezone.convert_time = function icaltimezone_convert_time(tt, from_zone, to_zone) {\r\n    if (tt.isDate ||\r\n        from_zone.tzid == to_zone.tzid ||\r\n        from_zone == ICAL.Timezone.localTimezone ||\r\n        to_zone == ICAL.Timezone.localTimezone) {\r\n      tt.zone = to_zone;\r\n      return tt;\r\n    }\r\n\r\n    var utcOffset = from_zone.utcOffset(tt);\r\n    tt.adjust(0, 0, 0, - utcOffset);\r\n\r\n    utcOffset = to_zone.utcOffset(tt);\r\n    tt.adjust(0, 0, 0, utcOffset);\r\n\r\n    return null;\r\n  };\r\n\r\n  /**\r\n   * Creates a new ICAL.Timezone instance from the passed data object.\r\n   *\r\n   * @param {ICAL.Component|Object} aData options for class\r\n   * @param {String|ICAL.Component} aData.component\r\n   *        If aData is a simple object, then this member can be set to either a\r\n   *        string containing the component data, or an already parsed\r\n   *        ICAL.Component\r\n   * @param {String} aData.tzid      The timezone identifier\r\n   * @param {String} aData.location  The timezone locationw\r\n   * @param {String} aData.tznames   An alternative string representation of the\r\n   *                                  timezone\r\n   * @param {Number} aData.latitude  The latitude of the timezone\r\n   * @param {Number} aData.longitude The longitude of the timezone\r\n   */\r\n  ICAL.Timezone.fromData = function icaltimezone_fromData(aData) {\r\n    var tt = new ICAL.Timezone();\r\n    return tt.fromData(aData);\r\n  };\r\n\r\n  /**\r\n   * The instance describing the UTC timezone\r\n   * @type {ICAL.Timezone}\r\n   * @constant\r\n   * @instance\r\n   */\r\n  ICAL.Timezone.utcTimezone = ICAL.Timezone.fromData({\r\n    tzid: \"UTC\"\r\n  });\r\n\r\n  /**\r\n   * The instance describing the local timezone\r\n   * @type {ICAL.Timezone}\r\n   * @constant\r\n   * @instance\r\n   */\r\n  ICAL.Timezone.localTimezone = ICAL.Timezone.fromData({\r\n    tzid: \"floating\"\r\n  });\r\n\r\n  /**\r\n   * Adjust a timezone change object.\r\n   * @private\r\n   * @param {Object} change     The timezone change object\r\n   * @param {Number} days       The extra amount of days\r\n   * @param {Number} hours      The extra amount of hours\r\n   * @param {Number} minutes    The extra amount of minutes\r\n   * @param {Number} seconds    The extra amount of seconds\r\n   */\r\n  ICAL.Timezone.adjust_change = function icaltimezone_adjust_change(change, days, hours, minutes, seconds) {\r\n    return ICAL.Time.prototype.adjust.call(\r\n      change,\r\n      days,\r\n      hours,\r\n      minutes,\r\n      seconds,\r\n      change\r\n    );\r\n  };\r\n\r\n  ICAL.Timezone._minimumExpansionYear = -1;\r\n  ICAL.Timezone.MAX_YEAR = 2035; // TODO this is because of time_t, which we don't need. Still usefull?\r\n  ICAL.Timezone.EXTRA_COVERAGE = 5;\r\n})();\r\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\r\n\r\n\r\n/**\r\n * This symbol is further described later on\r\n * @ignore\r\n */\r\nICAL.TimezoneService = (function() {\r\n  var zones;\r\n\r\n  /**\r\n   * @classdesc\r\n   * Singleton class to contain timezones.  Right now its all manual registry in\r\n   * the future we may use this class to download timezone information or handle\r\n   * loading pre-expanded timezones.\r\n   *\r\n   * @namespace\r\n   * @alias ICAL.TimezoneService\r\n   */\r\n  var TimezoneService = {\r\n    get count() {\r\n      return Object.keys(zones).length;\r\n    },\r\n\r\n    reset: function() {\r\n      zones = Object.create(null);\r\n      var utc = ICAL.Timezone.utcTimezone;\r\n\r\n      zones.Z = utc;\r\n      zones.UTC = utc;\r\n      zones.GMT = utc;\r\n    },\r\n\r\n    /**\r\n     * Checks if timezone id has been registered.\r\n     *\r\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\r\n     * @return {Boolean}        False, when not present\r\n     */\r\n    has: function(tzid) {\r\n      return !!zones[tzid];\r\n    },\r\n\r\n    /**\r\n     * Returns a timezone by its tzid if present.\r\n     *\r\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\r\n     * @return {?ICAL.Timezone} The timezone, or null if not found\r\n     */\r\n    get: function(tzid) {\r\n      return zones[tzid];\r\n    },\r\n\r\n    /**\r\n     * Registers a timezone object or component.\r\n     *\r\n     * @param {String=} name\r\n     *        The name of the timezone. Defaults to the component's TZID if not\r\n     *        passed.\r\n     * @param {ICAL.Component|ICAL.Timezone} zone\r\n     *        The initialized zone or vtimezone.\r\n     */\r\n    register: function(name, timezone) {\r\n      if (name instanceof ICAL.Component) {\r\n        if (name.name === 'vtimezone') {\r\n          timezone = new ICAL.Timezone(name);\r\n          name = timezone.tzid;\r\n        }\r\n      }\r\n\r\n      if (timezone instanceof ICAL.Timezone) {\r\n        zones[name] = timezone;\r\n      } else {\r\n        throw new TypeError('timezone must be ICAL.Timezone or ICAL.Component');\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Removes a timezone by its tzid from the list.\r\n     *\r\n     * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)\r\n     * @return {?ICAL.Timezone} The removed timezone, or null if not registered\r\n     */\r\n    remove: function(tzid) {\r\n      return (delete zones[tzid]);\r\n    }\r\n  };\r\n\r\n  // initialize defaults\r\n  TimezoneService.reset();\r\n\r\n  return TimezoneService;\r\n}());\r\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\r\n\r\n\r\n\r\n(function() {\r\n\r\n  /**\r\n   * @classdesc\r\n   * iCalendar Time representation (similar to JS Date object).  Fully\r\n   * independent of system (OS) timezone / time.  Unlike JS Date, the month\r\n   * January is 1, not zero.\r\n   *\r\n   * @example\r\n   * var time = new ICAL.Time({\r\n   *   year: 2012,\r\n   *   month: 10,\r\n   *   day: 11\r\n   *   minute: 0,\r\n   *   second: 0,\r\n   *   isDate: false\r\n   * });\r\n   *\r\n   *\r\n   * @alias ICAL.Time\r\n   * @class\r\n   * @param {Object} data           Time initialization\r\n   * @param {Number=} data.year     The year for this date\r\n   * @param {Number=} data.month    The month for this date\r\n   * @param {Number=} data.day      The day for this date\r\n   * @param {Number=} data.hour     The hour for this date\r\n   * @param {Number=} data.minute   The minute for this date\r\n   * @param {Number=} data.second   The second for this date\r\n   * @param {Boolean=} data.isDate  If true, the instance represents a date (as\r\n   *                                  opposed to a date-time)\r\n   * @param {ICAL.Timezone} zone timezone this position occurs in\r\n   */\r\n  ICAL.Time = function icaltime(data, zone) {\r\n    this.wrappedJSObject = this;\r\n    var time = this._time = Object.create(null);\r\n\r\n    /* time defaults */\r\n    time.year = 0;\r\n    time.month = 1;\r\n    time.day = 1;\r\n    time.hour = 0;\r\n    time.minute = 0;\r\n    time.second = 0;\r\n    time.isDate = false;\r\n\r\n    this.fromData(data, zone);\r\n  };\r\n\r\n  ICAL.Time._dowCache = {};\r\n  ICAL.Time._wnCache = {};\r\n\r\n  ICAL.Time.prototype = {\r\n\r\n    /**\r\n     * The class identifier.\r\n     * @constant\r\n     * @type {String}\r\n     * @default \"icaltime\"\r\n     */\r\n    icalclass: \"icaltime\",\r\n    _cachedUnixTime: null,\r\n\r\n    /**\r\n     * The type name, to be used in the jCal object. This value may change and\r\n     * is strictly defined by the {@link ICAL.Time#isDate isDate} member.\r\n     * @readonly\r\n     * @type {String}\r\n     * @default \"date-time\"\r\n     */\r\n    get icaltype() {\r\n      return this.isDate ? 'date' : 'date-time';\r\n    },\r\n\r\n    /**\r\n     * The timezone for this time.\r\n     * @type {ICAL.Timezone}\r\n     */\r\n    zone: null,\r\n\r\n    /**\r\n     * Internal uses to indicate that a change has been made and the next read\r\n     * operation must attempt to normalize the value (for example changing the\r\n     * day to 33).\r\n     *\r\n     * @type {Boolean}\r\n     * @private\r\n     */\r\n    _pendingNormalization: false,\r\n\r\n    /**\r\n     * Returns a clone of the time object.\r\n     *\r\n     * @return {ICAL.Time}              The cloned object\r\n     */\r\n    clone: function() {\r\n      return new ICAL.Time(this._time, this.zone);\r\n    },\r\n\r\n    /**\r\n     * Reset the time instance to epoch time\r\n     */\r\n    reset: function icaltime_reset() {\r\n      this.fromData(ICAL.Time.epochTime);\r\n      this.zone = ICAL.Timezone.utcTimezone;\r\n    },\r\n\r\n    /**\r\n     * Reset the time instance to the given date/time values.\r\n     *\r\n     * @param {Number} year             The year to set\r\n     * @param {Number} month            The month to set\r\n     * @param {Number} day              The day to set\r\n     * @param {Number} hour             The hour to set\r\n     * @param {Number} minute           The minute to set\r\n     * @param {Number} second           The second to set\r\n     * @param {ICAL.Timezone} timezone  The timezone to set\r\n     */\r\n    resetTo: function icaltime_resetTo(year, month, day,\r\n                                       hour, minute, second, timezone) {\r\n      this.fromData({\r\n        year: year,\r\n        month: month,\r\n        day: day,\r\n        hour: hour,\r\n        minute: minute,\r\n        second: second,\r\n        zone: timezone\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Set up the current instance from the Javascript date value.\r\n     *\r\n     * @param {?Date} aDate     The Javascript Date to read, or null to reset\r\n     * @param {Boolean} useUTC  If true, the UTC values of the date will be used\r\n     */\r\n    fromJSDate: function icaltime_fromJSDate(aDate, useUTC) {\r\n      if (!aDate) {\r\n        this.reset();\r\n      } else {\r\n        if (useUTC) {\r\n          this.zone = ICAL.Timezone.utcTimezone;\r\n          this.year = aDate.getUTCFullYear();\r\n          this.month = aDate.getUTCMonth() + 1;\r\n          this.day = aDate.getUTCDate();\r\n          this.hour = aDate.getUTCHours();\r\n          this.minute = aDate.getUTCMinutes();\r\n          this.second = aDate.getUTCSeconds();\r\n        } else {\r\n          this.zone = ICAL.Timezone.localTimezone;\r\n          this.year = aDate.getFullYear();\r\n          this.month = aDate.getMonth() + 1;\r\n          this.day = aDate.getDate();\r\n          this.hour = aDate.getHours();\r\n          this.minute = aDate.getMinutes();\r\n          this.second = aDate.getSeconds();\r\n        }\r\n      }\r\n      this._cachedUnixTime = null;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Sets up the current instance using members from the passed data object.\r\n     *\r\n     * @param {Object} aData            Time initialization\r\n     * @param {Number=} aData.year      The year for this date\r\n     * @param {Number=} aData.month     The month for this date\r\n     * @param {Number=} aData.day       The day for this date\r\n     * @param {Number=} aData.hour      The hour for this date\r\n     * @param {Number=} aData.minute    The minute for this date\r\n     * @param {Number=} aData.second    The second for this date\r\n     * @param {Boolean=} aData.isDate   If true, the instance represents a date\r\n     *                                    (as opposed to a date-time)\r\n     * @param {ICAL.Timezone=} aZone    Timezone this position occurs in\r\n     */\r\n    fromData: function fromData(aData, aZone) {\r\n      if (aData) {\r\n        for (var key in aData) {\r\n          /* istanbul ignore else */\r\n          if (Object.prototype.hasOwnProperty.call(aData, key)) {\r\n            // ical type cannot be set\r\n            if (key === 'icaltype') continue;\r\n            this[key] = aData[key];\r\n          }\r\n        }\r\n      }\r\n\r\n      if (aZone) {\r\n        this.zone = aZone;\r\n      }\r\n\r\n      if (aData && !(\"isDate\" in aData)) {\r\n        this.isDate = !(\"hour\" in aData);\r\n      } else if (aData && (\"isDate\" in aData)) {\r\n        this.isDate = aData.isDate;\r\n      }\r\n\r\n      if (aData && \"timezone\" in aData) {\r\n        var zone = ICAL.TimezoneService.get(\r\n          aData.timezone\r\n        );\r\n\r\n        this.zone = zone || ICAL.Timezone.localTimezone;\r\n      }\r\n\r\n      if (aData && \"zone\" in aData) {\r\n        this.zone = aData.zone;\r\n      }\r\n\r\n      if (!this.zone) {\r\n        this.zone = ICAL.Timezone.localTimezone;\r\n      }\r\n\r\n      this._cachedUnixTime = null;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the day of week.\r\n     * @param {ICAL.Time.weekDay=} aWeekStart\r\n     *        The week start weekday, defaults to SUNDAY\r\n     * @return {ICAL.Time.weekDay}\r\n     */\r\n    dayOfWeek: function icaltime_dayOfWeek(aWeekStart) {\r\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\r\n      var dowCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + firstDow;\r\n      if (dowCacheKey in ICAL.Time._dowCache) {\r\n        return ICAL.Time._dowCache[dowCacheKey];\r\n      }\r\n\r\n      // Using Zeller's algorithm\r\n      var q = this.day;\r\n      var m = this.month + (this.month < 3 ? 12 : 0);\r\n      var Y = this.year - (this.month < 3 ? 1 : 0);\r\n\r\n      var h = (q + Y + ICAL.helpers.trunc(((m + 1) * 26) / 10) + ICAL.helpers.trunc(Y / 4));\r\n      /* istanbul ignore else */\r\n      if (true /* gregorian */) {\r\n        h += ICAL.helpers.trunc(Y / 100) * 6 + ICAL.helpers.trunc(Y / 400);\r\n      } else {\r\n        h += 5;\r\n      }\r\n\r\n      // Normalize to 1 = wkst\r\n      h = ((h + 7 - firstDow) % 7) + 1;\r\n      ICAL.Time._dowCache[dowCacheKey] = h;\r\n      return h;\r\n    },\r\n\r\n    /**\r\n     * Calculate the day of year.\r\n     * @return {Number}\r\n     */\r\n    dayOfYear: function dayOfYear() {\r\n      var is_leap = (ICAL.Time.isLeapYear(this.year) ? 1 : 0);\r\n      var diypm = ICAL.Time.daysInYearPassedMonth;\r\n      return diypm[is_leap][this.month - 1] + this.day;\r\n    },\r\n\r\n    /**\r\n     * Returns a copy of the current date/time, rewound to the start of the\r\n     * week. The resulting ICAL.Time instance is of icaltype date, even if this\r\n     * is a date-time.\r\n     *\r\n     * @param {ICAL.Time.weekDay=} aWeekStart\r\n     *        The week start weekday, defaults to SUNDAY\r\n     * @return {ICAL.Time}      The start of the week (cloned)\r\n     */\r\n    startOfWeek: function startOfWeek(aWeekStart) {\r\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\r\n      var result = this.clone();\r\n      result.day -= ((this.dayOfWeek() + 7 - firstDow) % 7);\r\n      result.isDate = true;\r\n      result.hour = 0;\r\n      result.minute = 0;\r\n      result.second = 0;\r\n      return result;\r\n    },\r\n\r\n    /**\r\n     * Returns a copy of the current date/time, shifted to the end of the week.\r\n     * The resulting ICAL.Time instance is of icaltype date, even if this is a\r\n     * date-time.\r\n     *\r\n     * @param {ICAL.Time.weekDay=} aWeekStart\r\n     *        The week start weekday, defaults to SUNDAY\r\n     * @return {ICAL.Time}      The end of the week (cloned)\r\n     */\r\n    endOfWeek: function endOfWeek(aWeekStart) {\r\n      var firstDow = aWeekStart || ICAL.Time.SUNDAY;\r\n      var result = this.clone();\r\n      result.day += (7 - this.dayOfWeek() + firstDow - ICAL.Time.SUNDAY) % 7;\r\n      result.isDate = true;\r\n      result.hour = 0;\r\n      result.minute = 0;\r\n      result.second = 0;\r\n      return result;\r\n    },\r\n\r\n    /**\r\n     * Returns a copy of the current date/time, rewound to the start of the\r\n     * month. The resulting ICAL.Time instance is of icaltype date, even if\r\n     * this is a date-time.\r\n     *\r\n     * @return {ICAL.Time}      The start of the month (cloned)\r\n     */\r\n    startOfMonth: function startOfMonth() {\r\n      var result = this.clone();\r\n      result.day = 1;\r\n      result.isDate = true;\r\n      result.hour = 0;\r\n      result.minute = 0;\r\n      result.second = 0;\r\n      return result;\r\n    },\r\n\r\n    /**\r\n     * Returns a copy of the current date/time, shifted to the end of the\r\n     * month.  The resulting ICAL.Time instance is of icaltype date, even if\r\n     * this is a date-time.\r\n     *\r\n     * @return {ICAL.Time}      The end of the month (cloned)\r\n     */\r\n    endOfMonth: function endOfMonth() {\r\n      var result = this.clone();\r\n      result.day = ICAL.Time.daysInMonth(result.month, result.year);\r\n      result.isDate = true;\r\n      result.hour = 0;\r\n      result.minute = 0;\r\n      result.second = 0;\r\n      return result;\r\n    },\r\n\r\n    /**\r\n     * Returns a copy of the current date/time, rewound to the start of the\r\n     * year. The resulting ICAL.Time instance is of icaltype date, even if\r\n     * this is a date-time.\r\n     *\r\n     * @return {ICAL.Time}      The start of the year (cloned)\r\n     */\r\n    startOfYear: function startOfYear() {\r\n      var result = this.clone();\r\n      result.day = 1;\r\n      result.month = 1;\r\n      result.isDate = true;\r\n      result.hour = 0;\r\n      result.minute = 0;\r\n      result.second = 0;\r\n      return result;\r\n    },\r\n\r\n    /**\r\n     * Returns a copy of the current date/time, shifted to the end of the\r\n     * year.  The resulting ICAL.Time instance is of icaltype date, even if\r\n     * this is a date-time.\r\n     *\r\n     * @return {ICAL.Time}      The end of the year (cloned)\r\n     */\r\n    endOfYear: function endOfYear() {\r\n      var result = this.clone();\r\n      result.day = 31;\r\n      result.month = 12;\r\n      result.isDate = true;\r\n      result.hour = 0;\r\n      result.minute = 0;\r\n      result.second = 0;\r\n      return result;\r\n    },\r\n\r\n    /**\r\n     * First calculates the start of the week, then returns the day of year for\r\n     * this date. If the day falls into the previous year, the day is zero or negative.\r\n     *\r\n     * @param {ICAL.Time.weekDay=} aFirstDayOfWeek\r\n     *        The week start weekday, defaults to SUNDAY\r\n     * @return {Number}     The calculated day of year\r\n     */\r\n    startDoyWeek: function startDoyWeek(aFirstDayOfWeek) {\r\n      var firstDow = aFirstDayOfWeek || ICAL.Time.SUNDAY;\r\n      var delta = this.dayOfWeek() - firstDow;\r\n      if (delta < 0) delta += 7;\r\n      return this.dayOfYear() - delta;\r\n    },\r\n\r\n    /**\r\n     * Get the dominical letter for the current year. Letters range from A - G\r\n     * for common years, and AG to GF for leap years.\r\n     *\r\n     * @param {Number} yr           The year to retrieve the letter for\r\n     * @return {String}             The dominical letter.\r\n     */\r\n    getDominicalLetter: function() {\r\n      return ICAL.Time.getDominicalLetter(this.year);\r\n    },\r\n\r\n    /**\r\n     * Finds the nthWeekDay relative to the current month (not day).  The\r\n     * returned value is a day relative the month that this month belongs to so\r\n     * 1 would indicate the first of the month and 40 would indicate a day in\r\n     * the following month.\r\n     *\r\n     * @param {Number} aDayOfWeek   Day of the week see the day name constants\r\n     * @param {Number} aPos         Nth occurrence of a given week day values\r\n     *        of 1 and 0 both indicate the first weekday of that type. aPos may\r\n     *        be either positive or negative\r\n     *\r\n     * @return {Number} numeric value indicating a day relative\r\n     *                   to the current month of this time object\r\n     */\r\n    nthWeekDay: function icaltime_nthWeekDay(aDayOfWeek, aPos) {\r\n      var daysInMonth = ICAL.Time.daysInMonth(this.month, this.year);\r\n      var weekday;\r\n      var pos = aPos;\r\n\r\n      var start = 0;\r\n\r\n      var otherDay = this.clone();\r\n\r\n      if (pos >= 0) {\r\n        otherDay.day = 1;\r\n\r\n        // because 0 means no position has been given\r\n        // 1 and 0 indicate the same day.\r\n        if (pos != 0) {\r\n          // remove the extra numeric value\r\n          pos--;\r\n        }\r\n\r\n        // set current start offset to current day.\r\n        start = otherDay.day;\r\n\r\n        // find the current day of week\r\n        var startDow = otherDay.dayOfWeek();\r\n\r\n        // calculate the difference between current\r\n        // day of the week and desired day of the week\r\n        var offset = aDayOfWeek - startDow;\r\n\r\n\r\n        // if the offset goes into the past\r\n        // week we add 7 so its goes into the next\r\n        // week. We only want to go forward in time here.\r\n        if (offset < 0)\r\n          // this is really important otherwise we would\r\n          // end up with dates from in the past.\r\n          offset += 7;\r\n\r\n        // add offset to start so start is the same\r\n        // day of the week as the desired day of week.\r\n        start += offset;\r\n\r\n        // because we are going to add (and multiply)\r\n        // the numeric value of the day we subtract it\r\n        // from the start position so not to add it twice.\r\n        start -= aDayOfWeek;\r\n\r\n        // set week day\r\n        weekday = aDayOfWeek;\r\n      } else {\r\n\r\n        // then we set it to the last day in the current month\r\n        otherDay.day = daysInMonth;\r\n\r\n        // find the ends weekday\r\n        var endDow = otherDay.dayOfWeek();\r\n\r\n        pos++;\r\n\r\n        weekday = (endDow - aDayOfWeek);\r\n\r\n        if (weekday < 0) {\r\n          weekday += 7;\r\n        }\r\n\r\n        weekday = daysInMonth - weekday;\r\n      }\r\n\r\n      weekday += pos * 7;\r\n\r\n      return start + weekday;\r\n    },\r\n\r\n    /**\r\n     * Checks if current time is the nth weekday, relative to the current\r\n     * month.  Will always return false when rule resolves outside of current\r\n     * month.\r\n     *\r\n     * @param {ICAL.Time.weekDay} aDayOfWeek       Day of week to check\r\n     * @param {Number} aPos                        Relative position\r\n     * @return {Boolean}                           True, if its the nth weekday\r\n     */\r\n    isNthWeekDay: function(aDayOfWeek, aPos) {\r\n      var dow = this.dayOfWeek();\r\n\r\n      if (aPos === 0 && dow === aDayOfWeek) {\r\n        return true;\r\n      }\r\n\r\n      // get pos\r\n      var day = this.nthWeekDay(aDayOfWeek, aPos);\r\n\r\n      if (day === this.day) {\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    },\r\n\r\n    /**\r\n     * Calculates the ISO 8601 week number. The first week of a year is the\r\n     * week that contains the first Thursday. The year can have 53 weeks, if\r\n     * January 1st is a Friday.\r\n     *\r\n     * Note there are regions where the first week of the year is the one that\r\n     * starts on January 1st, which may offset the week number. Also, if a\r\n     * different week start is specified, this will also affect the week\r\n     * number.\r\n     *\r\n     * @see ICAL.Time.weekOneStarts\r\n     * @param {ICAL.Time.weekDay} aWeekStart        The weekday the week starts with\r\n     * @return {Number}                             The ISO week number\r\n     */\r\n    weekNumber: function weekNumber(aWeekStart) {\r\n      var wnCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + aWeekStart;\r\n      if (wnCacheKey in ICAL.Time._wnCache) {\r\n        return ICAL.Time._wnCache[wnCacheKey];\r\n      }\r\n      // This function courtesty of Julian Bucknall, published under the MIT license\r\n      // http://www.boyet.com/articles/publishedarticles/calculatingtheisoweeknumb.html\r\n      // plus some fixes to be able to use different week starts.\r\n      var week1;\r\n\r\n      var dt = this.clone();\r\n      dt.isDate = true;\r\n      var isoyear = this.year;\r\n\r\n      if (dt.month == 12 && dt.day > 25) {\r\n        week1 = ICAL.Time.weekOneStarts(isoyear + 1, aWeekStart);\r\n        if (dt.compare(week1) < 0) {\r\n          week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);\r\n        } else {\r\n          isoyear++;\r\n        }\r\n      } else {\r\n        week1 = ICAL.Time.weekOneStarts(isoyear, aWeekStart);\r\n        if (dt.compare(week1) < 0) {\r\n          week1 = ICAL.Time.weekOneStarts(--isoyear, aWeekStart);\r\n        }\r\n      }\r\n\r\n      var daysBetween = (dt.subtractDate(week1).toSeconds() / 86400);\r\n      var answer = ICAL.helpers.trunc(daysBetween / 7) + 1;\r\n      ICAL.Time._wnCache[wnCacheKey] = answer;\r\n      return answer;\r\n    },\r\n\r\n    /**\r\n     * Adds the duration to the current time. The instance is modified in\r\n     * place.\r\n     *\r\n     * @param {ICAL.Duration} aDuration         The duration to add\r\n     */\r\n    addDuration: function icaltime_add(aDuration) {\r\n      var mult = (aDuration.isNegative ? -1 : 1);\r\n\r\n      // because of the duration optimizations it is much\r\n      // more efficient to grab all the values up front\r\n      // then set them directly (which will avoid a normalization call).\r\n      // So we don't actually normalize until we need it.\r\n      var second = this.second;\r\n      var minute = this.minute;\r\n      var hour = this.hour;\r\n      var day = this.day;\r\n\r\n      second += mult * aDuration.seconds;\r\n      minute += mult * aDuration.minutes;\r\n      hour += mult * aDuration.hours;\r\n      day += mult * aDuration.days;\r\n      day += mult * 7 * aDuration.weeks;\r\n\r\n      this.second = second;\r\n      this.minute = minute;\r\n      this.hour = hour;\r\n      this.day = day;\r\n\r\n      this._cachedUnixTime = null;\r\n    },\r\n\r\n    /**\r\n     * Subtract the date details (_excluding_ timezone).  Useful for finding\r\n     * the relative difference between two time objects excluding their\r\n     * timezone differences.\r\n     *\r\n     * @param {ICAL.Time} aDate     The date to substract\r\n     * @return {ICAL.Duration}      The difference as a duration\r\n     */\r\n    subtractDate: function icaltime_subtract(aDate) {\r\n      var unixTime = this.toUnixTime() + this.utcOffset();\r\n      var other = aDate.toUnixTime() + aDate.utcOffset();\r\n      return ICAL.Duration.fromSeconds(unixTime - other);\r\n    },\r\n\r\n    /**\r\n     * Subtract the date details, taking timezones into account.\r\n     *\r\n     * @param {ICAL.Time} aDate  The date to subtract\r\n     * @return {ICAL.Duration}  The difference in duration\r\n     */\r\n    subtractDateTz: function icaltime_subtract_abs(aDate) {\r\n      var unixTime = this.toUnixTime();\r\n      var other = aDate.toUnixTime();\r\n      return ICAL.Duration.fromSeconds(unixTime - other);\r\n    },\r\n\r\n    /**\r\n     * Compares the ICAL.Time instance with another one.\r\n     *\r\n     * @param {ICAL.Duration} aOther        The instance to compare with\r\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\r\n     */\r\n    compare: function icaltime_compare(other) {\r\n      var a = this.toUnixTime();\r\n      var b = other.toUnixTime();\r\n\r\n      if (a > b) return 1;\r\n      if (b > a) return -1;\r\n      return 0;\r\n    },\r\n\r\n    /**\r\n     * Compares only the date part of this instance with another one.\r\n     *\r\n     * @param {ICAL.Duration} other         The instance to compare with\r\n     * @param {ICAL.Timezone} tz            The timezone to compare in\r\n     * @return {Number}                     -1, 0 or 1 for less/equal/greater\r\n     */\r\n    compareDateOnlyTz: function icaltime_compareDateOnlyTz(other, tz) {\r\n      function cmp(attr) {\r\n        return ICAL.Time._cmp_attr(a, b, attr);\r\n      }\r\n      var a = this.convertToZone(tz);\r\n      var b = other.convertToZone(tz);\r\n      var rc = 0;\r\n\r\n      if ((rc = cmp(\"year\")) != 0) return rc;\r\n      if ((rc = cmp(\"month\")) != 0) return rc;\r\n      if ((rc = cmp(\"day\")) != 0) return rc;\r\n\r\n      return rc;\r\n    },\r\n\r\n    /**\r\n     * Convert the instance into another timzone. The returned ICAL.Time\r\n     * instance is always a copy.\r\n     *\r\n     * @param {ICAL.Timezone} zone      The zone to convert to\r\n     * @return {ICAL.Time}              The copy, converted to the zone\r\n     */\r\n    convertToZone: function convertToZone(zone) {\r\n      var copy = this.clone();\r\n      var zone_equals = (this.zone.tzid == zone.tzid);\r\n\r\n      if (!this.isDate && !zone_equals) {\r\n        ICAL.Timezone.convert_time(copy, this.zone, zone);\r\n      }\r\n\r\n      copy.zone = zone;\r\n      return copy;\r\n    },\r\n\r\n    /**\r\n     * Calculates the UTC offset of the current date/time in the timezone it is\r\n     * in.\r\n     *\r\n     * @return {Number}     UTC offset in seconds\r\n     */\r\n    utcOffset: function utc_offset() {\r\n      if (this.zone == ICAL.Timezone.localTimezone ||\r\n          this.zone == ICAL.Timezone.utcTimezone) {\r\n        return 0;\r\n      } else {\r\n        return this.zone.utcOffset(this);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Returns an RFC 5545 compliant ical representation of this object.\r\n     *\r\n     * @return {String} ical date/date-time\r\n     */\r\n    toICALString: function() {\r\n      var string = this.toString();\r\n\r\n      if (string.length > 10) {\r\n        return ICAL.design.icalendar.value['date-time'].toICAL(string);\r\n      } else {\r\n        return ICAL.design.icalendar.value.date.toICAL(string);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * The string representation of this date/time, in jCal form\r\n     * (including : and - separators).\r\n     * @return {String}\r\n     */\r\n    toString: function toString() {\r\n      var result = this.year + '-' +\r\n                   ICAL.helpers.pad2(this.month) + '-' +\r\n                   ICAL.helpers.pad2(this.day);\r\n\r\n      if (!this.isDate) {\r\n          result += 'T' + ICAL.helpers.pad2(this.hour) + ':' +\r\n                    ICAL.helpers.pad2(this.minute) + ':' +\r\n                    ICAL.helpers.pad2(this.second);\r\n\r\n        if (this.zone === ICAL.Timezone.utcTimezone) {\r\n          result += 'Z';\r\n        }\r\n      }\r\n\r\n      return result;\r\n    },\r\n\r\n    /**\r\n     * Converts the current instance to a Javascript date\r\n     * @return {Date}\r\n     */\r\n    toJSDate: function toJSDate() {\r\n      if (this.zone == ICAL.Timezone.localTimezone) {\r\n        if (this.isDate) {\r\n          return new Date(this.year, this.month - 1, this.day);\r\n        } else {\r\n          return new Date(this.year, this.month - 1, this.day,\r\n                          this.hour, this.minute, this.second, 0);\r\n        }\r\n      } else {\r\n        return new Date(this.toUnixTime() * 1000);\r\n      }\r\n    },\r\n\r\n    _normalize: function icaltime_normalize() {\r\n      var isDate = this._time.isDate;\r\n      if (this._time.isDate) {\r\n        this._time.hour = 0;\r\n        this._time.minute = 0;\r\n        this._time.second = 0;\r\n      }\r\n      this.adjust(0, 0, 0, 0);\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Adjust the date/time by the given offset\r\n     *\r\n     * @param {Number} aExtraDays       The extra amount of days\r\n     * @param {Number} aExtraHours      The extra amount of hours\r\n     * @param {Number} aExtraMinutes    The extra amount of minutes\r\n     * @param {Number} aExtraSeconds    The extra amount of seconds\r\n     * @param {Number=} aTime           The time to adjust, defaults to the\r\n     *                                    current instance.\r\n     */\r\n    adjust: function icaltime_adjust(aExtraDays, aExtraHours,\r\n                                     aExtraMinutes, aExtraSeconds, aTime) {\r\n\r\n      var minutesOverflow, hoursOverflow,\r\n          daysOverflow = 0, yearsOverflow = 0;\r\n\r\n      var second, minute, hour, day;\r\n      var daysInMonth;\r\n\r\n      var time = aTime || this._time;\r\n\r\n      if (!time.isDate) {\r\n        second = time.second + aExtraSeconds;\r\n        time.second = second % 60;\r\n        minutesOverflow = ICAL.helpers.trunc(second / 60);\r\n        if (time.second < 0) {\r\n          time.second += 60;\r\n          minutesOverflow--;\r\n        }\r\n\r\n        minute = time.minute + aExtraMinutes + minutesOverflow;\r\n        time.minute = minute % 60;\r\n        hoursOverflow = ICAL.helpers.trunc(minute / 60);\r\n        if (time.minute < 0) {\r\n          time.minute += 60;\r\n          hoursOverflow--;\r\n        }\r\n\r\n        hour = time.hour + aExtraHours + hoursOverflow;\r\n\r\n        time.hour = hour % 24;\r\n        daysOverflow = ICAL.helpers.trunc(hour / 24);\r\n        if (time.hour < 0) {\r\n          time.hour += 24;\r\n          daysOverflow--;\r\n        }\r\n      }\r\n\r\n\r\n      // Adjust month and year first, because we need to know what month the day\r\n      // is in before adjusting it.\r\n      if (time.month > 12) {\r\n        yearsOverflow = ICAL.helpers.trunc((time.month - 1) / 12);\r\n      } else if (time.month < 1) {\r\n        yearsOverflow = ICAL.helpers.trunc(time.month / 12) - 1;\r\n      }\r\n\r\n      time.year += yearsOverflow;\r\n      time.month -= 12 * yearsOverflow;\r\n\r\n      // Now take care of the days (and adjust month if needed)\r\n      day = time.day + aExtraDays + daysOverflow;\r\n\r\n      if (day > 0) {\r\n        for (;;) {\r\n          daysInMonth = ICAL.Time.daysInMonth(time.month, time.year);\r\n          if (day <= daysInMonth) {\r\n            break;\r\n          }\r\n\r\n          time.month++;\r\n          if (time.month > 12) {\r\n            time.year++;\r\n            time.month = 1;\r\n          }\r\n\r\n          day -= daysInMonth;\r\n        }\r\n      } else {\r\n        while (day <= 0) {\r\n          if (time.month == 1) {\r\n            time.year--;\r\n            time.month = 12;\r\n          } else {\r\n            time.month--;\r\n          }\r\n\r\n          day += ICAL.Time.daysInMonth(time.month, time.year);\r\n        }\r\n      }\r\n\r\n      time.day = day;\r\n\r\n      this._cachedUnixTime = null;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Sets up the current instance from unix time, the number of seconds since\r\n     * January 1st, 1970.\r\n     *\r\n     * @param {Number} seconds      The seconds to set up with\r\n     */\r\n    fromUnixTime: function fromUnixTime(seconds) {\r\n      this.zone = ICAL.Timezone.utcTimezone;\r\n      var epoch = ICAL.Time.epochTime.clone();\r\n      epoch.adjust(0, 0, 0, seconds);\r\n\r\n      this.year = epoch.year;\r\n      this.month = epoch.month;\r\n      this.day = epoch.day;\r\n      this.hour = epoch.hour;\r\n      this.minute = epoch.minute;\r\n      this.second = Math.floor(epoch.second);\r\n\r\n      this._cachedUnixTime = null;\r\n    },\r\n\r\n    /**\r\n     * Converts the current instance to seconds since January 1st 1970.\r\n     *\r\n     * @return {Number}         Seconds since 1970\r\n     */\r\n    toUnixTime: function toUnixTime() {\r\n      if (this._cachedUnixTime !== null) {\r\n        return this._cachedUnixTime;\r\n      }\r\n      var offset = this.utcOffset();\r\n\r\n      // we use the offset trick to ensure\r\n      // that we are getting the actual UTC time\r\n      var ms = Date.UTC(\r\n        this.year,\r\n        this.month - 1,\r\n        this.day,\r\n        this.hour,\r\n        this.minute,\r\n        this.second - offset\r\n      );\r\n\r\n      // seconds\r\n      this._cachedUnixTime = ms / 1000;\r\n      return this._cachedUnixTime;\r\n    },\r\n\r\n    /**\r\n     * Converts time to into Object which can be serialized then re-created\r\n     * using the constructor.\r\n     *\r\n     * @example\r\n     * // toJSON will automatically be called\r\n     * var json = JSON.stringify(mytime);\r\n     *\r\n     * var deserialized = JSON.parse(json);\r\n     *\r\n     * var time = new ICAL.Time(deserialized);\r\n     *\r\n     * @return {Object}\r\n     */\r\n    toJSON: function() {\r\n      var copy = [\r\n        'year',\r\n        'month',\r\n        'day',\r\n        'hour',\r\n        'minute',\r\n        'second',\r\n        'isDate'\r\n      ];\r\n\r\n      var result = Object.create(null);\r\n\r\n      var i = 0;\r\n      var len = copy.length;\r\n      var prop;\r\n\r\n      for (; i < len; i++) {\r\n        prop = copy[i];\r\n        result[prop] = this[prop];\r\n      }\r\n\r\n      if (this.zone) {\r\n        result.timezone = this.zone.tzid;\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n  };\r\n\r\n  (function setupNormalizeAttributes() {\r\n    // This needs to run before any instances are created!\r\n    function defineAttr(attr) {\r\n      Object.defineProperty(ICAL.Time.prototype, attr, {\r\n        get: function getTimeAttr() {\r\n          if (this._pendingNormalization) {\r\n            this._normalize();\r\n            this._pendingNormalization = false;\r\n          }\r\n\r\n          return this._time[attr];\r\n        },\r\n        set: function setTimeAttr(val) {\r\n          // Check if isDate will be set and if was not set to normalize date.\r\n          // This avoids losing days when seconds, minutes and hours are zeroed\r\n          // what normalize will do when time is a date.\r\n          if (attr === \"isDate\" && val && !this._time.isDate) {\r\n            this.adjust(0, 0, 0, 0);\r\n          }\r\n          this._cachedUnixTime = null;\r\n          this._pendingNormalization = true;\r\n          this._time[attr] = val;\r\n\r\n          return val;\r\n        }\r\n      });\r\n\r\n    }\r\n\r\n    /* istanbul ignore else */\r\n    if (\"defineProperty\" in Object) {\r\n      defineAttr(\"year\");\r\n      defineAttr(\"month\");\r\n      defineAttr(\"day\");\r\n      defineAttr(\"hour\");\r\n      defineAttr(\"minute\");\r\n      defineAttr(\"second\");\r\n      defineAttr(\"isDate\");\r\n    }\r\n  })();\r\n\r\n  /**\r\n   * Returns the days in the given month\r\n   *\r\n   * @param {Number} month      The month to check\r\n   * @param {Number} year       The year to check\r\n   * @return {Number}           The number of days in the month\r\n   */\r\n  ICAL.Time.daysInMonth = function icaltime_daysInMonth(month, year) {\r\n    var _daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\r\n    var days = 30;\r\n\r\n    if (month < 1 || month > 12) return days;\r\n\r\n    days = _daysInMonth[month];\r\n\r\n    if (month == 2) {\r\n      days += ICAL.Time.isLeapYear(year);\r\n    }\r\n\r\n    return days;\r\n  };\r\n\r\n  /**\r\n   * Checks if the year is a leap year\r\n   *\r\n   * @param {Number} year       The year to check\r\n   * @return {Boolean}          True, if the year is a leap year\r\n   */\r\n  ICAL.Time.isLeapYear = function isLeapYear(year) {\r\n    if (year <= 1752) {\r\n      return ((year % 4) == 0);\r\n    } else {\r\n      return (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0));\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Create a new ICAL.Time from the day of year and year. The date is returned\r\n   * in floating timezone.\r\n   *\r\n   * @param {Number} aDayOfYear     The day of year\r\n   * @param {Number} aYear          The year to create the instance in\r\n   * @return {ICAL.Time}            The created instance with the calculated date\r\n   */\r\n  ICAL.Time.fromDayOfYear = function icaltime_fromDayOfYear(aDayOfYear, aYear) {\r\n    var year = aYear;\r\n    var doy = aDayOfYear;\r\n    var tt = new ICAL.Time();\r\n    tt.auto_normalize = false;\r\n    var is_leap = (ICAL.Time.isLeapYear(year) ? 1 : 0);\r\n\r\n    if (doy < 1) {\r\n      year--;\r\n      is_leap = (ICAL.Time.isLeapYear(year) ? 1 : 0);\r\n      doy += ICAL.Time.daysInYearPassedMonth[is_leap][12];\r\n      return ICAL.Time.fromDayOfYear(doy, year);\r\n    } else if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][12]) {\r\n      is_leap = (ICAL.Time.isLeapYear(year) ? 1 : 0);\r\n      doy -= ICAL.Time.daysInYearPassedMonth[is_leap][12];\r\n      year++;\r\n      return ICAL.Time.fromDayOfYear(doy, year);\r\n    }\r\n\r\n    tt.year = year;\r\n    tt.isDate = true;\r\n\r\n    for (var month = 11; month >= 0; month--) {\r\n      if (doy > ICAL.Time.daysInYearPassedMonth[is_leap][month]) {\r\n        tt.month = month + 1;\r\n        tt.day = doy - ICAL.Time.daysInYearPassedMonth[is_leap][month];\r\n        break;\r\n      }\r\n    }\r\n\r\n    tt.auto_normalize = true;\r\n    return tt;\r\n  };\r\n\r\n  /**\r\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\r\n   *\r\n   * @deprecated                Use {@link ICAL.Time.fromDateString} instead\r\n   * @param {String} str        The string to create from\r\n   * @return {ICAL.Time}        The date/time instance\r\n   */\r\n  ICAL.Time.fromStringv2 = function fromString(str) {\r\n    return new ICAL.Time({\r\n      year: parseInt(str.substr(0, 4), 10),\r\n      month: parseInt(str.substr(5, 2), 10),\r\n      day: parseInt(str.substr(8, 2), 10),\r\n      isDate: true\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.\r\n   *\r\n   * @param {String} aValue     The string to create from\r\n   * @return {ICAL.Time}        The date/time instance\r\n   */\r\n  ICAL.Time.fromDateString = function(aValue) {\r\n    // Dates should have no timezone.\r\n    // Google likes to sometimes specify Z on dates\r\n    // we specifically ignore that to avoid issues.\r\n\r\n    // YYYY-MM-DD\r\n    // 2012-10-10\r\n    return new ICAL.Time({\r\n      year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),\r\n      month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),\r\n      day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),\r\n      isDate: true\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Returns a new ICAL.Time instance from a date-time string, e.g\r\n   * 2015-01-02T03:04:05. If a property is specified, the timezone is set up\r\n   * from the property's TZID parameter.\r\n   *\r\n   * @param {String} aValue         The string to create from\r\n   * @param {ICAL.Property=} prop   The property the date belongs to\r\n   * @return {ICAL.Time}            The date/time instance\r\n   */\r\n  ICAL.Time.fromDateTimeString = function(aValue, prop) {\r\n    if (aValue.length < 19) {\r\n      throw new Error(\r\n        'invalid date-time value: \"' + aValue + '\"'\r\n      );\r\n    }\r\n\r\n    var zone;\r\n\r\n    if (aValue[19] && aValue[19] === 'Z') {\r\n      zone = 'Z';\r\n    } else if (prop) {\r\n      zone = prop.getParameter('tzid');\r\n    }\r\n\r\n    // 2012-10-10T10:10:10(Z)?\r\n    var time = new ICAL.Time({\r\n      year: ICAL.helpers.strictParseInt(aValue.substr(0, 4)),\r\n      month: ICAL.helpers.strictParseInt(aValue.substr(5, 2)),\r\n      day: ICAL.helpers.strictParseInt(aValue.substr(8, 2)),\r\n      hour: ICAL.helpers.strictParseInt(aValue.substr(11, 2)),\r\n      minute: ICAL.helpers.strictParseInt(aValue.substr(14, 2)),\r\n      second: ICAL.helpers.strictParseInt(aValue.substr(17, 2)),\r\n      timezone: zone\r\n    });\r\n\r\n    return time;\r\n  };\r\n\r\n  /**\r\n   * Returns a new ICAL.Time instance from a date or date-time string,\r\n   *\r\n   * @param {String} aValue         The string to create from\r\n   * @param {ICAL.Property=} prop   The property the date belongs to\r\n   * @return {ICAL.Time}            The date/time instance\r\n   */\r\n  ICAL.Time.fromString = function fromString(aValue, aProperty) {\r\n    if (aValue.length > 10) {\r\n      return ICAL.Time.fromDateTimeString(aValue, aProperty);\r\n    } else {\r\n      return ICAL.Time.fromDateString(aValue);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Creates a new ICAL.Time instance from the given Javascript Date.\r\n   *\r\n   * @param {?Date} aDate     The Javascript Date to read, or null to reset\r\n   * @param {Boolean} useUTC  If true, the UTC values of the date will be used\r\n   */\r\n  ICAL.Time.fromJSDate = function fromJSDate(aDate, useUTC) {\r\n    var tt = new ICAL.Time();\r\n    return tt.fromJSDate(aDate, useUTC);\r\n  };\r\n\r\n  /**\r\n   * Creates a new ICAL.Time instance from the the passed data object.\r\n   *\r\n   * @param {Object} aData            Time initialization\r\n   * @param {Number=} aData.year      The year for this date\r\n   * @param {Number=} aData.month     The month for this date\r\n   * @param {Number=} aData.day       The day for this date\r\n   * @param {Number=} aData.hour      The hour for this date\r\n   * @param {Number=} aData.minute    The minute for this date\r\n   * @param {Number=} aData.second    The second for this date\r\n   * @param {Boolean=} aData.isDate   If true, the instance represents a date\r\n   *                                    (as opposed to a date-time)\r\n   * @param {ICAL.Timezone=} aZone    Timezone this position occurs in\r\n   */\r\n  ICAL.Time.fromData = function fromData(aData, aZone) {\r\n    var t = new ICAL.Time();\r\n    return t.fromData(aData, aZone);\r\n  };\r\n\r\n  /**\r\n   * Creates a new ICAL.Time instance from the current moment.\r\n   * @return {ICAL.Time}\r\n   */\r\n  ICAL.Time.now = function icaltime_now() {\r\n    return ICAL.Time.fromJSDate(new Date(), false);\r\n  };\r\n\r\n  /**\r\n   * Returns the date on which ISO week number 1 starts.\r\n   *\r\n   * @see ICAL.Time#weekNumber\r\n   * @param {Number} aYear                  The year to search in\r\n   * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday, used for calculation.\r\n   * @return {ICAL.Time}                    The date on which week number 1 starts\r\n   */\r\n  ICAL.Time.weekOneStarts = function weekOneStarts(aYear, aWeekStart) {\r\n    var t = ICAL.Time.fromData({\r\n      year: aYear,\r\n      month: 1,\r\n      day: 1,\r\n      isDate: true\r\n    });\r\n\r\n    var dow = t.dayOfWeek();\r\n    var wkst = aWeekStart || ICAL.Time.DEFAULT_WEEK_START;\r\n    if (dow > ICAL.Time.THURSDAY) {\r\n      t.day += 7;\r\n    }\r\n    if (wkst > ICAL.Time.THURSDAY) {\r\n      t.day -= 7;\r\n    }\r\n\r\n    t.day -= dow - wkst;\r\n\r\n    return t;\r\n  };\r\n\r\n  /**\r\n   * Get the dominical letter for the given year. Letters range from A - G for\r\n   * common years, and AG to GF for leap years.\r\n   *\r\n   * @param {Number} yr           The year to retrieve the letter for\r\n   * @return {String}             The dominical letter.\r\n   */\r\n  ICAL.Time.getDominicalLetter = function(yr) {\r\n    var LTRS = \"GFEDCBA\";\r\n    var dom = (yr + (yr / 4 | 0) + (yr / 400 | 0) - (yr / 100 | 0) - 1) % 7;\r\n    var isLeap = ICAL.Time.isLeapYear(yr);\r\n    if (isLeap) {\r\n      return LTRS[(dom + 6) % 7] + LTRS[dom];\r\n    } else {\r\n      return LTRS[dom];\r\n    }\r\n  };\r\n\r\n  /**\r\n   * January 1st, 1970 as an ICAL.Time.\r\n   * @type {ICAL.Time}\r\n   * @constant\r\n   * @instance\r\n   */\r\n  ICAL.Time.epochTime = ICAL.Time.fromData({\r\n    year: 1970,\r\n    month: 1,\r\n    day: 1,\r\n    hour: 0,\r\n    minute: 0,\r\n    second: 0,\r\n    isDate: false,\r\n    timezone: \"Z\"\r\n  });\r\n\r\n  ICAL.Time._cmp_attr = function _cmp_attr(a, b, attr) {\r\n    if (a[attr] > b[attr]) return 1;\r\n    if (a[attr] < b[attr]) return -1;\r\n    return 0;\r\n  };\r\n\r\n  /**\r\n   * The days that have passed in the year after a given month. The array has\r\n   * two members, one being an array of passed days for non-leap years, the\r\n   * other analog for leap years.\r\n   * @example\r\n   * var isLeapYear = ICAL.Time.isLeapYear(year);\r\n   * var passedDays = ICAL.Time.daysInYearPassedMonth[isLeapYear][month];\r\n   * @type {Array.<Array.<Number>>}\r\n   */\r\n  ICAL.Time.daysInYearPassedMonth = [\r\n    [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365],\r\n    [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]\r\n  ];\r\n\r\n  /**\r\n   * The weekday, 1 = SUNDAY, 7 = SATURDAY. Access via\r\n   * ICAL.Time.MONDAY, ICAL.Time.TUESDAY, ...\r\n   *\r\n   * @typedef {Number} weekDay\r\n   * @memberof ICAL.Time\r\n   */\r\n\r\n  ICAL.Time.SUNDAY = 1;\r\n  ICAL.Time.MONDAY = 2;\r\n  ICAL.Time.TUESDAY = 3;\r\n  ICAL.Time.WEDNESDAY = 4;\r\n  ICAL.Time.THURSDAY = 5;\r\n  ICAL.Time.FRIDAY = 6;\r\n  ICAL.Time.SATURDAY = 7;\r\n\r\n  /**\r\n   * The default weekday for the WKST part.\r\n   * @constant\r\n   * @default ICAL.Time.MONDAY\r\n   */\r\n  ICAL.Time.DEFAULT_WEEK_START = ICAL.Time.MONDAY;\r\n})();\r\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2015 */\r\n\r\n\r\n\r\n(function() {\r\n\r\n  /**\r\n   * Describes a vCard time, which has slight differences to the ICAL.Time.\r\n   * Properties can be null if not specified, for example for dates with\r\n   * reduced accuracy or truncation.\r\n   *\r\n   * Note that currently not all methods are correctly re-implemented for\r\n   * VCardTime. For example, comparison will have undefined results when some\r\n   * members are null.\r\n   *\r\n   * Also, normalization is not yet implemented for this class!\r\n   *\r\n   * @alias ICAL.VCardTime\r\n   * @class\r\n   * @extends {ICAL.Time}\r\n   * @param {Object} data                           The data for the time instance\r\n   * @param {Number=} data.year                     The year for this date\r\n   * @param {Number=} data.month                    The month for this date\r\n   * @param {Number=} data.day                      The day for this date\r\n   * @param {Number=} data.hour                     The hour for this date\r\n   * @param {Number=} data.minute                   The minute for this date\r\n   * @param {Number=} data.second                   The second for this date\r\n   * @param {ICAL.Timezone|ICAL.UtcOffset} zone     The timezone to use\r\n   * @param {String} icaltype                       The type for this date/time object\r\n   */\r\n  ICAL.VCardTime = function(data, zone, icaltype) {\r\n    this.wrappedJSObject = this;\r\n    var time = this._time = Object.create(null);\r\n\r\n    time.year = null;\r\n    time.month = null;\r\n    time.day = null;\r\n    time.hour = null;\r\n    time.minute = null;\r\n    time.second = null;\r\n\r\n    this.icaltype = icaltype || \"date-and-or-time\";\r\n\r\n    this.fromData(data, zone);\r\n  };\r\n  ICAL.helpers.inherits(ICAL.Time, ICAL.VCardTime, /** @lends ICAL.VCardTime */ {\r\n\r\n    /**\r\n     * The class identifier.\r\n     * @constant\r\n     * @type {String}\r\n     * @default \"vcardtime\"\r\n     */\r\n    icalclass: \"vcardtime\",\r\n\r\n    /**\r\n     * The type name, to be used in the jCal object.\r\n     * @type {String}\r\n     * @default \"date-and-or-time\"\r\n     */\r\n    icaltype: \"date-and-or-time\",\r\n\r\n    /**\r\n     * The timezone. This can either be floating, UTC, or an instance of\r\n     * ICAL.UtcOffset.\r\n     * @type {ICAL.Timezone|ICAL.UtcOFfset}\r\n     */\r\n    zone: null,\r\n\r\n    /**\r\n     * Returns a clone of the vcard date/time object.\r\n     *\r\n     * @return {ICAL.VCardTime}     The cloned object\r\n     */\r\n    clone: function() {\r\n      return new ICAL.VCardTime(this._time, this.zone, this.icaltype);\r\n    },\r\n\r\n    _normalize: function() {\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    utcOffset: function() {\r\n      if (this.zone instanceof ICAL.UtcOffset) {\r\n        return this.zone.toSeconds();\r\n      } else {\r\n        return ICAL.Time.prototype.utcOffset.apply(this, arguments);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Returns an RFC 6350 compliant representation of this object.\r\n     *\r\n     * @return {String}         vcard date/time string\r\n     */\r\n    toICALString: function() {\r\n      return ICAL.design.vcard.value[this.icaltype].toICAL(this.toString());\r\n    },\r\n\r\n    /**\r\n     * The string representation of this date/time, in jCard form\r\n     * (including : and - separators).\r\n     * @return {String}\r\n     */\r\n    toString: function toString() {\r\n      var p2 = ICAL.helpers.pad2;\r\n      var y = this.year, m = this.month, d = this.day;\r\n      var h = this.hour, mm = this.minute, s = this.second;\r\n\r\n      var hasYear = y !== null, hasMonth = m !== null, hasDay = d !== null;\r\n      var hasHour = h !== null, hasMinute = mm !== null, hasSecond = s !== null;\r\n\r\n      var datepart = (hasYear ? p2(y) + (hasMonth || hasDay ? '-' : '') : (hasMonth || hasDay ? '--' : '')) +\r\n                     (hasMonth ? p2(m) : '') +\r\n                     (hasDay ? '-' + p2(d) : '');\r\n      var timepart = (hasHour ? p2(h) : '-') + (hasHour && hasMinute ? ':' : '') +\r\n                     (hasMinute ? p2(mm) : '') + (!hasHour && !hasMinute ? '-' : '') +\r\n                     (hasMinute && hasSecond ? ':' : '') +\r\n                     (hasSecond ? p2(s) : '');\r\n\r\n      var zone;\r\n      if (this.zone === ICAL.Timezone.utcTimezone) {\r\n        zone = 'Z';\r\n      } else if (this.zone instanceof ICAL.UtcOffset) {\r\n        zone = this.zone.toString();\r\n      } else if (this.zone === ICAL.Timezone.localTimezone) {\r\n        zone = '';\r\n      } else if (this.zone instanceof ICAL.Timezone) {\r\n        var offset = ICAL.UtcOffset.fromSeconds(this.zone.utcOffset(this));\r\n        zone = offset.toString();\r\n      } else {\r\n        zone = '';\r\n      }\r\n\r\n      switch (this.icaltype) {\r\n        case \"time\":\r\n          return timepart + zone;\r\n        case \"date-and-or-time\":\r\n        case \"date-time\":\r\n          return datepart + (timepart == '--' ? '' : 'T' + timepart + zone);\r\n        case \"date\":\r\n          return datepart;\r\n      }\r\n      return null;\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns a new ICAL.VCardTime instance from a date and/or time string.\r\n   *\r\n   * @param {String} aValue     The string to create from\r\n   * @param {String} aIcalType  The type for this instance, e.g. date-and-or-time\r\n   * @return {ICAL.VCardTime}   The date/time instance\r\n   */\r\n  ICAL.VCardTime.fromDateAndOrTimeString = function(aValue, aIcalType) {\r\n    function part(v, s, e) {\r\n      return v ? ICAL.helpers.strictParseInt(v.substr(s, e)) : null;\r\n    }\r\n    var parts = aValue.split('T');\r\n    var dt = parts[0], tmz = parts[1];\r\n    var splitzone = tmz ? ICAL.design.vcard.value.time._splitZone(tmz) : [];\r\n    var zone = splitzone[0], tm = splitzone[1];\r\n\r\n    var stoi = ICAL.helpers.strictParseInt;\r\n    var dtlen = dt ? dt.length : 0;\r\n    var tmlen = tm ? tm.length : 0;\r\n\r\n    var hasDashDate = dt && dt[0] == '-' && dt[1] == '-';\r\n    var hasDashTime = tm && tm[0] == '-';\r\n\r\n    var o = {\r\n      year: hasDashDate ? null : part(dt, 0, 4),\r\n      month: hasDashDate && (dtlen == 4 || dtlen == 7) ? part(dt, 2, 2) : dtlen == 7 ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 5, 2) : null,\r\n      day: dtlen == 5 ? part(dt, 3, 2) : dtlen == 7 && hasDashDate ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 8, 2) : null,\r\n\r\n      hour: hasDashTime ? null : part(tm, 0, 2),\r\n      minute: hasDashTime && tmlen == 3 ? part(tm, 1, 2) : tmlen > 4 ? hasDashTime ? part(tm, 1, 2) : part(tm, 3, 2) : null,\r\n      second: tmlen == 4 ? part(tm, 2, 2) : tmlen == 6 ? part(tm, 4, 2) : tmlen == 8 ? part(tm, 6, 2) : null\r\n    };\r\n\r\n    if (zone == 'Z') {\r\n      zone = ICAL.Timezone.utcTimezone;\r\n    } else if (zone && zone[3] == ':') {\r\n      zone = ICAL.UtcOffset.fromString(zone);\r\n    } else {\r\n      zone = null;\r\n    }\r\n\r\n    return new ICAL.VCardTime(o, zone, aIcalType);\r\n  };\r\n})();\r\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\r\n\r\n\r\n\r\n(function() {\r\n  var DOW_MAP = {\r\n    SU: ICAL.Time.SUNDAY,\r\n    MO: ICAL.Time.MONDAY,\r\n    TU: ICAL.Time.TUESDAY,\r\n    WE: ICAL.Time.WEDNESDAY,\r\n    TH: ICAL.Time.THURSDAY,\r\n    FR: ICAL.Time.FRIDAY,\r\n    SA: ICAL.Time.SATURDAY\r\n  };\r\n\r\n  var REVERSE_DOW_MAP = {};\r\n  for (var key in DOW_MAP) {\r\n    /* istanbul ignore else */\r\n    if (DOW_MAP.hasOwnProperty(key)) {\r\n      REVERSE_DOW_MAP[DOW_MAP[key]] = key;\r\n    }\r\n  }\r\n\r\n  var COPY_PARTS = [\"BYSECOND\", \"BYMINUTE\", \"BYHOUR\", \"BYDAY\",\r\n                    \"BYMONTHDAY\", \"BYYEARDAY\", \"BYWEEKNO\",\r\n                    \"BYMONTH\", \"BYSETPOS\"];\r\n\r\n  /**\r\n   * @classdesc\r\n   * This class represents the \"recur\" value type, with various calculation\r\n   * and manipulation methods.\r\n   *\r\n   * @class\r\n   * @alias ICAL.Recur\r\n   * @param {Object} data                               An object with members of the recurrence\r\n   * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value\r\n   * @param {Number=} data.interval                     The INTERVAL value\r\n   * @param {ICAL.Time.weekDay=} data.wkst              The week start value\r\n   * @param {ICAL.Time=} data.until                     The end of the recurrence set\r\n   * @param {Number=} data.count                        The number of occurrences\r\n   * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\r\n   * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\r\n   * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\r\n   * @param {Array.<String>=} data.byday                The BYDAY values\r\n   * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\r\n   * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\r\n   * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\r\n   * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\r\n   * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\r\n   */\r\n  ICAL.Recur = function icalrecur(data) {\r\n    this.wrappedJSObject = this;\r\n    this.parts = {};\r\n\r\n    if (data && typeof(data) === 'object') {\r\n      this.fromData(data);\r\n    }\r\n  };\r\n\r\n  ICAL.Recur.prototype = {\r\n    /**\r\n     * An object holding the BY-parts of the recurrence rule\r\n     * @type {Object}\r\n     */\r\n    parts: null,\r\n\r\n    /**\r\n     * The interval value for the recurrence rule.\r\n     * @type {Number}\r\n     */\r\n    interval: 1,\r\n\r\n    /**\r\n     * The week start day\r\n     *\r\n     * @type {ICAL.Time.weekDay}\r\n     * @default ICAL.Time.MONDAY\r\n     */\r\n    wkst: ICAL.Time.MONDAY,\r\n\r\n    /**\r\n     * The end of the recurrence\r\n     * @type {?ICAL.Time}\r\n     */\r\n    until: null,\r\n\r\n    /**\r\n     * The maximum number of occurrences\r\n     * @type {?Number}\r\n     */\r\n    count: null,\r\n\r\n    /**\r\n     * The frequency value.\r\n     * @type {ICAL.Recur.frequencyValues}\r\n     */\r\n    freq: null,\r\n\r\n    /**\r\n     * The class identifier.\r\n     * @constant\r\n     * @type {String}\r\n     * @default \"icalrecur\"\r\n     */\r\n    icalclass: \"icalrecur\",\r\n\r\n    /**\r\n     * The type name, to be used in the jCal object.\r\n     * @constant\r\n     * @type {String}\r\n     * @default \"recur\"\r\n     */\r\n    icaltype: \"recur\",\r\n\r\n    /**\r\n     * Create a new iterator for this recurrence rule. The passed start date\r\n     * must be the start date of the event, not the start of the range to\r\n     * search in.\r\n     *\r\n     * @example\r\n     * var recur = comp.getFirstPropertyValue('rrule');\r\n     * var dtstart = comp.getFirstPropertyValue('dtstart');\r\n     * var iter = recur.iterator(dtstart);\r\n     * for (var next = iter.next(); next; next = iter.next()) {\r\n     *   if (next.compare(rangeStart) < 0) {\r\n     *     continue;\r\n     *   }\r\n     *   console.log(next.toString());\r\n     * }\r\n     *\r\n     * @param {ICAL.Time} aStart        The item's start date\r\n     * @return {ICAL.RecurIterator}     The recurrence iterator\r\n     */\r\n    iterator: function(aStart) {\r\n      return new ICAL.RecurIterator({\r\n        rule: this,\r\n        dtstart: aStart\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Returns a clone of the recurrence object.\r\n     *\r\n     * @return {ICAL.Recur}      The cloned object\r\n     */\r\n    clone: function clone() {\r\n      return new ICAL.Recur(this.toJSON());\r\n    },\r\n\r\n    /**\r\n     * Checks if the current rule is finite, i.e. has a count or until part.\r\n     *\r\n     * @return {Boolean}        True, if the rule is finite\r\n     */\r\n    isFinite: function isfinite() {\r\n      return !!(this.count || this.until);\r\n    },\r\n\r\n    /**\r\n     * Checks if the current rule has a count part, and not limited by an until\r\n     * part.\r\n     *\r\n     * @return {Boolean}        True, if the rule is by count\r\n     */\r\n    isByCount: function isbycount() {\r\n      return !!(this.count && !this.until);\r\n    },\r\n\r\n    /**\r\n     * Adds a component (part) to the recurrence rule. This is not a component\r\n     * in the sense of {@link ICAL.Component}, but a part of the recurrence\r\n     * rule, i.e. BYMONTH.\r\n     *\r\n     * @param {String} aType            The name of the component part\r\n     * @param {Array|String} aValue     The component value\r\n     */\r\n    addComponent: function addPart(aType, aValue) {\r\n      var ucname = aType.toUpperCase();\r\n      if (ucname in this.parts) {\r\n        this.parts[ucname].push(aValue);\r\n      } else {\r\n        this.parts[ucname] = [aValue];\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Sets the component value for the given by-part.\r\n     *\r\n     * @param {String} aType        The component part name\r\n     * @param {Array} aValues       The component values\r\n     */\r\n    setComponent: function setComponent(aType, aValues) {\r\n      this.parts[aType.toUpperCase()] = aValues.slice();\r\n    },\r\n\r\n    /**\r\n     * Gets (a copy) of the requested component value.\r\n     *\r\n     * @param {String} aType        The component part name\r\n     * @return {Array}              The component part value\r\n     */\r\n    getComponent: function getComponent(aType) {\r\n      var ucname = aType.toUpperCase();\r\n      return (ucname in this.parts ? this.parts[ucname].slice() : []);\r\n    },\r\n\r\n    /**\r\n     * Retrieves the next occurrence after the given recurrence id. See the\r\n     * guide on {@tutorial terminology} for more details.\r\n     *\r\n     * NOTE: Currently, this method iterates all occurrences from the start\r\n     * date. It should not be called in a loop for performance reasons. If you\r\n     * would like to get more than one occurrence, you can iterate the\r\n     * occurrences manually, see the example on the\r\n     * {@link ICAL.Recur#iterator iterator} method.\r\n     *\r\n     * @param {ICAL.Time} aStartTime        The start of the event series\r\n     * @param {ICAL.Time} aRecurrenceId     The date of the last occurrence\r\n     * @return {ICAL.Time}                  The next occurrence after\r\n     */\r\n    getNextOccurrence: function getNextOccurrence(aStartTime, aRecurrenceId) {\r\n      var iter = this.iterator(aStartTime);\r\n      var next, cdt;\r\n\r\n      do {\r\n        next = iter.next();\r\n      } while (next && next.compare(aRecurrenceId) <= 0);\r\n\r\n      if (next && aRecurrenceId.zone) {\r\n        next.zone = aRecurrenceId.zone;\r\n      }\r\n\r\n      return next;\r\n    },\r\n\r\n    /**\r\n     * Sets up the current instance using members from the passed data object.\r\n     *\r\n     * @param {Object} data                               An object with members of the recurrence\r\n     * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value\r\n     * @param {Number=} data.interval                     The INTERVAL value\r\n     * @param {ICAL.Time.weekDay=} data.wkst              The week start value\r\n     * @param {ICAL.Time=} data.until                     The end of the recurrence set\r\n     * @param {Number=} data.count                        The number of occurrences\r\n     * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part\r\n     * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part\r\n     * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part\r\n     * @param {Array.<String>=} data.byday                The BYDAY values\r\n     * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part\r\n     * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part\r\n     * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part\r\n     * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part\r\n     * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part\r\n     */\r\n    fromData: function(data) {\r\n      for (var key in data) {\r\n        var uckey = key.toUpperCase();\r\n\r\n        if (uckey in partDesign) {\r\n          if (Array.isArray(data[key])) {\r\n            this.parts[uckey] = data[key];\r\n          } else {\r\n            this.parts[uckey] = [data[key]];\r\n          }\r\n        } else {\r\n          this[key] = data[key];\r\n        }\r\n      }\r\n\r\n      if (this.interval && typeof this.interval != \"number\") {\r\n        optionDesign.INTERVAL(this.interval, this);\r\n      }\r\n\r\n      if (this.wkst && typeof this.wkst != \"number\") {\r\n        this.wkst = ICAL.Recur.icalDayToNumericDay(this.wkst);\r\n      }\r\n\r\n      if (this.until && !(this.until instanceof ICAL.Time)) {\r\n        this.until = ICAL.Time.fromString(this.until);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * The jCal representation of this recurrence type.\r\n     * @return {Object}\r\n     */\r\n    toJSON: function() {\r\n      var res = Object.create(null);\r\n      res.freq = this.freq;\r\n\r\n      if (this.count) {\r\n        res.count = this.count;\r\n      }\r\n\r\n      if (this.interval > 1) {\r\n        res.interval = this.interval;\r\n      }\r\n\r\n      for (var k in this.parts) {\r\n        /* istanbul ignore if */\r\n        if (!this.parts.hasOwnProperty(k)) {\r\n          continue;\r\n        }\r\n        var kparts = this.parts[k];\r\n        if (Array.isArray(kparts) && kparts.length == 1) {\r\n          res[k.toLowerCase()] = kparts[0];\r\n        } else {\r\n          res[k.toLowerCase()] = ICAL.helpers.clone(this.parts[k]);\r\n        }\r\n      }\r\n\r\n      if (this.until) {\r\n        res.until = this.until.toString();\r\n      }\r\n      if ('wkst' in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {\r\n        res.wkst = ICAL.Recur.numericDayToIcalDay(this.wkst);\r\n      }\r\n      return res;\r\n    },\r\n\r\n    /**\r\n     * The string representation of this recurrence rule.\r\n     * @return {String}\r\n     */\r\n    toString: function icalrecur_toString() {\r\n      // TODO retain order\r\n      var str = \"FREQ=\" + this.freq;\r\n      if (this.count) {\r\n        str += \";COUNT=\" + this.count;\r\n      }\r\n      if (this.interval > 1) {\r\n        str += \";INTERVAL=\" + this.interval;\r\n      }\r\n      for (var k in this.parts) {\r\n        /* istanbul ignore else */\r\n        if (this.parts.hasOwnProperty(k)) {\r\n          str += \";\" + k + \"=\" + this.parts[k];\r\n        }\r\n      }\r\n      if (this.until) {\r\n        str += ';UNTIL=' + this.until.toICALString();\r\n      }\r\n      if ('wkst' in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) {\r\n        str += ';WKST=' + ICAL.Recur.numericDayToIcalDay(this.wkst);\r\n      }\r\n      return str;\r\n    }\r\n  };\r\n\r\n  function parseNumericValue(type, min, max, value) {\r\n    var result = value;\r\n\r\n    if (value[0] === '+') {\r\n      result = value.substr(1);\r\n    }\r\n\r\n    result = ICAL.helpers.strictParseInt(result);\r\n\r\n    if (min !== undefined && value < min) {\r\n      throw new Error(\r\n        type + ': invalid value \"' + value + '\" must be > ' + min\r\n      );\r\n    }\r\n\r\n    if (max !== undefined && value > max) {\r\n      throw new Error(\r\n        type + ': invalid value \"' + value + '\" must be < ' + min\r\n      );\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Convert an ical representation of a day (SU, MO, etc..)\r\n   * into a numeric value of that day.\r\n   *\r\n   * @param {String} string     The iCalendar day name\r\n   * @param {ICAL.Time.weekDay=} aWeekStart\r\n   *        The week start weekday, defaults to SUNDAY\r\n   * @return {Number}           Numeric value of given day\r\n   */\r\n  ICAL.Recur.icalDayToNumericDay = function toNumericDay(string, aWeekStart) {\r\n    //XXX: this is here so we can deal\r\n    //     with possibly invalid string values.\r\n    var firstDow = aWeekStart || ICAL.Time.SUNDAY;\r\n    return ((DOW_MAP[string] - firstDow + 7) % 7) + 1;\r\n  };\r\n\r\n  /**\r\n   * Convert a numeric day value into its ical representation (SU, MO, etc..)\r\n   *\r\n   * @param {Number} num        Numeric value of given day\r\n   * @param {ICAL.Time.weekDay=} aWeekStart\r\n   *        The week start weekday, defaults to SUNDAY\r\n   * @return {String}           The ICAL day value, e.g SU,MO,...\r\n   */\r\n  ICAL.Recur.numericDayToIcalDay = function toIcalDay(num, aWeekStart) {\r\n    //XXX: this is here so we can deal with possibly invalid number values.\r\n    //     Also, this allows consistent mapping between day numbers and day\r\n    //     names for external users.\r\n    var firstDow = aWeekStart || ICAL.Time.SUNDAY;\r\n    var dow = (num + firstDow - ICAL.Time.SUNDAY);\r\n    if (dow > 7) {\r\n      dow -= 7;\r\n    }\r\n    return REVERSE_DOW_MAP[dow];\r\n  };\r\n\r\n  var VALID_DAY_NAMES = /^(SU|MO|TU|WE|TH|FR|SA)$/;\r\n  var VALID_BYDAY_PART = /^([+-])?(5[0-3]|[1-4][0-9]|[1-9])?(SU|MO|TU|WE|TH|FR|SA)$/;\r\n\r\n  /**\r\n   * Possible frequency values for the FREQ part\r\n   * (YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY, SECONDLY)\r\n   *\r\n   * @typedef {String} frequencyValues\r\n   * @memberof ICAL.Recur\r\n   */\r\n\r\n  var ALLOWED_FREQ = ['SECONDLY', 'MINUTELY', 'HOURLY',\r\n                      'DAILY', 'WEEKLY', 'MONTHLY', 'YEARLY'];\r\n\r\n  var optionDesign = {\r\n    FREQ: function(value, dict, fmtIcal) {\r\n      // yes this is actually equal or faster then regex.\r\n      // upside here is we can enumerate the valid values.\r\n      if (ALLOWED_FREQ.indexOf(value) !== -1) {\r\n        dict.freq = value;\r\n      } else {\r\n        throw new Error(\r\n          'invalid frequency \"' + value + '\" expected: \"' +\r\n          ALLOWED_FREQ.join(', ') + '\"'\r\n        );\r\n      }\r\n    },\r\n\r\n    COUNT: function(value, dict, fmtIcal) {\r\n      dict.count = ICAL.helpers.strictParseInt(value);\r\n    },\r\n\r\n    INTERVAL: function(value, dict, fmtIcal) {\r\n      dict.interval = ICAL.helpers.strictParseInt(value);\r\n      if (dict.interval < 1) {\r\n        // 0 or negative values are not allowed, some engines seem to generate\r\n        // it though. Assume 1 instead.\r\n        dict.interval = 1;\r\n      }\r\n    },\r\n\r\n    UNTIL: function(value, dict, fmtIcal) {\r\n      if (value.length > 10) {\r\n        dict.until = ICAL.design.icalendar.value['date-time'].fromICAL(value);\r\n      } else {\r\n        dict.until = ICAL.design.icalendar.value.date.fromICAL(value);\r\n      }\r\n      if (!fmtIcal) {\r\n        dict.until = ICAL.Time.fromString(dict.until);\r\n      }\r\n    },\r\n\r\n    WKST: function(value, dict, fmtIcal) {\r\n      if (VALID_DAY_NAMES.test(value)) {\r\n        dict.wkst = ICAL.Recur.icalDayToNumericDay(value);\r\n      } else {\r\n        throw new Error('invalid WKST value \"' + value + '\"');\r\n      }\r\n    }\r\n  };\r\n\r\n  var partDesign = {\r\n    BYSECOND: parseNumericValue.bind(this, 'BYSECOND', 0, 60),\r\n    BYMINUTE: parseNumericValue.bind(this, 'BYMINUTE', 0, 59),\r\n    BYHOUR: parseNumericValue.bind(this, 'BYHOUR', 0, 23),\r\n    BYDAY: function(value) {\r\n      if (VALID_BYDAY_PART.test(value)) {\r\n        return value;\r\n      } else {\r\n        throw new Error('invalid BYDAY value \"' + value + '\"');\r\n      }\r\n    },\r\n    BYMONTHDAY: parseNumericValue.bind(this, 'BYMONTHDAY', -31, 31),\r\n    BYYEARDAY: parseNumericValue.bind(this, 'BYYEARDAY', -366, 366),\r\n    BYWEEKNO: parseNumericValue.bind(this, 'BYWEEKNO', -53, 53),\r\n    BYMONTH: parseNumericValue.bind(this, 'BYMONTH', 0, 12),\r\n    BYSETPOS: parseNumericValue.bind(this, 'BYSETPOS', -366, 366)\r\n  };\r\n\r\n\r\n  /**\r\n   * Creates a new {@link ICAL.Recur} instance from the passed string.\r\n   *\r\n   * @param {String} string         The string to parse\r\n   * @return {ICAL.Recur}           The created recurrence instance\r\n   */\r\n  ICAL.Recur.fromString = function(string) {\r\n    var data = ICAL.Recur._stringToData(string, false);\r\n    return new ICAL.Recur(data);\r\n  };\r\n\r\n  /**\r\n   * Creates a new {@link ICAL.Recur} instance using members from the passed\r\n   * data object.\r\n   *\r\n   * @param {Object} aData                              An object with members of the recurrence\r\n   * @param {ICAL.Recur.frequencyValues=} aData.freq    The frequency value\r\n   * @param {Number=} aData.interval                    The INTERVAL value\r\n   * @param {ICAL.Time.weekDay=} aData.wkst             The week start value\r\n   * @param {ICAL.Time=} aData.until                    The end of the recurrence set\r\n   * @param {Number=} aData.count                       The number of occurrences\r\n   * @param {Array.<Number>=} aData.bysecond            The seconds for the BYSECOND part\r\n   * @param {Array.<Number>=} aData.byminute            The minutes for the BYMINUTE part\r\n   * @param {Array.<Number>=} aData.byhour              The hours for the BYHOUR part\r\n   * @param {Array.<String>=} aData.byday               The BYDAY values\r\n   * @param {Array.<Number>=} aData.bymonthday          The days for the BYMONTHDAY part\r\n   * @param {Array.<Number>=} aData.byyearday           The days for the BYYEARDAY part\r\n   * @param {Array.<Number>=} aData.byweekno            The weeks for the BYWEEKNO part\r\n   * @param {Array.<Number>=} aData.bymonth             The month for the BYMONTH part\r\n   * @param {Array.<Number>=} aData.bysetpos            The positionals for the BYSETPOS part\r\n   */\r\n  ICAL.Recur.fromData = function(aData) {\r\n    return new ICAL.Recur(aData);\r\n  };\r\n\r\n  /**\r\n   * Converts a recurrence string to a data object, suitable for the fromData\r\n   * method.\r\n   *\r\n   * @param {String} string     The string to parse\r\n   * @param {Boolean} fmtIcal   If true, the string is considered to be an\r\n   *                              iCalendar string\r\n   * @return {ICAL.Recur}       The recurrence instance\r\n   */\r\n  ICAL.Recur._stringToData = function(string, fmtIcal) {\r\n    var dict = Object.create(null);\r\n\r\n    // split is slower in FF but fast enough.\r\n    // v8 however this is faster then manual split?\r\n    var values = string.split(';');\r\n    var len = values.length;\r\n\r\n    for (var i = 0; i < len; i++) {\r\n      var parts = values[i].split('=');\r\n      var ucname = parts[0].toUpperCase();\r\n      var lcname = parts[0].toLowerCase();\r\n      var name = (fmtIcal ? lcname : ucname);\r\n      var value = parts[1];\r\n\r\n      if (ucname in partDesign) {\r\n        var partArr = value.split(',');\r\n        var partArrIdx = 0;\r\n        var partArrLen = partArr.length;\r\n\r\n        for (; partArrIdx < partArrLen; partArrIdx++) {\r\n          partArr[partArrIdx] = partDesign[ucname](partArr[partArrIdx]);\r\n        }\r\n        dict[name] = (partArr.length == 1 ? partArr[0] : partArr);\r\n      } else if (ucname in optionDesign) {\r\n        optionDesign[ucname](value, dict, fmtIcal);\r\n      } else {\r\n        // Don't swallow unknown values. Just set them as they are.\r\n        dict[lcname] = value;\r\n      }\r\n    }\r\n\r\n    return dict;\r\n  };\r\n})();\r\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\r\n\r\n\r\n/**\r\n * This symbol is further described later on\r\n * @ignore\r\n */\r\nICAL.RecurIterator = (function() {\r\n\r\n  /**\r\n   * @classdesc\r\n   * An iterator for a single recurrence rule. This class usually doesn't have\r\n   * to be instanciated directly, the convenience method\r\n   * {@link ICAL.Recur#iterator} can be used.\r\n   *\r\n   * @description\r\n   * The options object may contain additional members when resuming iteration from a previous run\r\n   *\r\n   * @description\r\n   * The options object may contain additional members when resuming iteration\r\n   * from a previous run.\r\n   *\r\n   * @class\r\n   * @alias ICAL.RecurIterator\r\n   * @param {Object} options                The iterator options\r\n   * @param {ICAL.Recur} options.rule       The rule to iterate.\r\n   * @param {ICAL.Time} options.dtstart     The start date of the event.\r\n   * @param {Boolean=} options.initialized  When true, assume that options are\r\n   *        from a previously constructed iterator. Initialization will not be\r\n   *        repeated.\r\n   */\r\n  function icalrecur_iterator(options) {\r\n    this.fromData(options);\r\n  }\r\n\r\n  icalrecur_iterator.prototype = {\r\n\r\n    /**\r\n     * True when iteration is finished.\r\n     * @type {Boolean}\r\n     */\r\n    completed: false,\r\n\r\n    /**\r\n     * The rule that is being iterated\r\n     * @type {ICAL.Recur}\r\n     */\r\n    rule: null,\r\n\r\n    /**\r\n     * The start date of the event being iterated.\r\n     * @type {ICAL.Time}\r\n     */\r\n    dtstart: null,\r\n\r\n    /**\r\n     * The last occurrence that was returned from the\r\n     * {@link ICAL.RecurIterator#next} method.\r\n     * @type {ICAL.Time}\r\n     */\r\n    last: null,\r\n\r\n    /**\r\n     * The sequence number from the occurrence\r\n     * @type {Number}\r\n     */\r\n    occurrence_number: 0,\r\n\r\n    /**\r\n     * The indices used for the {@link ICAL.RecurIterator#by_data} object.\r\n     * @type {Object}\r\n     * @private\r\n     */\r\n    by_indices: null,\r\n\r\n    /**\r\n     * If true, the iterator has already been initialized\r\n     * @type {Boolean}\r\n     * @private\r\n     */\r\n    initialized: false,\r\n\r\n    /**\r\n     * The initializd by-data.\r\n     * @type {Object}\r\n     * @private\r\n     */\r\n    by_data: null,\r\n\r\n    /**\r\n     * The expanded yeardays\r\n     * @type {Array}\r\n     * @private\r\n     */\r\n    days: null,\r\n\r\n    /**\r\n     * The index in the {@link ICAL.RecurIterator#days} array.\r\n     * @type {Number}\r\n     * @private\r\n     */\r\n    days_index: 0,\r\n\r\n    /**\r\n     * Initialize the recurrence iterator from the passed data object. This\r\n     * method is usually not called directly, you can initialize the iterator\r\n     * through the constructor.\r\n     *\r\n     * @param {Object} options                The iterator options\r\n     * @param {ICAL.Recur} options.rule       The rule to iterate.\r\n     * @param {ICAL.Time} options.dtstart     The start date of the event.\r\n     * @param {Boolean=} options.initialized  When true, assume that options are\r\n     *        from a previously constructed iterator. Initialization will not be\r\n     *        repeated.\r\n     */\r\n    fromData: function(options) {\r\n      this.rule = ICAL.helpers.formatClassType(options.rule, ICAL.Recur);\r\n\r\n      if (!this.rule) {\r\n        throw new Error('iterator requires a (ICAL.Recur) rule');\r\n      }\r\n\r\n      this.dtstart = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);\r\n\r\n      if (!this.dtstart) {\r\n        throw new Error('iterator requires a (ICAL.Time) dtstart');\r\n      }\r\n\r\n      if (options.by_data) {\r\n        this.by_data = options.by_data;\r\n      } else {\r\n        this.by_data = ICAL.helpers.clone(this.rule.parts, true);\r\n      }\r\n\r\n      if (options.occurrence_number)\r\n        this.occurrence_number = options.occurrence_number;\r\n\r\n      this.days = options.days || [];\r\n      if (options.last) {\r\n        this.last = ICAL.helpers.formatClassType(options.last, ICAL.Time);\r\n      }\r\n\r\n      this.by_indices = options.by_indices;\r\n\r\n      if (!this.by_indices) {\r\n        this.by_indices = {\r\n          \"BYSECOND\": 0,\r\n          \"BYMINUTE\": 0,\r\n          \"BYHOUR\": 0,\r\n          \"BYDAY\": 0,\r\n          \"BYMONTH\": 0,\r\n          \"BYWEEKNO\": 0,\r\n          \"BYMONTHDAY\": 0\r\n        };\r\n      }\r\n\r\n      this.initialized = options.initialized || false;\r\n\r\n      if (!this.initialized) {\r\n        this.init();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Intialize the iterator\r\n     * @private\r\n     */\r\n    init: function icalrecur_iterator_init() {\r\n      this.initialized = true;\r\n      this.last = this.dtstart.clone();\r\n      var parts = this.by_data;\r\n\r\n      if (\"BYDAY\" in parts) {\r\n        // libical does this earlier when the rule is loaded, but we postpone to\r\n        // now so we can preserve the original order.\r\n        this.sort_byday_rules(parts.BYDAY);\r\n      }\r\n\r\n      // If the BYYEARDAY appares, no other date rule part may appear\r\n      if (\"BYYEARDAY\" in parts) {\r\n        if (\"BYMONTH\" in parts || \"BYWEEKNO\" in parts ||\r\n            \"BYMONTHDAY\" in parts || \"BYDAY\" in parts) {\r\n          throw new Error(\"Invalid BYYEARDAY rule\");\r\n        }\r\n      }\r\n\r\n      // BYWEEKNO and BYMONTHDAY rule parts may not both appear\r\n      if (\"BYWEEKNO\" in parts && \"BYMONTHDAY\" in parts) {\r\n        throw new Error(\"BYWEEKNO does not fit to BYMONTHDAY\");\r\n      }\r\n\r\n      // For MONTHLY recurrences (FREQ=MONTHLY) neither BYYEARDAY nor\r\n      // BYWEEKNO may appear.\r\n      if (this.rule.freq == \"MONTHLY\" &&\r\n          (\"BYYEARDAY\" in parts || \"BYWEEKNO\" in parts)) {\r\n        throw new Error(\"For MONTHLY recurrences neither BYYEARDAY nor BYWEEKNO may appear\");\r\n      }\r\n\r\n      // For WEEKLY recurrences (FREQ=WEEKLY) neither BYMONTHDAY nor\r\n      // BYYEARDAY may appear.\r\n      if (this.rule.freq == \"WEEKLY\" &&\r\n          (\"BYYEARDAY\" in parts || \"BYMONTHDAY\" in parts)) {\r\n        throw new Error(\"For WEEKLY recurrences neither BYMONTHDAY nor BYYEARDAY may appear\");\r\n      }\r\n\r\n      // BYYEARDAY may only appear in YEARLY rules\r\n      if (this.rule.freq != \"YEARLY\" && \"BYYEARDAY\" in parts) {\r\n        throw new Error(\"BYYEARDAY may only appear in YEARLY rules\");\r\n      }\r\n\r\n      this.last.second = this.setup_defaults(\"BYSECOND\", \"SECONDLY\", this.dtstart.second);\r\n      this.last.minute = this.setup_defaults(\"BYMINUTE\", \"MINUTELY\", this.dtstart.minute);\r\n      this.last.hour = this.setup_defaults(\"BYHOUR\", \"HOURLY\", this.dtstart.hour);\r\n      this.last.day = this.setup_defaults(\"BYMONTHDAY\", \"DAILY\", this.dtstart.day);\r\n      this.last.month = this.setup_defaults(\"BYMONTH\", \"MONTHLY\", this.dtstart.month);\r\n\r\n      if (this.rule.freq == \"WEEKLY\") {\r\n        if (\"BYDAY\" in parts) {\r\n          var bydayParts = this.ruleDayOfWeek(parts.BYDAY[0], this.rule.wkst);\r\n          var pos = bydayParts[0];\r\n          var dow = bydayParts[1];\r\n          var wkdy = dow - this.last.dayOfWeek(this.rule.wkst);\r\n          if ((this.last.dayOfWeek(this.rule.wkst) < dow && wkdy >= 0) || wkdy < 0) {\r\n            // Initial time is after first day of BYDAY data\r\n            this.last.day += wkdy;\r\n          }\r\n        } else {\r\n          var dayName = ICAL.Recur.numericDayToIcalDay(this.dtstart.dayOfWeek());\r\n          parts.BYDAY = [dayName];\r\n        }\r\n      }\r\n\r\n      if (this.rule.freq == \"YEARLY\") {\r\n        for (;;) {\r\n          this.expand_year_days(this.last.year);\r\n          if (this.days.length > 0) {\r\n            break;\r\n          }\r\n          this.increment_year(this.rule.interval);\r\n        }\r\n\r\n        this._nextByYearDay();\r\n      }\r\n\r\n      if (this.rule.freq == \"MONTHLY\" && this.has_by_data(\"BYDAY\")) {\r\n        var tempLast = null;\r\n        var initLast = this.last.clone();\r\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\r\n\r\n        // Check every weekday in BYDAY with relative dow and pos.\r\n        for (var i in this.by_data.BYDAY) {\r\n          /* istanbul ignore if */\r\n          if (!this.by_data.BYDAY.hasOwnProperty(i)) {\r\n            continue;\r\n          }\r\n          this.last = initLast.clone();\r\n          var bydayParts = this.ruleDayOfWeek(this.by_data.BYDAY[i]);\r\n          var pos = bydayParts[0];\r\n          var dow = bydayParts[1];\r\n          var dayOfMonth = this.last.nthWeekDay(dow, pos);\r\n\r\n          // If |pos| >= 6, the byday is invalid for a monthly rule.\r\n          if (pos >= 6 || pos <= -6) {\r\n            throw new Error(\"Malformed values in BYDAY part\");\r\n          }\r\n\r\n          // If a Byday with pos=+/-5 is not in the current month it\r\n          // must be searched in the next months.\r\n          if (dayOfMonth > daysInMonth || dayOfMonth <= 0) {\r\n            // Skip if we have already found a \"last\" in this month.\r\n            if (tempLast && tempLast.month == initLast.month) {\r\n              continue;\r\n            }\r\n            while (dayOfMonth > daysInMonth || dayOfMonth <= 0) {\r\n              this.increment_month();\r\n              daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\r\n              dayOfMonth = this.last.nthWeekDay(dow, pos);\r\n            }\r\n          }\r\n\r\n          this.last.day = dayOfMonth;\r\n          if (!tempLast || this.last.compare(tempLast) < 0) {\r\n            tempLast = this.last.clone();\r\n          }\r\n        }\r\n        this.last = tempLast.clone();\r\n\r\n        //XXX: This feels like a hack, but we need to initialize\r\n        //     the BYMONTHDAY case correctly and byDayAndMonthDay handles\r\n        //     this case. It accepts a special flag which will avoid incrementing\r\n        //     the initial value without the flag days that match the start time\r\n        //     would be missed.\r\n        if (this.has_by_data('BYMONTHDAY')) {\r\n          this._byDayAndMonthDay(true);\r\n        }\r\n\r\n        if (this.last.day > daysInMonth || this.last.day == 0) {\r\n          throw new Error(\"Malformed values in BYDAY part\");\r\n        }\r\n\r\n      } else if (this.has_by_data(\"BYMONTHDAY\")) {\r\n        if (this.last.day < 0) {\r\n          var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\r\n          this.last.day = daysInMonth + this.last.day + 1;\r\n        }\r\n      }\r\n\r\n    },\r\n\r\n    /**\r\n     * Retrieve the next occurrence from the iterator.\r\n     * @return {ICAL.Time}\r\n     */\r\n    next: function icalrecur_iterator_next() {\r\n      var before = (this.last ? this.last.clone() : null);\r\n\r\n      if ((this.rule.count && this.occurrence_number >= this.rule.count) ||\r\n          (this.rule.until && this.last.compare(this.rule.until) > 0)) {\r\n\r\n        //XXX: right now this is just a flag and has no impact\r\n        //     we can simplify the above case to check for completed later.\r\n        this.completed = true;\r\n\r\n        return null;\r\n      }\r\n\r\n      if (this.occurrence_number == 0 && this.last.compare(this.dtstart) >= 0) {\r\n        // First of all, give the instance that was initialized\r\n        this.occurrence_number++;\r\n        return this.last;\r\n      }\r\n\r\n\r\n      var valid;\r\n      do {\r\n        valid = 1;\r\n\r\n        switch (this.rule.freq) {\r\n        case \"SECONDLY\":\r\n          this.next_second();\r\n          break;\r\n        case \"MINUTELY\":\r\n          this.next_minute();\r\n          break;\r\n        case \"HOURLY\":\r\n          this.next_hour();\r\n          break;\r\n        case \"DAILY\":\r\n          this.next_day();\r\n          break;\r\n        case \"WEEKLY\":\r\n          this.next_week();\r\n          break;\r\n        case \"MONTHLY\":\r\n          valid = this.next_month();\r\n          break;\r\n        case \"YEARLY\":\r\n          this.next_year();\r\n          break;\r\n\r\n        default:\r\n          return null;\r\n        }\r\n      } while (!this.check_contracting_rules() ||\r\n               this.last.compare(this.dtstart) < 0 ||\r\n               !valid);\r\n\r\n      // TODO is this valid?\r\n      if (this.last.compare(before) == 0) {\r\n        throw new Error(\"Same occurrence found twice, protecting \" +\r\n                        \"you from death by recursion\");\r\n      }\r\n\r\n      if (this.rule.until && this.last.compare(this.rule.until) > 0) {\r\n        this.completed = true;\r\n        return null;\r\n      } else {\r\n        this.occurrence_number++;\r\n        return this.last;\r\n      }\r\n    },\r\n\r\n    next_second: function next_second() {\r\n      return this.next_generic(\"BYSECOND\", \"SECONDLY\", \"second\", \"minute\");\r\n    },\r\n\r\n    increment_second: function increment_second(inc) {\r\n      return this.increment_generic(inc, \"second\", 60, \"minute\");\r\n    },\r\n\r\n    next_minute: function next_minute() {\r\n      return this.next_generic(\"BYMINUTE\", \"MINUTELY\",\r\n                               \"minute\", \"hour\", \"next_second\");\r\n    },\r\n\r\n    increment_minute: function increment_minute(inc) {\r\n      return this.increment_generic(inc, \"minute\", 60, \"hour\");\r\n    },\r\n\r\n    next_hour: function next_hour() {\r\n      return this.next_generic(\"BYHOUR\", \"HOURLY\", \"hour\",\r\n                               \"monthday\", \"next_minute\");\r\n    },\r\n\r\n    increment_hour: function increment_hour(inc) {\r\n      this.increment_generic(inc, \"hour\", 24, \"monthday\");\r\n    },\r\n\r\n    next_day: function next_day() {\r\n      var has_by_day = (\"BYDAY\" in this.by_data);\r\n      var this_freq = (this.rule.freq == \"DAILY\");\r\n\r\n      if (this.next_hour() == 0) {\r\n        return 0;\r\n      }\r\n\r\n      if (this_freq) {\r\n        this.increment_monthday(this.rule.interval);\r\n      } else {\r\n        this.increment_monthday(1);\r\n      }\r\n\r\n      return 0;\r\n    },\r\n\r\n    next_week: function next_week() {\r\n      var end_of_data = 0;\r\n\r\n      if (this.next_weekday_by_week() == 0) {\r\n        return end_of_data;\r\n      }\r\n\r\n      if (this.has_by_data(\"BYWEEKNO\")) {\r\n        var idx = ++this.by_indices.BYWEEKNO;\r\n\r\n        if (this.by_indices.BYWEEKNO == this.by_data.BYWEEKNO.length) {\r\n          this.by_indices.BYWEEKNO = 0;\r\n          end_of_data = 1;\r\n        }\r\n\r\n        // HACK should be first month of the year\r\n        this.last.month = 1;\r\n        this.last.day = 1;\r\n\r\n        var week_no = this.by_data.BYWEEKNO[this.by_indices.BYWEEKNO];\r\n\r\n        this.last.day += 7 * week_no;\r\n\r\n        if (end_of_data) {\r\n          this.increment_year(1);\r\n        }\r\n      } else {\r\n        // Jump to the next week\r\n        this.increment_monthday(7 * this.rule.interval);\r\n      }\r\n\r\n      return end_of_data;\r\n    },\r\n\r\n    /**\r\n     * Normalize each by day rule for a given year/month.\r\n     * Takes into account ordering and negative rules\r\n     *\r\n     * @private\r\n     * @param {Number} year         Current year.\r\n     * @param {Number} month        Current month.\r\n     * @param {Array}  rules        Array of rules.\r\n     *\r\n     * @return {Array} sorted and normalized rules.\r\n     *                 Negative rules will be expanded to their\r\n     *                 correct positive values for easier processing.\r\n     */\r\n    normalizeByMonthDayRules: function(year, month, rules) {\r\n      var daysInMonth = ICAL.Time.daysInMonth(month, year);\r\n\r\n      // XXX: This is probably bad for performance to allocate\r\n      //      a new array for each month we scan, if possible\r\n      //      we should try to optimize this...\r\n      var newRules = [];\r\n\r\n      var ruleIdx = 0;\r\n      var len = rules.length;\r\n      var rule;\r\n\r\n      for (; ruleIdx < len; ruleIdx++) {\r\n        rule = rules[ruleIdx];\r\n\r\n        // if this rule falls outside of given\r\n        // month discard it.\r\n        if (Math.abs(rule) > daysInMonth) {\r\n          continue;\r\n        }\r\n\r\n        // negative case\r\n        if (rule < 0) {\r\n          // we add (not subtract its a negative number)\r\n          // one from the rule because 1 === last day of month\r\n          rule = daysInMonth + (rule + 1);\r\n        } else if (rule === 0) {\r\n          // skip zero its invalid.\r\n          continue;\r\n        }\r\n\r\n        // only add unique items...\r\n        if (newRules.indexOf(rule) === -1) {\r\n          newRules.push(rule);\r\n        }\r\n\r\n      }\r\n\r\n      // unique and sort\r\n      return newRules.sort(function(a, b) { return a - b; });\r\n    },\r\n\r\n    /**\r\n     * NOTES:\r\n     * We are given a list of dates in the month (BYMONTHDAY) (23, etc..)\r\n     * Also we are given a list of days (BYDAY) (MO, 2SU, etc..) when\r\n     * both conditions match a given date (this.last.day) iteration stops.\r\n     *\r\n     * @private\r\n     * @param {Boolean=} isInit     When given true will not increment the\r\n     *                                current day (this.last).\r\n     */\r\n    _byDayAndMonthDay: function(isInit) {\r\n      var byMonthDay; // setup in initMonth\r\n      var byDay = this.by_data.BYDAY;\r\n\r\n      var date;\r\n      var dateIdx = 0;\r\n      var dateLen; // setup in initMonth\r\n      var dayLen = byDay.length;\r\n\r\n      // we are not valid by default\r\n      var dataIsValid = 0;\r\n\r\n      var daysInMonth;\r\n      var self = this;\r\n      // we need a copy of this, because a DateTime gets normalized\r\n      // automatically if the day is out of range. At some points we\r\n      // set the last day to 0 to start counting.\r\n      var lastDay = this.last.day;\r\n\r\n      function initMonth() {\r\n        daysInMonth = ICAL.Time.daysInMonth(\r\n          self.last.month, self.last.year\r\n        );\r\n\r\n        byMonthDay = self.normalizeByMonthDayRules(\r\n          self.last.year,\r\n          self.last.month,\r\n          self.by_data.BYMONTHDAY\r\n        );\r\n\r\n        dateLen = byMonthDay.length;\r\n\r\n        // For the case of more than one occurrence in one month\r\n        // we have to be sure to start searching after the last\r\n        // found date or at the last BYMONTHDAY, unless we are\r\n        // initializing the iterator because in this case we have\r\n        // to consider the last found date too.\r\n        while (byMonthDay[dateIdx] <= lastDay &&\r\n               !(isInit && byMonthDay[dateIdx] == lastDay) &&\r\n               dateIdx < dateLen - 1) {\r\n          dateIdx++;\r\n        }\r\n      }\r\n\r\n      function nextMonth() {\r\n        // since the day is incremented at the start\r\n        // of the loop below, we need to start at 0\r\n        lastDay = 0;\r\n        self.increment_month();\r\n        dateIdx = 0;\r\n        initMonth();\r\n      }\r\n\r\n      initMonth();\r\n\r\n      // should come after initMonth\r\n      if (isInit) {\r\n        lastDay -= 1;\r\n      }\r\n\r\n      // Use a counter to avoid an infinite loop with malformed rules.\r\n      // Stop checking after 4 years so we consider also a leap year.\r\n      var monthsCounter = 48;\r\n\r\n      while (!dataIsValid && monthsCounter) {\r\n        monthsCounter--;\r\n        // increment the current date. This is really\r\n        // important otherwise we may fall into the infinite\r\n        // loop trap. The initial date takes care of the case\r\n        // where the current date is the date we are looking\r\n        // for.\r\n        date = lastDay + 1;\r\n\r\n        if (date > daysInMonth) {\r\n          nextMonth();\r\n          continue;\r\n        }\r\n\r\n        // find next date\r\n        var next = byMonthDay[dateIdx++];\r\n\r\n        // this logic is dependant on the BYMONTHDAYS\r\n        // being in order (which is done by #normalizeByMonthDayRules)\r\n        if (next >= date) {\r\n          // if the next month day is in the future jump to it.\r\n          lastDay = next;\r\n        } else {\r\n          // in this case the 'next' monthday has past\r\n          // we must move to the month.\r\n          nextMonth();\r\n          continue;\r\n        }\r\n\r\n        // Now we can loop through the day rules to see\r\n        // if one matches the current month date.\r\n        for (var dayIdx = 0; dayIdx < dayLen; dayIdx++) {\r\n          var parts = this.ruleDayOfWeek(byDay[dayIdx]);\r\n          var pos = parts[0];\r\n          var dow = parts[1];\r\n\r\n          this.last.day = lastDay;\r\n          if (this.last.isNthWeekDay(dow, pos)) {\r\n            // when we find the valid one we can mark\r\n            // the conditions as met and break the loop.\r\n            // (Because we have this condition above\r\n            //  it will also break the parent loop).\r\n            dataIsValid = 1;\r\n            break;\r\n          }\r\n        }\r\n\r\n        // Its completely possible that the combination\r\n        // cannot be matched in the current month.\r\n        // When we reach the end of possible combinations\r\n        // in the current month we iterate to the next one.\r\n        // since dateIdx is incremented right after getting\r\n        // \"next\", we don't need dateLen -1 here.\r\n        if (!dataIsValid && dateIdx === dateLen) {\r\n          nextMonth();\r\n          continue;\r\n        }\r\n      }\r\n\r\n      if (monthsCounter <= 0) {\r\n        // Checked 4 years without finding a Byday that matches\r\n        // a Bymonthday. Maybe the rule is not correct.\r\n        throw new Error(\"Malformed values in BYDAY combined with BYMONTHDAY parts\");\r\n      }\r\n\r\n\r\n      return dataIsValid;\r\n    },\r\n\r\n    next_month: function next_month() {\r\n      var this_freq = (this.rule.freq == \"MONTHLY\");\r\n      var data_valid = 1;\r\n\r\n      if (this.next_hour() == 0) {\r\n        return data_valid;\r\n      }\r\n\r\n      if (this.has_by_data(\"BYDAY\") && this.has_by_data(\"BYMONTHDAY\")) {\r\n        data_valid = this._byDayAndMonthDay();\r\n      } else if (this.has_by_data(\"BYDAY\")) {\r\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\r\n        var setpos = 0;\r\n        var setpos_total = 0;\r\n\r\n        if (this.has_by_data(\"BYSETPOS\")) {\r\n          var last_day = this.last.day;\r\n          for (var day = 1; day <= daysInMonth; day++) {\r\n            this.last.day = day;\r\n            if (this.is_day_in_byday(this.last)) {\r\n              setpos_total++;\r\n              if (day <= last_day) {\r\n                setpos++;\r\n              }\r\n            }\r\n          }\r\n          this.last.day = last_day;\r\n        }\r\n\r\n        data_valid = 0;\r\n        for (var day = this.last.day + 1; day <= daysInMonth; day++) {\r\n          this.last.day = day;\r\n\r\n          if (this.is_day_in_byday(this.last)) {\r\n            if (!this.has_by_data(\"BYSETPOS\") ||\r\n                this.check_set_position(++setpos) ||\r\n                this.check_set_position(setpos - setpos_total - 1)) {\r\n\r\n              data_valid = 1;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (day > daysInMonth) {\r\n          this.last.day = 1;\r\n          this.increment_month();\r\n\r\n          if (this.is_day_in_byday(this.last)) {\r\n            if (!this.has_by_data(\"BYSETPOS\") || this.check_set_position(1)) {\r\n              data_valid = 1;\r\n            }\r\n          } else {\r\n            data_valid = 0;\r\n          }\r\n        }\r\n      } else if (this.has_by_data(\"BYMONTHDAY\")) {\r\n        this.by_indices.BYMONTHDAY++;\r\n\r\n        if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) {\r\n          this.by_indices.BYMONTHDAY = 0;\r\n          this.increment_month();\r\n        }\r\n\r\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\r\n        var day = this.by_data.BYMONTHDAY[this.by_indices.BYMONTHDAY];\r\n\r\n        if (day < 0) {\r\n          day = daysInMonth + day + 1;\r\n        }\r\n\r\n        if (day > daysInMonth) {\r\n          this.last.day = 1;\r\n          data_valid = this.is_day_in_byday(this.last);\r\n        } else {\r\n          this.last.day = day;\r\n        }\r\n\r\n      } else {\r\n        this.increment_month();\r\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\r\n        if (this.by_data.BYMONTHDAY[0] > daysInMonth) {\r\n          data_valid = 0;\r\n        } else {\r\n          this.last.day = this.by_data.BYMONTHDAY[0];\r\n        }\r\n      }\r\n\r\n      return data_valid;\r\n    },\r\n\r\n    next_weekday_by_week: function next_weekday_by_week() {\r\n      var end_of_data = 0;\r\n\r\n      if (this.next_hour() == 0) {\r\n        return end_of_data;\r\n      }\r\n\r\n      if (!this.has_by_data(\"BYDAY\")) {\r\n        return 1;\r\n      }\r\n\r\n      for (;;) {\r\n        var tt = new ICAL.Time();\r\n        this.by_indices.BYDAY++;\r\n\r\n        if (this.by_indices.BYDAY == Object.keys(this.by_data.BYDAY).length) {\r\n          this.by_indices.BYDAY = 0;\r\n          end_of_data = 1;\r\n        }\r\n\r\n        var coded_day = this.by_data.BYDAY[this.by_indices.BYDAY];\r\n        var parts = this.ruleDayOfWeek(coded_day);\r\n        var dow = parts[1];\r\n\r\n        dow -= this.rule.wkst;\r\n\r\n        if (dow < 0) {\r\n          dow += 7;\r\n        }\r\n\r\n        tt.year = this.last.year;\r\n        tt.month = this.last.month;\r\n        tt.day = this.last.day;\r\n\r\n        var startOfWeek = tt.startDoyWeek(this.rule.wkst);\r\n\r\n        if (dow + startOfWeek < 1) {\r\n          // The selected date is in the previous year\r\n          if (!end_of_data) {\r\n            continue;\r\n          }\r\n        }\r\n\r\n        var next = ICAL.Time.fromDayOfYear(startOfWeek + dow,\r\n                                                  this.last.year);\r\n\r\n        /**\r\n         * The normalization horrors below are due to\r\n         * the fact that when the year/month/day changes\r\n         * it can effect the other operations that come after.\r\n         */\r\n        this.last.year = next.year;\r\n        this.last.month = next.month;\r\n        this.last.day = next.day;\r\n\r\n        return end_of_data;\r\n      }\r\n    },\r\n\r\n    next_year: function next_year() {\r\n\r\n      if (this.next_hour() == 0) {\r\n        return 0;\r\n      }\r\n\r\n      if (++this.days_index == this.days.length) {\r\n        this.days_index = 0;\r\n        do {\r\n          this.increment_year(this.rule.interval);\r\n          this.expand_year_days(this.last.year);\r\n        } while (this.days.length == 0);\r\n      }\r\n\r\n      this._nextByYearDay();\r\n\r\n      return 1;\r\n    },\r\n\r\n    _nextByYearDay: function _nextByYearDay() {\r\n        var doy = this.days[this.days_index];\r\n        var year = this.last.year;\r\n        if (doy < 1) {\r\n            // Time.fromDayOfYear(doy, year) indexes relative to the\r\n            // start of the given year. That is different from the\r\n            // semantics of BYYEARDAY where negative indexes are an\r\n            // offset from the end of the given year.\r\n            doy += 1;\r\n            year += 1;\r\n        }\r\n        var next = ICAL.Time.fromDayOfYear(doy, year);\r\n        this.last.day = next.day;\r\n        this.last.month = next.month;\r\n    },\r\n\r\n    /**\r\n     * @param dow (eg: '1TU', '-1MO')\r\n     * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday\r\n     * @return [pos, numericDow] (eg: [1, 3]) numericDow is relative to aWeekStart\r\n     */\r\n    ruleDayOfWeek: function ruleDayOfWeek(dow, aWeekStart) {\r\n      var matches = dow.match(/([+-]?[0-9])?(MO|TU|WE|TH|FR|SA|SU)/);\r\n      if (matches) {\r\n        var pos = parseInt(matches[1] || 0, 10);\r\n        dow = ICAL.Recur.icalDayToNumericDay(matches[2], aWeekStart);\r\n        return [pos, dow];\r\n      } else {\r\n        return [0, 0];\r\n      }\r\n    },\r\n\r\n    next_generic: function next_generic(aRuleType, aInterval, aDateAttr,\r\n                                        aFollowingAttr, aPreviousIncr) {\r\n      var has_by_rule = (aRuleType in this.by_data);\r\n      var this_freq = (this.rule.freq == aInterval);\r\n      var end_of_data = 0;\r\n\r\n      if (aPreviousIncr && this[aPreviousIncr]() == 0) {\r\n        return end_of_data;\r\n      }\r\n\r\n      if (has_by_rule) {\r\n        this.by_indices[aRuleType]++;\r\n        var idx = this.by_indices[aRuleType];\r\n        var dta = this.by_data[aRuleType];\r\n\r\n        if (this.by_indices[aRuleType] == dta.length) {\r\n          this.by_indices[aRuleType] = 0;\r\n          end_of_data = 1;\r\n        }\r\n        this.last[aDateAttr] = dta[this.by_indices[aRuleType]];\r\n      } else if (this_freq) {\r\n        this[\"increment_\" + aDateAttr](this.rule.interval);\r\n      }\r\n\r\n      if (has_by_rule && end_of_data && this_freq) {\r\n        this[\"increment_\" + aFollowingAttr](1);\r\n      }\r\n\r\n      return end_of_data;\r\n    },\r\n\r\n    increment_monthday: function increment_monthday(inc) {\r\n      for (var i = 0; i < inc; i++) {\r\n        var daysInMonth = ICAL.Time.daysInMonth(this.last.month, this.last.year);\r\n        this.last.day++;\r\n\r\n        if (this.last.day > daysInMonth) {\r\n          this.last.day -= daysInMonth;\r\n          this.increment_month();\r\n        }\r\n      }\r\n    },\r\n\r\n    increment_month: function increment_month() {\r\n      this.last.day = 1;\r\n      if (this.has_by_data(\"BYMONTH\")) {\r\n        this.by_indices.BYMONTH++;\r\n\r\n        if (this.by_indices.BYMONTH == this.by_data.BYMONTH.length) {\r\n          this.by_indices.BYMONTH = 0;\r\n          this.increment_year(1);\r\n        }\r\n\r\n        this.last.month = this.by_data.BYMONTH[this.by_indices.BYMONTH];\r\n      } else {\r\n        if (this.rule.freq == \"MONTHLY\") {\r\n          this.last.month += this.rule.interval;\r\n        } else {\r\n          this.last.month++;\r\n        }\r\n\r\n        this.last.month--;\r\n        var years = ICAL.helpers.trunc(this.last.month / 12);\r\n        this.last.month %= 12;\r\n        this.last.month++;\r\n\r\n        if (years != 0) {\r\n          this.increment_year(years);\r\n        }\r\n      }\r\n    },\r\n\r\n    increment_year: function increment_year(inc) {\r\n      this.last.year += inc;\r\n    },\r\n\r\n    increment_generic: function increment_generic(inc, aDateAttr,\r\n                                                  aFactor, aNextIncrement) {\r\n      this.last[aDateAttr] += inc;\r\n      var nextunit = ICAL.helpers.trunc(this.last[aDateAttr] / aFactor);\r\n      this.last[aDateAttr] %= aFactor;\r\n      if (nextunit != 0) {\r\n        this[\"increment_\" + aNextIncrement](nextunit);\r\n      }\r\n    },\r\n\r\n    has_by_data: function has_by_data(aRuleType) {\r\n      return (aRuleType in this.rule.parts);\r\n    },\r\n\r\n    expand_year_days: function expand_year_days(aYear) {\r\n      var t = new ICAL.Time();\r\n      this.days = [];\r\n\r\n      // We need our own copy with a few keys set\r\n      var parts = {};\r\n      var rules = [\"BYDAY\", \"BYWEEKNO\", \"BYMONTHDAY\", \"BYMONTH\", \"BYYEARDAY\"];\r\n      for (var p in rules) {\r\n        /* istanbul ignore else */\r\n        if (rules.hasOwnProperty(p)) {\r\n          var part = rules[p];\r\n          if (part in this.rule.parts) {\r\n            parts[part] = this.rule.parts[part];\r\n          }\r\n        }\r\n      }\r\n\r\n      if (\"BYMONTH\" in parts && \"BYWEEKNO\" in parts) {\r\n        var valid = 1;\r\n        var validWeeks = {};\r\n        t.year = aYear;\r\n        t.isDate = true;\r\n\r\n        for (var monthIdx = 0; monthIdx < this.by_data.BYMONTH.length; monthIdx++) {\r\n          var month = this.by_data.BYMONTH[monthIdx];\r\n          t.month = month;\r\n          t.day = 1;\r\n          var first_week = t.weekNumber(this.rule.wkst);\r\n          t.day = ICAL.Time.daysInMonth(month, aYear);\r\n          var last_week = t.weekNumber(this.rule.wkst);\r\n          for (monthIdx = first_week; monthIdx < last_week; monthIdx++) {\r\n            validWeeks[monthIdx] = 1;\r\n          }\r\n        }\r\n\r\n        for (var weekIdx = 0; weekIdx < this.by_data.BYWEEKNO.length && valid; weekIdx++) {\r\n          var weekno = this.by_data.BYWEEKNO[weekIdx];\r\n          if (weekno < 52) {\r\n            valid &= validWeeks[weekIdx];\r\n          } else {\r\n            valid = 0;\r\n          }\r\n        }\r\n\r\n        if (valid) {\r\n          delete parts.BYMONTH;\r\n        } else {\r\n          delete parts.BYWEEKNO;\r\n        }\r\n      }\r\n\r\n      var partCount = Object.keys(parts).length;\r\n\r\n      if (partCount == 0) {\r\n        var t1 = this.dtstart.clone();\r\n        t1.year = this.last.year;\r\n        this.days.push(t1.dayOfYear());\r\n      } else if (partCount == 1 && \"BYMONTH\" in parts) {\r\n        for (var monthkey in this.by_data.BYMONTH) {\r\n          /* istanbul ignore if */\r\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\r\n            continue;\r\n          }\r\n          var t2 = this.dtstart.clone();\r\n          t2.year = aYear;\r\n          t2.month = this.by_data.BYMONTH[monthkey];\r\n          t2.isDate = true;\r\n          this.days.push(t2.dayOfYear());\r\n        }\r\n      } else if (partCount == 1 && \"BYMONTHDAY\" in parts) {\r\n        for (var monthdaykey in this.by_data.BYMONTHDAY) {\r\n          /* istanbul ignore if */\r\n          if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {\r\n            continue;\r\n          }\r\n          var t3 = this.dtstart.clone();\r\n          var day_ = this.by_data.BYMONTHDAY[monthdaykey];\r\n          if (day_ < 0) {\r\n            var daysInMonth = ICAL.Time.daysInMonth(t3.month, aYear);\r\n            day_ = day_ + daysInMonth + 1;\r\n          }\r\n          t3.day = day_;\r\n          t3.year = aYear;\r\n          t3.isDate = true;\r\n          this.days.push(t3.dayOfYear());\r\n        }\r\n      } else if (partCount == 2 &&\r\n                 \"BYMONTHDAY\" in parts &&\r\n                 \"BYMONTH\" in parts) {\r\n        for (var monthkey in this.by_data.BYMONTH) {\r\n          /* istanbul ignore if */\r\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\r\n            continue;\r\n          }\r\n          var month_ = this.by_data.BYMONTH[monthkey];\r\n          var daysInMonth = ICAL.Time.daysInMonth(month_, aYear);\r\n          for (var monthdaykey in this.by_data.BYMONTHDAY) {\r\n            /* istanbul ignore if */\r\n            if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {\r\n              continue;\r\n            }\r\n            var day_ = this.by_data.BYMONTHDAY[monthdaykey];\r\n            if (day_ < 0) {\r\n              day_ = day_ + daysInMonth + 1;\r\n            }\r\n            t.day = day_;\r\n            t.month = month_;\r\n            t.year = aYear;\r\n            t.isDate = true;\r\n\r\n            this.days.push(t.dayOfYear());\r\n          }\r\n        }\r\n      } else if (partCount == 1 && \"BYWEEKNO\" in parts) {\r\n        // TODO unimplemented in libical\r\n      } else if (partCount == 2 &&\r\n                 \"BYWEEKNO\" in parts &&\r\n                 \"BYMONTHDAY\" in parts) {\r\n        // TODO unimplemented in libical\r\n      } else if (partCount == 1 && \"BYDAY\" in parts) {\r\n        this.days = this.days.concat(this.expand_by_day(aYear));\r\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTH\" in parts) {\r\n        for (var monthkey in this.by_data.BYMONTH) {\r\n          /* istanbul ignore if */\r\n          if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {\r\n            continue;\r\n          }\r\n          var month = this.by_data.BYMONTH[monthkey];\r\n          var daysInMonth = ICAL.Time.daysInMonth(month, aYear);\r\n\r\n          t.year = aYear;\r\n          t.month = this.by_data.BYMONTH[monthkey];\r\n          t.day = 1;\r\n          t.isDate = true;\r\n\r\n          var first_dow = t.dayOfWeek();\r\n          var doy_offset = t.dayOfYear() - 1;\r\n\r\n          t.day = daysInMonth;\r\n          var last_dow = t.dayOfWeek();\r\n\r\n          if (this.has_by_data(\"BYSETPOS\")) {\r\n            var set_pos_counter = 0;\r\n            var by_month_day = [];\r\n            for (var day = 1; day <= daysInMonth; day++) {\r\n              t.day = day;\r\n              if (this.is_day_in_byday(t)) {\r\n                by_month_day.push(day);\r\n              }\r\n            }\r\n\r\n            for (var spIndex = 0; spIndex < by_month_day.length; spIndex++) {\r\n              if (this.check_set_position(spIndex + 1) ||\r\n                  this.check_set_position(spIndex - by_month_day.length)) {\r\n                this.days.push(doy_offset + by_month_day[spIndex]);\r\n              }\r\n            }\r\n          } else {\r\n            for (var daycodedkey in this.by_data.BYDAY) {\r\n              /* istanbul ignore if */\r\n              if (!this.by_data.BYDAY.hasOwnProperty(daycodedkey)) {\r\n                continue;\r\n              }\r\n              var coded_day = this.by_data.BYDAY[daycodedkey];\r\n              var bydayParts = this.ruleDayOfWeek(coded_day);\r\n              var pos = bydayParts[0];\r\n              var dow = bydayParts[1];\r\n              var month_day;\r\n\r\n              var first_matching_day = ((dow + 7 - first_dow) % 7) + 1;\r\n              var last_matching_day = daysInMonth - ((last_dow + 7 - dow) % 7);\r\n\r\n              if (pos == 0) {\r\n                for (var day = first_matching_day; day <= daysInMonth; day += 7) {\r\n                  this.days.push(doy_offset + day);\r\n                }\r\n              } else if (pos > 0) {\r\n                month_day = first_matching_day + (pos - 1) * 7;\r\n\r\n                if (month_day <= daysInMonth) {\r\n                  this.days.push(doy_offset + month_day);\r\n                }\r\n              } else {\r\n                month_day = last_matching_day + (pos + 1) * 7;\r\n\r\n                if (month_day > 0) {\r\n                  this.days.push(doy_offset + month_day);\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n        // Return dates in order of occurrence (1,2,3,...) instead\r\n        // of by groups of weekdays (1,8,15,...,2,9,16,...).\r\n        this.days.sort(function(a, b) { return a - b; }); // Comparator function allows to sort numbers.\r\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYMONTHDAY\" in parts) {\r\n        var expandedDays = this.expand_by_day(aYear);\r\n\r\n        for (var daykey in expandedDays) {\r\n          /* istanbul ignore if */\r\n          if (!expandedDays.hasOwnProperty(daykey)) {\r\n            continue;\r\n          }\r\n          var day = expandedDays[daykey];\r\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\r\n          if (this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\r\n            this.days.push(day);\r\n          }\r\n        }\r\n      } else if (partCount == 3 &&\r\n                 \"BYDAY\" in parts &&\r\n                 \"BYMONTHDAY\" in parts &&\r\n                 \"BYMONTH\" in parts) {\r\n        var expandedDays = this.expand_by_day(aYear);\r\n\r\n        for (var daykey in expandedDays) {\r\n          /* istanbul ignore if */\r\n          if (!expandedDays.hasOwnProperty(daykey)) {\r\n            continue;\r\n          }\r\n          var day = expandedDays[daykey];\r\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\r\n\r\n          if (this.by_data.BYMONTH.indexOf(tt.month) >= 0 &&\r\n              this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {\r\n            this.days.push(day);\r\n          }\r\n        }\r\n      } else if (partCount == 2 && \"BYDAY\" in parts && \"BYWEEKNO\" in parts) {\r\n        var expandedDays = this.expand_by_day(aYear);\r\n\r\n        for (var daykey in expandedDays) {\r\n          /* istanbul ignore if */\r\n          if (!expandedDays.hasOwnProperty(daykey)) {\r\n            continue;\r\n          }\r\n          var day = expandedDays[daykey];\r\n          var tt = ICAL.Time.fromDayOfYear(day, aYear);\r\n          var weekno = tt.weekNumber(this.rule.wkst);\r\n\r\n          if (this.by_data.BYWEEKNO.indexOf(weekno)) {\r\n            this.days.push(day);\r\n          }\r\n        }\r\n      } else if (partCount == 3 &&\r\n                 \"BYDAY\" in parts &&\r\n                 \"BYWEEKNO\" in parts &&\r\n                 \"BYMONTHDAY\" in parts) {\r\n        // TODO unimplemted in libical\r\n      } else if (partCount == 1 && \"BYYEARDAY\" in parts) {\r\n        this.days = this.days.concat(this.by_data.BYYEARDAY);\r\n      } else {\r\n        this.days = [];\r\n      }\r\n      return 0;\r\n    },\r\n\r\n    expand_by_day: function expand_by_day(aYear) {\r\n\r\n      var days_list = [];\r\n      var tmp = this.last.clone();\r\n\r\n      tmp.year = aYear;\r\n      tmp.month = 1;\r\n      tmp.day = 1;\r\n      tmp.isDate = true;\r\n\r\n      var start_dow = tmp.dayOfWeek();\r\n\r\n      tmp.month = 12;\r\n      tmp.day = 31;\r\n      tmp.isDate = true;\r\n\r\n      var end_dow = tmp.dayOfWeek();\r\n      var end_year_day = tmp.dayOfYear();\r\n\r\n      for (var daykey in this.by_data.BYDAY) {\r\n        /* istanbul ignore if */\r\n        if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {\r\n          continue;\r\n        }\r\n        var day = this.by_data.BYDAY[daykey];\r\n        var parts = this.ruleDayOfWeek(day);\r\n        var pos = parts[0];\r\n        var dow = parts[1];\r\n\r\n        if (pos == 0) {\r\n          var tmp_start_doy = ((dow + 7 - start_dow) % 7) + 1;\r\n\r\n          for (var doy = tmp_start_doy; doy <= end_year_day; doy += 7) {\r\n            days_list.push(doy);\r\n          }\r\n\r\n        } else if (pos > 0) {\r\n          var first;\r\n          if (dow >= start_dow) {\r\n            first = dow - start_dow + 1;\r\n          } else {\r\n            first = dow - start_dow + 8;\r\n          }\r\n\r\n          days_list.push(first + (pos - 1) * 7);\r\n        } else {\r\n          var last;\r\n          pos = -pos;\r\n\r\n          if (dow <= end_dow) {\r\n            last = end_year_day - end_dow + dow;\r\n          } else {\r\n            last = end_year_day - end_dow + dow - 7;\r\n          }\r\n\r\n          days_list.push(last - (pos - 1) * 7);\r\n        }\r\n      }\r\n      return days_list;\r\n    },\r\n\r\n    is_day_in_byday: function is_day_in_byday(tt) {\r\n      for (var daykey in this.by_data.BYDAY) {\r\n        /* istanbul ignore if */\r\n        if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {\r\n          continue;\r\n        }\r\n        var day = this.by_data.BYDAY[daykey];\r\n        var parts = this.ruleDayOfWeek(day);\r\n        var pos = parts[0];\r\n        var dow = parts[1];\r\n        var this_dow = tt.dayOfWeek();\r\n\r\n        if ((pos == 0 && dow == this_dow) ||\r\n            (tt.nthWeekDay(dow, pos) == tt.day)) {\r\n          return 1;\r\n        }\r\n      }\r\n\r\n      return 0;\r\n    },\r\n\r\n    /**\r\n     * Checks if given value is in BYSETPOS.\r\n     *\r\n     * @private\r\n     * @param {Numeric} aPos position to check for.\r\n     * @return {Boolean} false unless BYSETPOS rules exist\r\n     *                   and the given value is present in rules.\r\n     */\r\n    check_set_position: function check_set_position(aPos) {\r\n      if (this.has_by_data('BYSETPOS')) {\r\n        var idx = this.by_data.BYSETPOS.indexOf(aPos);\r\n        // negative numbers are not false-y\r\n        return idx !== -1;\r\n      }\r\n      return false;\r\n    },\r\n\r\n    sort_byday_rules: function icalrecur_sort_byday_rules(aRules) {\r\n      for (var i = 0; i < aRules.length; i++) {\r\n        for (var j = 0; j < i; j++) {\r\n          var one = this.ruleDayOfWeek(aRules[j], this.rule.wkst)[1];\r\n          var two = this.ruleDayOfWeek(aRules[i], this.rule.wkst)[1];\r\n\r\n          if (one > two) {\r\n            var tmp = aRules[i];\r\n            aRules[i] = aRules[j];\r\n            aRules[j] = tmp;\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    check_contract_restriction: function check_contract_restriction(aRuleType, v) {\r\n      var indexMapValue = icalrecur_iterator._indexMap[aRuleType];\r\n      var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];\r\n      var pass = false;\r\n\r\n      if (aRuleType in this.by_data &&\r\n          ruleMapValue == icalrecur_iterator.CONTRACT) {\r\n\r\n        var ruleType = this.by_data[aRuleType];\r\n\r\n        for (var bydatakey in ruleType) {\r\n          /* istanbul ignore else */\r\n          if (ruleType.hasOwnProperty(bydatakey)) {\r\n            if (ruleType[bydatakey] == v) {\r\n              pass = true;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        // Not a contracting byrule or has no data, test passes\r\n        pass = true;\r\n      }\r\n      return pass;\r\n    },\r\n\r\n    check_contracting_rules: function check_contracting_rules() {\r\n      var dow = this.last.dayOfWeek();\r\n      var weekNo = this.last.weekNumber(this.rule.wkst);\r\n      var doy = this.last.dayOfYear();\r\n\r\n      return (this.check_contract_restriction(\"BYSECOND\", this.last.second) &&\r\n              this.check_contract_restriction(\"BYMINUTE\", this.last.minute) &&\r\n              this.check_contract_restriction(\"BYHOUR\", this.last.hour) &&\r\n              this.check_contract_restriction(\"BYDAY\", ICAL.Recur.numericDayToIcalDay(dow)) &&\r\n              this.check_contract_restriction(\"BYWEEKNO\", weekNo) &&\r\n              this.check_contract_restriction(\"BYMONTHDAY\", this.last.day) &&\r\n              this.check_contract_restriction(\"BYMONTH\", this.last.month) &&\r\n              this.check_contract_restriction(\"BYYEARDAY\", doy));\r\n    },\r\n\r\n    setup_defaults: function setup_defaults(aRuleType, req, deftime) {\r\n      var indexMapValue = icalrecur_iterator._indexMap[aRuleType];\r\n      var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];\r\n\r\n      if (ruleMapValue != icalrecur_iterator.CONTRACT) {\r\n        if (!(aRuleType in this.by_data)) {\r\n          this.by_data[aRuleType] = [deftime];\r\n        }\r\n        if (this.rule.freq != req) {\r\n          return this.by_data[aRuleType][0];\r\n        }\r\n      }\r\n      return deftime;\r\n    },\r\n\r\n    /**\r\n     * Convert iterator into a serialize-able object.  Will preserve current\r\n     * iteration sequence to ensure the seamless continuation of the recurrence\r\n     * rule.\r\n     * @return {Object}\r\n     */\r\n    toJSON: function() {\r\n      var result = Object.create(null);\r\n\r\n      result.initialized = this.initialized;\r\n      result.rule = this.rule.toJSON();\r\n      result.dtstart = this.dtstart.toJSON();\r\n      result.by_data = this.by_data;\r\n      result.days = this.days;\r\n      result.last = this.last.toJSON();\r\n      result.by_indices = this.by_indices;\r\n      result.occurrence_number = this.occurrence_number;\r\n\r\n      return result;\r\n    }\r\n  };\r\n\r\n  icalrecur_iterator._indexMap = {\r\n    \"BYSECOND\": 0,\r\n    \"BYMINUTE\": 1,\r\n    \"BYHOUR\": 2,\r\n    \"BYDAY\": 3,\r\n    \"BYMONTHDAY\": 4,\r\n    \"BYYEARDAY\": 5,\r\n    \"BYWEEKNO\": 6,\r\n    \"BYMONTH\": 7,\r\n    \"BYSETPOS\": 8\r\n  };\r\n\r\n  icalrecur_iterator._expandMap = {\r\n    \"SECONDLY\": [1, 1, 1, 1, 1, 1, 1, 1],\r\n    \"MINUTELY\": [2, 1, 1, 1, 1, 1, 1, 1],\r\n    \"HOURLY\": [2, 2, 1, 1, 1, 1, 1, 1],\r\n    \"DAILY\": [2, 2, 2, 1, 1, 1, 1, 1],\r\n    \"WEEKLY\": [2, 2, 2, 2, 3, 3, 1, 1],\r\n    \"MONTHLY\": [2, 2, 2, 2, 2, 3, 3, 1],\r\n    \"YEARLY\": [2, 2, 2, 2, 2, 2, 2, 2]\r\n  };\r\n  icalrecur_iterator.UNKNOWN = 0;\r\n  icalrecur_iterator.CONTRACT = 1;\r\n  icalrecur_iterator.EXPAND = 2;\r\n  icalrecur_iterator.ILLEGAL = 3;\r\n\r\n  return icalrecur_iterator;\r\n\r\n}());\r\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\r\n\r\n\r\n/**\r\n * This symbol is further described later on\r\n * @ignore\r\n */\r\nICAL.RecurExpansion = (function() {\r\n  function formatTime(item) {\r\n    return ICAL.helpers.formatClassType(item, ICAL.Time);\r\n  }\r\n\r\n  function compareTime(a, b) {\r\n    return a.compare(b);\r\n  }\r\n\r\n  function isRecurringComponent(comp) {\r\n    return comp.hasProperty('rdate') ||\r\n           comp.hasProperty('rrule') ||\r\n           comp.hasProperty('recurrence-id');\r\n  }\r\n\r\n  /**\r\n   * @classdesc\r\n   * Primary class for expanding recurring rules.  Can take multiple rrules,\r\n   * rdates, exdate(s) and iterate (in order) over each next occurrence.\r\n   *\r\n   * Once initialized this class can also be serialized saved and continue\r\n   * iteration from the last point.\r\n   *\r\n   * NOTE: it is intended that this class is to be used\r\n   *       with ICAL.Event which handles recurrence exceptions.\r\n   *\r\n   * @example\r\n   * // assuming event is a parsed ical component\r\n   * var event;\r\n   *\r\n   * var expand = new ICAL.RecurExpansion({\r\n   *   component: event,\r\n   *   dtstart: event.getFirstPropertyValue('dtstart')\r\n   * });\r\n   *\r\n   * // remember there are infinite rules\r\n   * // so its a good idea to limit the scope\r\n   * // of the iterations then resume later on.\r\n   *\r\n   * // next is always an ICAL.Time or null\r\n   * var next;\r\n   *\r\n   * while (someCondition && (next = expand.next())) {\r\n   *   // do something with next\r\n   * }\r\n   *\r\n   * // save instance for later\r\n   * var json = JSON.stringify(expand);\r\n   *\r\n   * //...\r\n   *\r\n   * // NOTE: if the component's properties have\r\n   * //       changed you will need to rebuild the\r\n   * //       class and start over. This only works\r\n   * //       when the component's recurrence info is the same.\r\n   * var expand = new ICAL.RecurExpansion(JSON.parse(json));\r\n   *\r\n   * @description\r\n   * The options object can be filled with the specified initial values. It can\r\n   * also contain additional members, as a result of serializing a previous\r\n   * expansion state, as shown in the example.\r\n   *\r\n   * @class\r\n   * @alias ICAL.RecurExpansion\r\n   * @param {Object} options\r\n   *        Recurrence expansion options\r\n   * @param {ICAL.Time} options.dtstart\r\n   *        Start time of the event\r\n   * @param {ICAL.Component=} options.component\r\n   *        Component for expansion, required if not resuming.\r\n   */\r\n  function RecurExpansion(options) {\r\n    this.ruleDates = [];\r\n    this.exDates = [];\r\n    this.fromData(options);\r\n  }\r\n\r\n  RecurExpansion.prototype = {\r\n    /**\r\n     * True when iteration is fully completed.\r\n     * @type {Boolean}\r\n     */\r\n    complete: false,\r\n\r\n    /**\r\n     * Array of rrule iterators.\r\n     *\r\n     * @type {ICAL.RecurIterator[]}\r\n     * @private\r\n     */\r\n    ruleIterators: null,\r\n\r\n    /**\r\n     * Array of rdate instances.\r\n     *\r\n     * @type {ICAL.Time[]}\r\n     * @private\r\n     */\r\n    ruleDates: null,\r\n\r\n    /**\r\n     * Array of exdate instances.\r\n     *\r\n     * @type {ICAL.Time[]}\r\n     * @private\r\n     */\r\n    exDates: null,\r\n\r\n    /**\r\n     * Current position in ruleDates array.\r\n     * @type {Number}\r\n     * @private\r\n     */\r\n    ruleDateInc: 0,\r\n\r\n    /**\r\n     * Current position in exDates array\r\n     * @type {Number}\r\n     * @private\r\n     */\r\n    exDateInc: 0,\r\n\r\n    /**\r\n     * Current negative date.\r\n     *\r\n     * @type {ICAL.Time}\r\n     * @private\r\n     */\r\n    exDate: null,\r\n\r\n    /**\r\n     * Current additional date.\r\n     *\r\n     * @type {ICAL.Time}\r\n     * @private\r\n     */\r\n    ruleDate: null,\r\n\r\n    /**\r\n     * Start date of recurring rules.\r\n     *\r\n     * @type {ICAL.Time}\r\n     */\r\n    dtstart: null,\r\n\r\n    /**\r\n     * Last expanded time\r\n     *\r\n     * @type {ICAL.Time}\r\n     */\r\n    last: null,\r\n\r\n    /**\r\n     * Initialize the recurrence expansion from the data object. The options\r\n     * object may also contain additional members, see the\r\n     * {@link ICAL.RecurExpansion constructor} for more details.\r\n     *\r\n     * @param {Object} options\r\n     *        Recurrence expansion options\r\n     * @param {ICAL.Time} options.dtstart\r\n     *        Start time of the event\r\n     * @param {ICAL.Component=} options.component\r\n     *        Component for expansion, required if not resuming.\r\n     */\r\n    fromData: function(options) {\r\n      var start = ICAL.helpers.formatClassType(options.dtstart, ICAL.Time);\r\n\r\n      if (!start) {\r\n        throw new Error('.dtstart (ICAL.Time) must be given');\r\n      } else {\r\n        this.dtstart = start;\r\n      }\r\n\r\n      if (options.component) {\r\n        this._init(options.component);\r\n      } else {\r\n        this.last = formatTime(options.last) || start.clone();\r\n\r\n        if (!options.ruleIterators) {\r\n          throw new Error('.ruleIterators or .component must be given');\r\n        }\r\n\r\n        this.ruleIterators = options.ruleIterators.map(function(item) {\r\n          return ICAL.helpers.formatClassType(item, ICAL.RecurIterator);\r\n        });\r\n\r\n        this.ruleDateInc = options.ruleDateInc;\r\n        this.exDateInc = options.exDateInc;\r\n\r\n        if (options.ruleDates) {\r\n          this.ruleDates = options.ruleDates.map(formatTime);\r\n          this.ruleDate = this.ruleDates[this.ruleDateInc];\r\n        }\r\n\r\n        if (options.exDates) {\r\n          this.exDates = options.exDates.map(formatTime);\r\n          this.exDate = this.exDates[this.exDateInc];\r\n        }\r\n\r\n        if (typeof(options.complete) !== 'undefined') {\r\n          this.complete = options.complete;\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Retrieve the next occurrence in the series.\r\n     * @return {ICAL.Time}\r\n     */\r\n    next: function() {\r\n      var iter;\r\n      var ruleOfDay;\r\n      var next;\r\n      var compare;\r\n\r\n      var maxTries = 500;\r\n      var currentTry = 0;\r\n\r\n      while (true) {\r\n        if (currentTry++ > maxTries) {\r\n          throw new Error(\r\n            'max tries have occured, rule may be impossible to forfill.'\r\n          );\r\n        }\r\n\r\n        next = this.ruleDate;\r\n        iter = this._nextRecurrenceIter(this.last);\r\n\r\n        // no more matches\r\n        // because we increment the rule day or rule\r\n        // _after_ we choose a value this should be\r\n        // the only spot where we need to worry about the\r\n        // end of events.\r\n        if (!next && !iter) {\r\n          // there are no more iterators or rdates\r\n          this.complete = true;\r\n          break;\r\n        }\r\n\r\n        // no next rule day or recurrence rule is first.\r\n        if (!next || (iter && next.compare(iter.last) > 0)) {\r\n          // must be cloned, recur will reuse the time element.\r\n          next = iter.last.clone();\r\n          // move to next so we can continue\r\n          iter.next();\r\n        }\r\n\r\n        // if the ruleDate is still next increment it.\r\n        if (this.ruleDate === next) {\r\n          this._nextRuleDay();\r\n        }\r\n\r\n        this.last = next;\r\n\r\n        // check the negative rules\r\n        if (this.exDate) {\r\n          compare = this.exDate.compare(this.last);\r\n\r\n          if (compare < 0) {\r\n            this._nextExDay();\r\n          }\r\n\r\n          // if the current rule is excluded skip it.\r\n          if (compare === 0) {\r\n            this._nextExDay();\r\n            continue;\r\n          }\r\n        }\r\n\r\n        //XXX: The spec states that after we resolve the final\r\n        //     list of dates we execute exdate this seems somewhat counter\r\n        //     intuitive to what I have seen most servers do so for now\r\n        //     I exclude based on the original date not the one that may\r\n        //     have been modified by the exception.\r\n        return this.last;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Converts object into a serialize-able format. This format can be passed\r\n     * back into the expansion to resume iteration.\r\n     * @return {Object}\r\n     */\r\n    toJSON: function() {\r\n      function toJSON(item) {\r\n        return item.toJSON();\r\n      }\r\n\r\n      var result = Object.create(null);\r\n      result.ruleIterators = this.ruleIterators.map(toJSON);\r\n\r\n      if (this.ruleDates) {\r\n        result.ruleDates = this.ruleDates.map(toJSON);\r\n      }\r\n\r\n      if (this.exDates) {\r\n        result.exDates = this.exDates.map(toJSON);\r\n      }\r\n\r\n      result.ruleDateInc = this.ruleDateInc;\r\n      result.exDateInc = this.exDateInc;\r\n      result.last = this.last.toJSON();\r\n      result.dtstart = this.dtstart.toJSON();\r\n      result.complete = this.complete;\r\n\r\n      return result;\r\n    },\r\n\r\n    /**\r\n     * Extract all dates from the properties in the given component. The\r\n     * properties will be filtered by the property name.\r\n     *\r\n     * @private\r\n     * @param {ICAL.Component} component        The component to search in\r\n     * @param {String} propertyName             The property name to search for\r\n     * @return {ICAL.Time[]}                    The extracted dates.\r\n     */\r\n    _extractDates: function(component, propertyName) {\r\n      function handleProp(prop) {\r\n        idx = ICAL.helpers.binsearchInsert(\r\n          result,\r\n          prop,\r\n          compareTime\r\n        );\r\n\r\n        // ordered insert\r\n        result.splice(idx, 0, prop);\r\n      }\r\n\r\n      var result = [];\r\n      var props = component.getAllProperties(propertyName);\r\n      var len = props.length;\r\n      var i = 0;\r\n      var prop;\r\n\r\n      var idx;\r\n\r\n      for (; i < len; i++) {\r\n        props[i].getValues().forEach(handleProp);\r\n      }\r\n\r\n      return result;\r\n    },\r\n\r\n    /**\r\n     * Initialize the recurrence expansion.\r\n     *\r\n     * @private\r\n     * @param {ICAL.Component} component    The component to initialize from.\r\n     */\r\n    _init: function(component) {\r\n      this.ruleIterators = [];\r\n\r\n      this.last = this.dtstart.clone();\r\n\r\n      // to provide api consistency non-recurring\r\n      // events can also use the iterator though it will\r\n      // only return a single time.\r\n      if (!isRecurringComponent(component)) {\r\n        this.ruleDate = this.last.clone();\r\n        this.complete = true;\r\n        return;\r\n      }\r\n\r\n      if (component.hasProperty('rdate')) {\r\n        this.ruleDates = this._extractDates(component, 'rdate');\r\n\r\n        // special hack for cases where first rdate is prior\r\n        // to the start date. We only check for the first rdate.\r\n        // This is mostly for google's crazy recurring date logic\r\n        // (contacts birthdays).\r\n        if ((this.ruleDates[0]) &&\r\n            (this.ruleDates[0].compare(this.dtstart) < 0)) {\r\n\r\n          this.ruleDateInc = 0;\r\n          this.last = this.ruleDates[0].clone();\r\n        } else {\r\n          this.ruleDateInc = ICAL.helpers.binsearchInsert(\r\n            this.ruleDates,\r\n            this.last,\r\n            compareTime\r\n          );\r\n        }\r\n\r\n        this.ruleDate = this.ruleDates[this.ruleDateInc];\r\n      }\r\n\r\n      if (component.hasProperty('rrule')) {\r\n        var rules = component.getAllProperties('rrule');\r\n        var i = 0;\r\n        var len = rules.length;\r\n\r\n        var rule;\r\n        var iter;\r\n\r\n        for (; i < len; i++) {\r\n          rule = rules[i].getFirstValue();\r\n          iter = rule.iterator(this.dtstart);\r\n          this.ruleIterators.push(iter);\r\n\r\n          // increment to the next occurrence so future\r\n          // calls to next return times beyond the initial iteration.\r\n          // XXX: I find this suspicious might be a bug?\r\n          iter.next();\r\n        }\r\n      }\r\n\r\n      if (component.hasProperty('exdate')) {\r\n        this.exDates = this._extractDates(component, 'exdate');\r\n        // if we have a .last day we increment the index to beyond it.\r\n        this.exDateInc = ICAL.helpers.binsearchInsert(\r\n          this.exDates,\r\n          this.last,\r\n          compareTime\r\n        );\r\n\r\n        this.exDate = this.exDates[this.exDateInc];\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Advance to the next exdate\r\n     * @private\r\n     */\r\n    _nextExDay: function() {\r\n      this.exDate = this.exDates[++this.exDateInc];\r\n    },\r\n\r\n    /**\r\n     * Advance to the next rule date\r\n     * @private\r\n     */\r\n    _nextRuleDay: function() {\r\n      this.ruleDate = this.ruleDates[++this.ruleDateInc];\r\n    },\r\n\r\n    /**\r\n     * Find and return the recurrence rule with the most recent event and\r\n     * return it.\r\n     *\r\n     * @private\r\n     * @return {?ICAL.RecurIterator}    Found iterator.\r\n     */\r\n    _nextRecurrenceIter: function() {\r\n      var iters = this.ruleIterators;\r\n\r\n      if (iters.length === 0) {\r\n        return null;\r\n      }\r\n\r\n      var len = iters.length;\r\n      var iter;\r\n      var iterTime;\r\n      var iterIdx = 0;\r\n      var chosenIter;\r\n\r\n      // loop through each iterator\r\n      for (; iterIdx < len; iterIdx++) {\r\n        iter = iters[iterIdx];\r\n        iterTime = iter.last;\r\n\r\n        // if iteration is complete\r\n        // then we must exclude it from\r\n        // the search and remove it.\r\n        if (iter.completed) {\r\n          len--;\r\n          if (iterIdx !== 0) {\r\n            iterIdx--;\r\n          }\r\n          iters.splice(iterIdx, 1);\r\n          continue;\r\n        }\r\n\r\n        // find the most recent possible choice\r\n        if (!chosenIter || chosenIter.last.compare(iterTime) > 0) {\r\n          // that iterator is saved\r\n          chosenIter = iter;\r\n        }\r\n      }\r\n\r\n      // the chosen iterator is returned but not mutated\r\n      // this iterator contains the most recent event.\r\n      return chosenIter;\r\n    }\r\n  };\r\n\r\n  return RecurExpansion;\r\n}());\r\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\r\n\r\n\r\n/**\r\n * This symbol is further described later on\r\n * @ignore\r\n */\r\nICAL.Event = (function() {\r\n\r\n  /**\r\n   * @classdesc\r\n   * ICAL.js is organized into multiple layers. The bottom layer is a raw jCal\r\n   * object, followed by the component/property layer. The highest level is the\r\n   * event representation, which this class is part of. See the\r\n   * {@tutorial layers} guide for more details.\r\n   *\r\n   * @class\r\n   * @alias ICAL.Event\r\n   * @param {ICAL.Component=} component         The ICAL.Component to base this event on\r\n   * @param {Object} options                    Options for this event\r\n   * @param {Boolean} options.strictExceptions\r\n   *          When true, will verify exceptions are related by their UUID\r\n   * @param {Array<ICAL.Component|ICAL.Event>} options.exceptions\r\n   *          Exceptions to this event, either as components or events. If not\r\n   *            specified exceptions will automatically be set in relation of\r\n   *            component's parent\r\n   */\r\n  function Event(component, options) {\r\n    if (!(component instanceof ICAL.Component)) {\r\n      options = component;\r\n      component = null;\r\n    }\r\n\r\n    if (component) {\r\n      this.component = component;\r\n    } else {\r\n      this.component = new ICAL.Component('vevent');\r\n    }\r\n\r\n    this._rangeExceptionCache = Object.create(null);\r\n    this.exceptions = Object.create(null);\r\n    this.rangeExceptions = [];\r\n\r\n    if (options && options.strictExceptions) {\r\n      this.strictExceptions = options.strictExceptions;\r\n    }\r\n\r\n    if (options && options.exceptions) {\r\n      options.exceptions.forEach(this.relateException, this);\r\n    } else if (this.component.parent && !this.isRecurrenceException()) {\r\n      this.component.parent.getAllSubcomponents('vevent').forEach(function(event) {\r\n        if (event.hasProperty('recurrence-id')) {\r\n          this.relateException(event);\r\n        }\r\n      }, this);\r\n    }\r\n  }\r\n\r\n  Event.prototype = {\r\n\r\n    THISANDFUTURE: 'THISANDFUTURE',\r\n\r\n    /**\r\n     * List of related event exceptions.\r\n     *\r\n     * @type {ICAL.Event[]}\r\n     */\r\n    exceptions: null,\r\n\r\n    /**\r\n     * When true, will verify exceptions are related by their UUID.\r\n     *\r\n     * @type {Boolean}\r\n     */\r\n    strictExceptions: false,\r\n\r\n    /**\r\n     * Relates a given event exception to this object.  If the given component\r\n     * does not share the UID of this event it cannot be related and will throw\r\n     * an exception.\r\n     *\r\n     * If this component is an exception it cannot have other exceptions\r\n     * related to it.\r\n     *\r\n     * @param {ICAL.Component|ICAL.Event} obj       Component or event\r\n     */\r\n    relateException: function(obj) {\r\n      if (this.isRecurrenceException()) {\r\n        throw new Error('cannot relate exception to exceptions');\r\n      }\r\n\r\n      if (obj instanceof ICAL.Component) {\r\n        obj = new ICAL.Event(obj);\r\n      }\r\n\r\n      if (this.strictExceptions && obj.uid !== this.uid) {\r\n        throw new Error('attempted to relate unrelated exception');\r\n      }\r\n\r\n      var id = obj.recurrenceId.toString();\r\n\r\n      // we don't sort or manage exceptions directly\r\n      // here the recurrence expander handles that.\r\n      this.exceptions[id] = obj;\r\n\r\n      // index RANGE=THISANDFUTURE exceptions so we can\r\n      // look them up later in getOccurrenceDetails.\r\n      if (obj.modifiesFuture()) {\r\n        var item = [\r\n          obj.recurrenceId.toUnixTime(), id\r\n        ];\r\n\r\n        // we keep them sorted so we can find the nearest\r\n        // value later on...\r\n        var idx = ICAL.helpers.binsearchInsert(\r\n          this.rangeExceptions,\r\n          item,\r\n          compareRangeException\r\n        );\r\n\r\n        this.rangeExceptions.splice(idx, 0, item);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Checks if this record is an exception and has the RANGE=THISANDFUTURE\r\n     * value.\r\n     *\r\n     * @return {Boolean}        True, when exception is within range\r\n     */\r\n    modifiesFuture: function() {\r\n      if (!this.component.hasProperty('recurrence-id')) {\r\n        return false;\r\n      }\r\n\r\n      var range = this.component.getFirstProperty('recurrence-id').getParameter('range');\r\n      return range === this.THISANDFUTURE;\r\n    },\r\n\r\n    /**\r\n     * Finds the range exception nearest to the given date.\r\n     *\r\n     * @param {ICAL.Time} time usually an occurrence time of an event\r\n     * @return {?ICAL.Event} the related event/exception or null\r\n     */\r\n    findRangeException: function(time) {\r\n      if (!this.rangeExceptions.length) {\r\n        return null;\r\n      }\r\n\r\n      var utc = time.toUnixTime();\r\n      var idx = ICAL.helpers.binsearchInsert(\r\n        this.rangeExceptions,\r\n        [utc],\r\n        compareRangeException\r\n      );\r\n\r\n      idx -= 1;\r\n\r\n      // occurs before\r\n      if (idx < 0) {\r\n        return null;\r\n      }\r\n\r\n      var rangeItem = this.rangeExceptions[idx];\r\n\r\n      /* istanbul ignore next: sanity check only */\r\n      if (utc < rangeItem[0]) {\r\n        return null;\r\n      }\r\n\r\n      return rangeItem[1];\r\n    },\r\n\r\n    /**\r\n     * This object is returned by {@link ICAL.Event#getOccurrenceDetails getOccurrenceDetails}\r\n     *\r\n     * @typedef {Object} occurrenceDetails\r\n     * @memberof ICAL.Event\r\n     * @property {ICAL.Time} recurrenceId       The passed in recurrence id\r\n     * @property {ICAL.Event} item              The occurrence\r\n     * @property {ICAL.Time} startDate          The start of the occurrence\r\n     * @property {ICAL.Time} endDate            The end of the occurrence\r\n     */\r\n\r\n    /**\r\n     * Returns the occurrence details based on its start time.  If the\r\n     * occurrence has an exception will return the details for that exception.\r\n     *\r\n     * NOTE: this method is intend to be used in conjunction\r\n     *       with the {@link ICAL.Event#iterator iterator} method.\r\n     *\r\n     * @param {ICAL.Time} occurrence time occurrence\r\n     * @return {ICAL.Event.occurrenceDetails} Information about the occurrence\r\n     */\r\n    getOccurrenceDetails: function(occurrence) {\r\n      var id = occurrence.toString();\r\n      var utcId = occurrence.convertToZone(ICAL.Timezone.utcTimezone).toString();\r\n      var item;\r\n      var result = {\r\n        //XXX: Clone?\r\n        recurrenceId: occurrence\r\n      };\r\n\r\n      if (id in this.exceptions) {\r\n        item = result.item = this.exceptions[id];\r\n        result.startDate = item.startDate;\r\n        result.endDate = item.endDate;\r\n        result.item = item;\r\n      } else if (utcId in this.exceptions) {\r\n        item = this.exceptions[utcId];\r\n        result.startDate = item.startDate;\r\n        result.endDate = item.endDate;\r\n        result.item = item;\r\n      } else {\r\n        // range exceptions (RANGE=THISANDFUTURE) have a\r\n        // lower priority then direct exceptions but\r\n        // must be accounted for first. Their item is\r\n        // always the first exception with the range prop.\r\n        var rangeExceptionId = this.findRangeException(\r\n          occurrence\r\n        );\r\n        var end;\r\n\r\n        if (rangeExceptionId) {\r\n          var exception = this.exceptions[rangeExceptionId];\r\n\r\n          // range exception must modify standard time\r\n          // by the difference (if any) in start/end times.\r\n          result.item = exception;\r\n\r\n          var startDiff = this._rangeExceptionCache[rangeExceptionId];\r\n\r\n          if (!startDiff) {\r\n            var original = exception.recurrenceId.clone();\r\n            var newStart = exception.startDate.clone();\r\n\r\n            // zones must be same otherwise subtract may be incorrect.\r\n            original.zone = newStart.zone;\r\n            startDiff = newStart.subtractDate(original);\r\n\r\n            this._rangeExceptionCache[rangeExceptionId] = startDiff;\r\n          }\r\n\r\n          var start = occurrence.clone();\r\n          start.zone = exception.startDate.zone;\r\n          start.addDuration(startDiff);\r\n\r\n          end = start.clone();\r\n          end.addDuration(exception.duration);\r\n\r\n          result.startDate = start;\r\n          result.endDate = end;\r\n        } else {\r\n          // no range exception standard expansion\r\n          end = occurrence.clone();\r\n          end.addDuration(this.duration);\r\n\r\n          result.endDate = end;\r\n          result.startDate = occurrence;\r\n          result.item = this;\r\n        }\r\n      }\r\n\r\n      return result;\r\n    },\r\n\r\n    /**\r\n     * Builds a recur expansion instance for a specific point in time (defaults\r\n     * to startDate).\r\n     *\r\n     * @param {ICAL.Time} startTime     Starting point for expansion\r\n     * @return {ICAL.RecurExpansion}    Expansion object\r\n     */\r\n    iterator: function(startTime) {\r\n      return new ICAL.RecurExpansion({\r\n        component: this.component,\r\n        dtstart: startTime || this.startDate\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Checks if the event is recurring\r\n     *\r\n     * @return {Boolean}        True, if event is recurring\r\n     */\r\n    isRecurring: function() {\r\n      var comp = this.component;\r\n      return comp.hasProperty('rrule') || comp.hasProperty('rdate');\r\n    },\r\n\r\n    /**\r\n     * Checks if the event describes a recurrence exception. See\r\n     * {@tutorial terminology} for details.\r\n     *\r\n     * @return {Boolean}    True, if the even describes a recurrence exception\r\n     */\r\n    isRecurrenceException: function() {\r\n      return this.component.hasProperty('recurrence-id');\r\n    },\r\n\r\n    /**\r\n     * Returns the types of recurrences this event may have.\r\n     *\r\n     * Returned as an object with the following possible keys:\r\n     *\r\n     *    - YEARLY\r\n     *    - MONTHLY\r\n     *    - WEEKLY\r\n     *    - DAILY\r\n     *    - MINUTELY\r\n     *    - SECONDLY\r\n     *\r\n     * @return {Object.<ICAL.Recur.frequencyValues, Boolean>}\r\n     *          Object of recurrence flags\r\n     */\r\n    getRecurrenceTypes: function() {\r\n      var rules = this.component.getAllProperties('rrule');\r\n      var i = 0;\r\n      var len = rules.length;\r\n      var result = Object.create(null);\r\n\r\n      for (; i < len; i++) {\r\n        var value = rules[i].getFirstValue();\r\n        result[value.freq] = true;\r\n      }\r\n\r\n      return result;\r\n    },\r\n\r\n    /**\r\n     * The uid of this event\r\n     * @type {String}\r\n     */\r\n    get uid() {\r\n      return this._firstProp('uid');\r\n    },\r\n\r\n    set uid(value) {\r\n      this._setProp('uid', value);\r\n    },\r\n\r\n    /**\r\n     * The start date\r\n     * @type {ICAL.Time}\r\n     */\r\n    get startDate() {\r\n      return this._firstProp('dtstart');\r\n    },\r\n\r\n    set startDate(value) {\r\n      this._setTime('dtstart', value);\r\n    },\r\n\r\n    /**\r\n     * The end date. This can be the result directly from the property, or the\r\n     * end date calculated from start date and duration. Setting the property\r\n     * will remove any duration properties.\r\n     * @type {ICAL.Time}\r\n     */\r\n    get endDate() {\r\n      var endDate = this._firstProp('dtend');\r\n      if (!endDate) {\r\n          var duration = this._firstProp('duration');\r\n          endDate = this.startDate.clone();\r\n          if (duration) {\r\n              endDate.addDuration(duration);\r\n          } else if (endDate.isDate) {\r\n              endDate.day += 1;\r\n          }\r\n      }\r\n      return endDate;\r\n    },\r\n\r\n    set endDate(value) {\r\n      if (this.component.hasProperty('duration')) {\r\n        this.component.removeProperty('duration');\r\n      }\r\n      this._setTime('dtend', value);\r\n    },\r\n\r\n    /**\r\n     * The duration. This can be the result directly from the property, or the\r\n     * duration calculated from start date and end date. Setting the property\r\n     * will remove any `dtend` properties.\r\n     * @type {ICAL.Duration}\r\n     */\r\n    get duration() {\r\n      var duration = this._firstProp('duration');\r\n      if (!duration) {\r\n        return this.endDate.subtractDateTz(this.startDate);\r\n      }\r\n      return duration;\r\n    },\r\n\r\n    set duration(value) {\r\n      if (this.component.hasProperty('dtend')) {\r\n        this.component.removeProperty('dtend');\r\n      }\r\n\r\n      this._setProp('duration', value);\r\n    },\r\n\r\n    /**\r\n     * The location of the event.\r\n     * @type {String}\r\n     */\r\n    get location() {\r\n      return this._firstProp('location');\r\n    },\r\n\r\n    set location(value) {\r\n      return this._setProp('location', value);\r\n    },\r\n\r\n    /**\r\n     * The attendees in the event\r\n     * @type {ICAL.Property[]}\r\n     * @readonly\r\n     */\r\n    get attendees() {\r\n      //XXX: This is way lame we should have a better\r\n      //     data structure for this later.\r\n      return this.component.getAllProperties('attendee');\r\n    },\r\n\r\n\r\n    /**\r\n     * The event summary\r\n     * @type {String}\r\n     */\r\n    get summary() {\r\n      return this._firstProp('summary');\r\n    },\r\n\r\n    set summary(value) {\r\n      this._setProp('summary', value);\r\n    },\r\n\r\n    /**\r\n     * The event description.\r\n     * @type {String}\r\n     */\r\n    get description() {\r\n      return this._firstProp('description');\r\n    },\r\n\r\n    set description(value) {\r\n      this._setProp('description', value);\r\n    },\r\n\r\n    /**\r\n     * The organizer value as an uri. In most cases this is a mailto: uri, but\r\n     * it can also be something else, like urn:uuid:...\r\n     * @type {String}\r\n     */\r\n    get organizer() {\r\n      return this._firstProp('organizer');\r\n    },\r\n\r\n    set organizer(value) {\r\n      this._setProp('organizer', value);\r\n    },\r\n\r\n    /**\r\n     * The sequence value for this event. Used for scheduling\r\n     * see {@tutorial terminology}.\r\n     * @type {Number}\r\n     */\r\n    get sequence() {\r\n      return this._firstProp('sequence');\r\n    },\r\n\r\n    set sequence(value) {\r\n      this._setProp('sequence', value);\r\n    },\r\n\r\n    /**\r\n     * The recurrence id for this event. See {@tutorial terminology} for details.\r\n     * @type {ICAL.Time}\r\n     */\r\n    get recurrenceId() {\r\n      return this._firstProp('recurrence-id');\r\n    },\r\n\r\n    set recurrenceId(value) {\r\n      this._setTime('recurrence-id', value);\r\n    },\r\n\r\n    /**\r\n     * Set/update a time property's value.\r\n     * This will also update the TZID of the property.\r\n     *\r\n     * TODO: this method handles the case where we are switching\r\n     * from a known timezone to an implied timezone (one without TZID).\r\n     * This does _not_ handle the case of moving between a known\r\n     *  (by TimezoneService) timezone to an unknown timezone...\r\n     *\r\n     * We will not add/remove/update the VTIMEZONE subcomponents\r\n     *  leading to invalid ICAL data...\r\n     * @private\r\n     * @param {String} propName     The property name\r\n     * @param {ICAL.Time} time      The time to set\r\n     */\r\n    _setTime: function(propName, time) {\r\n      var prop = this.component.getFirstProperty(propName);\r\n\r\n      if (!prop) {\r\n        prop = new ICAL.Property(propName);\r\n        this.component.addProperty(prop);\r\n      }\r\n\r\n      // utc and local don't get a tzid\r\n      if (\r\n        time.zone === ICAL.Timezone.localTimezone ||\r\n        time.zone === ICAL.Timezone.utcTimezone\r\n      ) {\r\n        // remove the tzid\r\n        prop.removeParameter('tzid');\r\n      } else {\r\n        prop.setParameter('tzid', time.zone.tzid);\r\n      }\r\n\r\n      prop.setValue(time);\r\n    },\r\n\r\n    _setProp: function(name, value) {\r\n      this.component.updatePropertyWithValue(name, value);\r\n    },\r\n\r\n    _firstProp: function(name) {\r\n      return this.component.getFirstPropertyValue(name);\r\n    },\r\n\r\n    /**\r\n     * The string representation of this event.\r\n     * @return {String}\r\n     */\r\n    toString: function() {\r\n      return this.component.toString();\r\n    }\r\n\r\n  };\r\n\r\n  function compareRangeException(a, b) {\r\n    if (a[0] > b[0]) return 1;\r\n    if (b[0] > a[0]) return -1;\r\n    return 0;\r\n  }\r\n\r\n  return Event;\r\n}());\r\n/* This Source Code Form is subject to the terms of the Mozilla Public\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n * Portions Copyright (C) Philipp Kewisch, 2011-2015 */\r\n\r\n\r\n/**\r\n * This symbol is further described later on\r\n * @ignore\r\n */\r\nICAL.ComponentParser = (function() {\r\n  /**\r\n   * @classdesc\r\n   * The ComponentParser is used to process a String or jCal Object,\r\n   * firing callbacks for various found components, as well as completion.\r\n   *\r\n   * @example\r\n   * var options = {\r\n   *   // when false no events will be emitted for type\r\n   *   parseEvent: true,\r\n   *   parseTimezone: true\r\n   * };\r\n   *\r\n   * var parser = new ICAL.ComponentParser(options);\r\n   *\r\n   * parser.onevent(eventComponent) {\r\n   *   //...\r\n   * }\r\n   *\r\n   * // ontimezone, etc...\r\n   *\r\n   * parser.oncomplete = function() {\r\n   *\r\n   * };\r\n   *\r\n   * parser.process(stringOrComponent);\r\n   *\r\n   * @class\r\n   * @alias ICAL.ComponentParser\r\n   * @param {Object=} options        Component parser options\r\n   * @param {Boolean} options.parseEvent        Whether events should be parsed\r\n   * @param {Boolean} options.parseTimezeone    Whether timezones should be parsed\r\n   */\r\n  function ComponentParser(options) {\r\n    if (typeof(options) === 'undefined') {\r\n      options = {};\r\n    }\r\n\r\n    var key;\r\n    for (key in options) {\r\n      /* istanbul ignore else */\r\n      if (options.hasOwnProperty(key)) {\r\n        this[key] = options[key];\r\n      }\r\n    }\r\n  }\r\n\r\n  ComponentParser.prototype = {\r\n\r\n    /**\r\n     * When true, parse events\r\n     *\r\n     * @type {Boolean}\r\n     */\r\n    parseEvent: true,\r\n\r\n    /**\r\n     * When true, parse timezones\r\n     *\r\n     * @type {Boolean}\r\n     */\r\n    parseTimezone: true,\r\n\r\n\r\n    /* SAX like events here for reference */\r\n\r\n    /**\r\n     * Fired when parsing is complete\r\n     * @callback\r\n     */\r\n    oncomplete: /* istanbul ignore next */ function() {},\r\n\r\n    /**\r\n     * Fired if an error occurs during parsing.\r\n     *\r\n     * @callback\r\n     * @param {Error} err details of error\r\n     */\r\n    onerror: /* istanbul ignore next */ function(err) {},\r\n\r\n    /**\r\n     * Fired when a top level component (VTIMEZONE) is found\r\n     *\r\n     * @callback\r\n     * @param {ICAL.Timezone} component     Timezone object\r\n     */\r\n    ontimezone: /* istanbul ignore next */ function(component) {},\r\n\r\n    /**\r\n     * Fired when a top level component (VEVENT) is found.\r\n     *\r\n     * @callback\r\n     * @param {ICAL.Event} component    Top level component\r\n     */\r\n    onevent: /* istanbul ignore next */ function(component) {},\r\n\r\n    /**\r\n     * Process a string or parse ical object.  This function itself will return\r\n     * nothing but will start the parsing process.\r\n     *\r\n     * Events must be registered prior to calling this method.\r\n     *\r\n     * @param {ICAL.Component|String|Object} ical      The component to process,\r\n     *        either in its final form, as a jCal Object, or string representation\r\n     */\r\n    process: function(ical) {\r\n      //TODO: this is sync now in the future we will have a incremental parser.\r\n      if (typeof(ical) === 'string') {\r\n        ical = ICAL.parse(ical);\r\n      }\r\n\r\n      if (!(ical instanceof ICAL.Component)) {\r\n        ical = new ICAL.Component(ical);\r\n      }\r\n\r\n      var components = ical.getAllSubcomponents();\r\n      var i = 0;\r\n      var len = components.length;\r\n      var component;\r\n\r\n      for (; i < len; i++) {\r\n        component = components[i];\r\n\r\n        switch (component.name) {\r\n          case 'vtimezone':\r\n            if (this.parseTimezone) {\r\n              var tzid = component.getFirstPropertyValue('tzid');\r\n              if (tzid) {\r\n                this.ontimezone(new ICAL.Timezone({\r\n                  tzid: tzid,\r\n                  component: component\r\n                }));\r\n              }\r\n            }\r\n            break;\r\n          case 'vevent':\r\n            if (this.parseEvent) {\r\n              this.onevent(new ICAL.Event(component));\r\n            }\r\n            break;\r\n          default:\r\n            continue;\r\n        }\r\n      }\r\n\r\n      //XXX: ideally we should do a \"nextTick\" here\r\n      //     so in all cases this is actually async.\r\n      this.oncomplete();\r\n    }\r\n  };\r\n\r\n  return ComponentParser;\r\n}());\r\n"]},"metadata":{},"sourceType":"script"}