{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"C:/Users/bdgcy/Axis/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"C:/Users/bdgcy/Axis/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"C:/Users/bdgcy/Axis/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/bdgcy/Axis/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar StringScanner = require('./StringScanner');\n\nvar syntax = require('./syntax');\n\nvar XmlCdata = require('./XmlCdata');\n\nvar XmlComment = require('./XmlComment');\n\nvar XmlDocument = require('./XmlDocument');\n\nvar XmlElement = require('./XmlElement');\n\nvar XmlProcessingInstruction = require('./XmlProcessingInstruction');\n\nvar XmlText = require('./XmlText');\n\nvar emptyString = '';\n/**\r\nParses an XML string into an `XmlDocument`.\r\n\r\n@private\r\n*/\n\nvar Parser = /*#__PURE__*/function () {\n  /**\r\n  @param {string} xml\r\n    XML string to parse.\r\n    @param {object} [options]\r\n    Parsing options.\r\n      @param {boolean} [options.ignoreUndefinedEntities=false]\r\n    @param {boolean} [options.preserveCdata=false]\r\n    @param {boolean} [options.preserveComments=false]\r\n    @param {(entity: string) => string?} [options.resolveUndefinedEntity]\r\n    @param {boolean} [options.sortAttributes=false]\r\n  */\n  function Parser(xml) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Parser);\n\n    /** @type {XmlDocument} */\n    this.document = new XmlDocument();\n    /** @type {XmlDocument|XmlElement} */\n\n    this.currentNode = this.document;\n    this.options = options;\n    this.scanner = new StringScanner(normalizeXmlString(xml));\n    this.consumeProlog();\n\n    if (!this.consumeElement()) {\n      this.error('Root element is missing or invalid');\n    }\n\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n\n    if (!this.scanner.isEnd) {\n      this.error('Extra content at the end of the document');\n    }\n  }\n  /**\r\n  Adds the given `XmlNode` as a child of `this.currentNode`.\r\n    @param {XmlNode} node\r\n  */\n\n\n  _createClass(Parser, [{\n    key: \"addNode\",\n    value: function addNode(node) {\n      node.parent = this.currentNode; // @ts-ignore\n\n      this.currentNode.children.push(node);\n    }\n    /**\r\n    Adds the given _text_ to the document, either by appending it to a preceding\r\n    `XmlText` node (if possible) or by creating a new `XmlText` node.\r\n      @param {string} text\r\n    */\n\n  }, {\n    key: \"addText\",\n    value: function addText(text) {\n      var children = this.currentNode.children;\n\n      if (children.length > 0) {\n        var prevNode = children[children.length - 1];\n\n        if (prevNode instanceof XmlText) {\n          // The previous node is a text node, so we can append to it and avoid\n          // creating another node.\n          prevNode.text += text;\n          return;\n        }\n      }\n\n      this.addNode(new XmlText(text));\n    }\n    /**\r\n    Consumes an `AttValue` (attribute value) if possible.\r\n      @returns {string|false}\r\n      Contents of the `AttValue` minus quotes, or `false` if nothing was consumed.\r\n      An empty string indicates that an `AttValue` was consumed but was empty.\r\n      @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue\r\n    */\n\n  }, {\n    key: \"consumeAttributeValue\",\n    value: function consumeAttributeValue() {\n      var scanner = this.scanner;\n      var quote = scanner.peek();\n\n      if (quote !== '\"' && quote !== \"'\") {\n        return false;\n      }\n\n      scanner.advance();\n      var chars;\n      var isClosed = false;\n      var value = emptyString;\n      var regex = quote === '\"' ? new RegExp(\"[^\\\"&<]+\", \"y\") : new RegExp(\"[^'&<]+\", \"y\");\n\n      matchLoop: while (!scanner.isEnd) {\n        chars = scanner.consumeMatch(regex);\n\n        if (chars) {\n          this.validateChars(chars);\n          value += chars.replace(/[\\t\\r\\n]/g, ' ');\n        }\n\n        var nextChar = scanner.peek();\n\n        switch (nextChar) {\n          case quote:\n            isClosed = true;\n            break matchLoop;\n\n          case '&':\n            value += this.consumeReference();\n            continue;\n\n          case '<':\n            this.error('Unescaped `<` is not allowed in an attribute value');\n            /* istanbul ignore next */\n\n            break;\n\n          case emptyString:\n            this.error('Unclosed attribute');\n            /* istanbul ignore next */\n\n            break;\n        }\n      }\n\n      if (!isClosed) {\n        this.error('Unclosed attribute');\n      }\n\n      scanner.advance();\n      return value;\n    }\n    /**\r\n    Consumes a CDATA section if possible.\r\n      @returns {boolean}\r\n      Whether a CDATA section was consumed.\r\n      @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-cdata-sect\r\n    */\n\n  }, {\n    key: \"consumeCdataSection\",\n    value: function consumeCdataSection() {\n      var scanner = this.scanner;\n\n      if (!scanner.consumeStringFast('<![CDATA[')) {\n        return false;\n      }\n\n      var text = scanner.consumeUntilString(']]>');\n      this.validateChars(text);\n\n      if (!scanner.consumeStringFast(']]>')) {\n        this.error('Unclosed CDATA section');\n      }\n\n      if (this.options.preserveCdata) {\n        this.addNode(new XmlCdata(text));\n      } else {\n        this.addText(text);\n      }\n\n      return true;\n    }\n    /**\r\n    Consumes character data if possible.\r\n      @returns {boolean}\r\n      Whether character data was consumed.\r\n      @see https://www.w3.org/TR/2008/REC-xml-20081126/#dt-chardata\r\n    */\n\n  }, {\n    key: \"consumeCharData\",\n    value: function consumeCharData() {\n      var scanner = this.scanner;\n      var charData = scanner.consumeUntilMatch(/<|&|]]>/g);\n\n      if (!charData) {\n        return false;\n      }\n\n      this.validateChars(charData);\n\n      if (scanner.peek() === ']' && scanner.peek(3) === ']]>') {\n        this.error('Element content may not contain the CDATA section close delimiter `]]>`');\n      }\n\n      this.addText(charData);\n      return true;\n    }\n    /**\r\n    Consumes a comment if possible.\r\n      @returns {boolean}\r\n      Whether a comment was consumed.\r\n      @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Comment\r\n    */\n\n  }, {\n    key: \"consumeComment\",\n    value: function consumeComment() {\n      var scanner = this.scanner;\n\n      if (!scanner.consumeStringFast('<!--')) {\n        return false;\n      }\n\n      var content = scanner.consumeUntilString('--');\n      this.validateChars(content);\n\n      if (!scanner.consumeStringFast('-->')) {\n        if (scanner.peek(2) === '--') {\n          this.error(\"The string `--` isn't allowed inside a comment\");\n        } else {\n          this.error('Unclosed comment');\n        }\n      }\n\n      if (this.options.preserveComments) {\n        this.addNode(new XmlComment(content.trim()));\n      }\n\n      return true;\n    }\n    /**\r\n    Consumes a reference in a content context if possible.\r\n      This differs from `consumeReference()` in that a consumed reference will be\r\n    added to the document as a text node instead of returned.\r\n      @returns {boolean}\r\n      Whether a reference was consumed.\r\n      @see https://www.w3.org/TR/2008/REC-xml-20081126/#entproc\r\n    */\n\n  }, {\n    key: \"consumeContentReference\",\n    value: function consumeContentReference() {\n      var ref = this.consumeReference();\n\n      if (ref) {\n        this.addText(ref);\n        return true;\n      }\n\n      return false;\n    }\n    /**\r\n    Consumes a doctype declaration if possible.\r\n      This is a loose implementation since doctype declarations are currently\r\n    discarded without further parsing.\r\n      @returns {boolean}\r\n      Whether a doctype declaration was consumed.\r\n      @see https://www.w3.org/TR/2008/REC-xml-20081126/#dtd\r\n    */\n\n  }, {\n    key: \"consumeDoctypeDeclaration\",\n    value: function consumeDoctypeDeclaration() {\n      var scanner = this.scanner;\n\n      if (!scanner.consumeStringFast('<!DOCTYPE') || !this.consumeWhitespace()) {\n        return false;\n      }\n\n      scanner.consumeMatch(new RegExp(\"[^[>]+\", \"y\"));\n\n      if (scanner.consumeMatch(new RegExp(\"\\\\[[\\\\s\\\\S]+?\\\\][\\\\x20\\\\t\\\\r\\\\n]*>\", \"y\"))) {\n        return true;\n      }\n\n      if (!scanner.consumeStringFast('>')) {\n        this.error('Unclosed doctype declaration');\n      }\n\n      return true;\n    }\n    /**\r\n    Consumes an element if possible.\r\n      @returns {boolean}\r\n      Whether an element was consumed.\r\n      @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-element\r\n    */\n\n  }, {\n    key: \"consumeElement\",\n    value: function consumeElement() {\n      var scanner = this.scanner;\n      var mark = scanner.charIndex;\n\n      if (scanner.peek() !== '<') {\n        return false;\n      }\n\n      scanner.advance();\n      var name = this.consumeName();\n\n      if (!name) {\n        scanner.reset(mark);\n        return false;\n      }\n\n      var attributes = Object.create(null);\n\n      while (this.consumeWhitespace()) {\n        var attrName = this.consumeName();\n\n        if (!attrName) {\n          continue;\n        }\n\n        var attrValue = this.consumeEqual() && this.consumeAttributeValue();\n\n        if (attrValue === false) {\n          this.error('Attribute value expected');\n        }\n\n        if (attrName in attributes) {\n          this.error(\"Duplicate attribute: \".concat(attrName));\n        }\n\n        if (attrName === 'xml:space' && attrValue !== 'default' && attrValue !== 'preserve') {\n          this.error('Value of the `xml:space` attribute must be \"default\" or \"preserve\"');\n        }\n\n        attributes[attrName] = attrValue;\n      }\n\n      if (this.options.sortAttributes) {\n        var attrNames = Object.keys(attributes).sort();\n        var sortedAttributes = Object.create(null);\n\n        for (var i = 0; i < attrNames.length; ++i) {\n          var _attrName = attrNames[i];\n          sortedAttributes[_attrName] = attributes[_attrName];\n        }\n\n        attributes = sortedAttributes;\n      }\n\n      var isEmpty = Boolean(scanner.consumeStringFast('/>'));\n      var element = new XmlElement(name, attributes);\n      element.parent = this.currentNode;\n\n      if (!isEmpty) {\n        if (!scanner.consumeStringFast('>')) {\n          this.error(\"Unclosed start tag for element `\".concat(name, \"`\"));\n        }\n\n        this.currentNode = element;\n        this.consumeCharData();\n\n        while (this.consumeElement() || this.consumeContentReference() || this.consumeCdataSection() || this.consumeProcessingInstruction() || this.consumeComment()) {\n          this.consumeCharData();\n        }\n\n        var endTagMark = scanner.charIndex;\n        var endTagName;\n\n        if (!scanner.consumeStringFast('</') || !(endTagName = this.consumeName()) || endTagName !== name) {\n          scanner.reset(endTagMark);\n          this.error(\"Missing end tag for element \".concat(name));\n        }\n\n        this.consumeWhitespace();\n\n        if (!scanner.consumeStringFast('>')) {\n          this.error(\"Unclosed end tag for element \".concat(name));\n        }\n\n        this.currentNode = element.parent;\n      }\n\n      this.addNode(element);\n      return true;\n    }\n    /**\r\n    Consumes an `Eq` production if possible.\r\n      @returns {boolean}\r\n      Whether an `Eq` production was consumed.\r\n      @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Eq\r\n    */\n\n  }, {\n    key: \"consumeEqual\",\n    value: function consumeEqual() {\n      this.consumeWhitespace();\n\n      if (this.scanner.consumeStringFast('=')) {\n        this.consumeWhitespace();\n        return true;\n      }\n\n      return false;\n    }\n    /**\r\n    Consumes `Misc` content if possible.\r\n      @returns {boolean}\r\n      Whether anything was consumed.\r\n      @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Misc\r\n    */\n\n  }, {\n    key: \"consumeMisc\",\n    value: function consumeMisc() {\n      return this.consumeComment() || this.consumeProcessingInstruction() || this.consumeWhitespace();\n    }\n    /**\r\n    Consumes one or more `Name` characters if possible.\r\n      @returns {string}\r\n      `Name` characters, or an empty string if none were consumed.\r\n      @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Name\r\n    */\n\n  }, {\n    key: \"consumeName\",\n    value: function consumeName() {\n      return syntax.isNameStartChar(this.scanner.peek()) ? this.scanner.consumeMatchFn(syntax.isNameChar) : emptyString;\n    }\n    /**\r\n    Consumes a processing instruction if possible.\r\n      @returns {boolean}\r\n      Whether a processing instruction was consumed.\r\n      @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-pi\r\n    */\n\n  }, {\n    key: \"consumeProcessingInstruction\",\n    value: function consumeProcessingInstruction() {\n      var scanner = this.scanner;\n      var mark = scanner.charIndex;\n\n      if (!scanner.consumeStringFast('<?')) {\n        return false;\n      }\n\n      var name = this.consumeName();\n\n      if (name) {\n        if (name.toLowerCase() === 'xml') {\n          scanner.reset(mark);\n          this.error(\"XML declaration isn't allowed here\");\n        }\n      } else {\n        this.error('Invalid processing instruction');\n      }\n\n      if (!this.consumeWhitespace()) {\n        if (scanner.consumeStringFast('?>')) {\n          this.addNode(new XmlProcessingInstruction(name));\n          return true;\n        }\n\n        this.error('Whitespace is required after a processing instruction name');\n      }\n\n      var content = scanner.consumeUntilString('?>');\n      this.validateChars(content);\n\n      if (!scanner.consumeStringFast('?>')) {\n        this.error('Unterminated processing instruction');\n      }\n\n      this.addNode(new XmlProcessingInstruction(name, content));\n      return true;\n    }\n    /**\r\n    Consumes a prolog if possible.\r\n      @returns {boolean}\r\n      Whether a prolog was consumed.\r\n      @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-prolog-dtd\r\n    */\n\n  }, {\n    key: \"consumeProlog\",\n    value: function consumeProlog() {\n      var scanner = this.scanner;\n      var mark = scanner.charIndex;\n      this.consumeXmlDeclaration();\n\n      while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n\n      if (this.consumeDoctypeDeclaration()) {\n        while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n      }\n\n      return mark < scanner.charIndex;\n    }\n    /**\r\n    Consumes a reference if possible.\r\n      This differs from `consumeContentReference()` in that a consumed reference\r\n    will be returned rather than added to the document.\r\n      @returns {string|false}\r\n      Parsed reference value, or `false` if nothing was consumed (to distinguish\r\n      from a reference that resolves to an empty string).\r\n      @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Reference\r\n    */\n\n  }, {\n    key: \"consumeReference\",\n    value: function consumeReference() {\n      var scanner = this.scanner;\n\n      if (scanner.peek() !== '&') {\n        return false;\n      }\n\n      scanner.advance();\n      var ref = scanner.consumeMatchFn(syntax.isReferenceChar);\n\n      if (scanner.consume() !== ';') {\n        this.error('Unterminated reference (a reference must end with `;`)');\n      }\n\n      var parsedValue;\n\n      if (ref[0] === '#') {\n        // This is a character reference.\n        var codePoint = ref[1] === 'x' ? parseInt(ref.slice(2), 16) // Hex codepoint.\n        : parseInt(ref.slice(1), 10); // Decimal codepoint.\n\n        if (isNaN(codePoint)) {\n          this.error('Invalid character reference');\n        }\n\n        parsedValue = String.fromCodePoint(codePoint);\n\n        if (!syntax.isXmlChar(parsedValue)) {\n          this.error('Character reference resolves to an invalid character');\n        }\n      } else {\n        // This is an entity reference.\n        parsedValue = syntax.predefinedEntities[ref];\n\n        if (parsedValue === undefined) {\n          var _this$options = this.options,\n              ignoreUndefinedEntities = _this$options.ignoreUndefinedEntities,\n              resolveUndefinedEntity = _this$options.resolveUndefinedEntity;\n          var wrappedRef = \"&\".concat(ref, \";\"); // for backcompat with <= 2.x\n\n          if (resolveUndefinedEntity) {\n            var resolvedValue = resolveUndefinedEntity(wrappedRef);\n\n            if (resolvedValue !== null && resolvedValue !== undefined) {\n              var type = typeof resolvedValue;\n\n              if (type !== 'string') {\n                throw new TypeError(\"`resolveUndefinedEntity()` must return a string, `null`, or `undefined`, but returned a value of type \".concat(type));\n              }\n\n              return resolvedValue;\n            }\n          }\n\n          if (ignoreUndefinedEntities) {\n            return wrappedRef;\n          }\n\n          scanner.reset(-wrappedRef.length);\n          this.error(\"Named entity isn't defined: \".concat(wrappedRef));\n        }\n      }\n\n      return parsedValue;\n    }\n    /**\r\n    Consumes a `SystemLiteral` if possible.\r\n      A `SystemLiteral` is similar to an attribute value, but allows the characters\r\n    `<` and `&` and doesn't replace references.\r\n      @returns {string|false}\r\n      Value of the `SystemLiteral` minus quotes, or `false` if nothing was\r\n      consumed. An empty string indicates that a `SystemLiteral` was consumed but\r\n      was empty.\r\n      @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-SystemLiteral\r\n    */\n\n  }, {\n    key: \"consumeSystemLiteral\",\n    value: function consumeSystemLiteral() {\n      var scanner = this.scanner;\n      var quote = scanner.consumeStringFast('\"') || scanner.consumeStringFast(\"'\");\n\n      if (!quote) {\n        return false;\n      }\n\n      var value = scanner.consumeUntilString(quote);\n      this.validateChars(value);\n\n      if (!scanner.consumeStringFast(quote)) {\n        this.error('Missing end quote');\n      }\n\n      return value;\n    }\n    /**\r\n    Consumes one or more whitespace characters if possible.\r\n      @returns {boolean}\r\n      Whether any whitespace characters were consumed.\r\n      @see https://www.w3.org/TR/2008/REC-xml-20081126/#white\r\n    */\n\n  }, {\n    key: \"consumeWhitespace\",\n    value: function consumeWhitespace() {\n      return Boolean(this.scanner.consumeMatchFn(syntax.isWhitespace));\n    }\n    /**\r\n    Consumes an XML declaration if possible.\r\n      @returns {boolean}\r\n      Whether an XML declaration was consumed.\r\n      @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-XMLDecl\r\n    */\n\n  }, {\n    key: \"consumeXmlDeclaration\",\n    value: function consumeXmlDeclaration() {\n      var scanner = this.scanner;\n\n      if (!scanner.consumeStringFast('<?xml')) {\n        return false;\n      }\n\n      if (!this.consumeWhitespace()) {\n        this.error('Invalid XML declaration');\n      }\n\n      var version = Boolean(scanner.consumeStringFast('version')) && this.consumeEqual() && this.consumeSystemLiteral();\n\n      if (version === false) {\n        this.error('XML version is missing or invalid');\n      } else if (!/^1\\.[0-9]+$/.test(version)) {\n        this.error('Invalid character in version number');\n      }\n\n      if (this.consumeWhitespace()) {\n        var encoding = Boolean(scanner.consumeStringFast('encoding')) && this.consumeEqual() && this.consumeSystemLiteral();\n\n        if (encoding) {\n          this.consumeWhitespace();\n        }\n\n        var standalone = Boolean(scanner.consumeStringFast('standalone')) && this.consumeEqual() && this.consumeSystemLiteral();\n\n        if (standalone) {\n          if (standalone !== 'yes' && standalone !== 'no') {\n            this.error('Only \"yes\" and \"no\" are permitted as values of `standalone`');\n          }\n\n          this.consumeWhitespace();\n        }\n      }\n\n      if (!scanner.consumeStringFast('?>')) {\n        this.error('Invalid or unclosed XML declaration');\n      }\n\n      return true;\n    }\n    /**\r\n    Throws an error at the current scanner position.\r\n      @param {string} message\r\n    */\n\n  }, {\n    key: \"error\",\n    value: function error(message) {\n      var _this$scanner = this.scanner,\n          charIndex = _this$scanner.charIndex,\n          xml = _this$scanner.string;\n      var column = 1;\n      var excerpt = '';\n      var line = 1; // Find the line and column where the error occurred.\n\n      for (var i = 0; i < charIndex; ++i) {\n        var char = xml[i];\n\n        if (char === '\\n') {\n          column = 1;\n          excerpt = '';\n          line += 1;\n        } else {\n          column += 1;\n          excerpt += char;\n        }\n      }\n\n      var eol = xml.indexOf('\\n', charIndex);\n      excerpt += eol === -1 ? xml.slice(charIndex) : xml.slice(charIndex, eol);\n      var excerptStart = 0; // Keep the excerpt below 50 chars, but always keep the error position in\n      // view.\n\n      if (excerpt.length > 50) {\n        if (column < 40) {\n          excerpt = excerpt.slice(0, 50);\n        } else {\n          excerptStart = column - 20;\n          excerpt = excerpt.slice(excerptStart, column + 30);\n        }\n      }\n\n      var err = new Error(\"\".concat(message, \" (line \").concat(line, \", column \").concat(column, \")\\n\") + \"  \".concat(excerpt, \"\\n\") + ' '.repeat(column - excerptStart + 1) + '^\\n');\n      Object.assign(err, {\n        column: column,\n        excerpt: excerpt,\n        line: line,\n        pos: charIndex\n      });\n      throw err;\n    }\n    /**\r\n    Throws an invalid character error if any character in the given _string_ isn't\r\n    a valid XML character.\r\n      @param {string} string\r\n    */\n\n  }, {\n    key: \"validateChars\",\n    value: function validateChars(string) {\n      var charIndex = 0;\n\n      var _iterator = _createForOfIteratorHelper(string),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var char = _step.value;\n\n          if (syntax.isNotXmlChar(char)) {\n            this.scanner.reset(-(_toConsumableArray(string).length - charIndex));\n            this.error('Invalid character');\n          }\n\n          charIndex += 1;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }]);\n\n  return Parser;\n}();\n\nmodule.exports = Parser; // -- Private Functions --------------------------------------------------------\n\n/**\r\nNormalizes the given XML string by stripping a byte order mark (if present) and\r\nreplacing CRLF sequences and lone CR characters with LF characters.\r\n\r\n@param {string} xml\r\n@returns {string}\r\n*/\n\nfunction normalizeXmlString(xml) {\n  if (xml[0] === \"\\uFEFF\") {\n    xml = xml.slice(1);\n  }\n\n  return xml.replace(/\\r\\n?/g, '\\n');\n}\n/** @typedef {import('./XmlNode')} XmlNode */","map":{"version":3,"sources":["C:/Users/bdgcy/Axis/client/node_modules/@rgrove/parse-xml/src/lib/Parser.js"],"names":["StringScanner","require","syntax","XmlCdata","XmlComment","XmlDocument","XmlElement","XmlProcessingInstruction","XmlText","emptyString","Parser","xml","options","document","currentNode","scanner","normalizeXmlString","consumeProlog","consumeElement","error","consumeMisc","isEnd","node","parent","children","push","text","length","prevNode","addNode","quote","peek","advance","chars","isClosed","value","regex","matchLoop","consumeMatch","validateChars","replace","nextChar","consumeReference","consumeStringFast","consumeUntilString","preserveCdata","addText","charData","consumeUntilMatch","content","preserveComments","trim","ref","consumeWhitespace","mark","charIndex","name","consumeName","reset","attributes","Object","create","attrName","attrValue","consumeEqual","consumeAttributeValue","sortAttributes","attrNames","keys","sort","sortedAttributes","i","isEmpty","Boolean","element","consumeCharData","consumeContentReference","consumeCdataSection","consumeProcessingInstruction","consumeComment","endTagMark","endTagName","isNameStartChar","consumeMatchFn","isNameChar","toLowerCase","consumeXmlDeclaration","consumeDoctypeDeclaration","isReferenceChar","consume","parsedValue","codePoint","parseInt","slice","isNaN","String","fromCodePoint","isXmlChar","predefinedEntities","undefined","ignoreUndefinedEntities","resolveUndefinedEntity","wrappedRef","resolvedValue","type","TypeError","isWhitespace","version","consumeSystemLiteral","test","encoding","standalone","message","string","column","excerpt","line","char","eol","indexOf","excerptStart","err","Error","repeat","assign","pos","isNotXmlChar","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst StringScanner = require('./StringScanner');\r\nconst syntax = require('./syntax');\r\nconst XmlCdata = require('./XmlCdata');\r\nconst XmlComment = require('./XmlComment');\r\nconst XmlDocument = require('./XmlDocument');\r\nconst XmlElement = require('./XmlElement');\r\nconst XmlProcessingInstruction = require('./XmlProcessingInstruction');\r\nconst XmlText = require('./XmlText');\r\n\r\nconst emptyString = '';\r\n\r\n/**\r\nParses an XML string into an `XmlDocument`.\r\n\r\n@private\r\n*/\r\nclass Parser {\r\n  /**\r\n  @param {string} xml\r\n    XML string to parse.\r\n\r\n  @param {object} [options]\r\n    Parsing options.\r\n\r\n    @param {boolean} [options.ignoreUndefinedEntities=false]\r\n    @param {boolean} [options.preserveCdata=false]\r\n    @param {boolean} [options.preserveComments=false]\r\n    @param {(entity: string) => string?} [options.resolveUndefinedEntity]\r\n    @param {boolean} [options.sortAttributes=false]\r\n  */\r\n  constructor(xml, options = {}) {\r\n    /** @type {XmlDocument} */\r\n    this.document = new XmlDocument();\r\n\r\n    /** @type {XmlDocument|XmlElement} */\r\n    this.currentNode = this.document;\r\n\r\n    this.options = options;\r\n    this.scanner = new StringScanner(normalizeXmlString(xml));\r\n\r\n    this.consumeProlog();\r\n\r\n    if (!this.consumeElement()) {\r\n      this.error('Root element is missing or invalid');\r\n    }\r\n\r\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\r\n\r\n    if (!this.scanner.isEnd) {\r\n      this.error('Extra content at the end of the document');\r\n    }\r\n  }\r\n\r\n  /**\r\n  Adds the given `XmlNode` as a child of `this.currentNode`.\r\n\r\n  @param {XmlNode} node\r\n  */\r\n  addNode(node) {\r\n    node.parent = this.currentNode;\r\n\r\n    // @ts-ignore\r\n    this.currentNode.children.push(node);\r\n  }\r\n\r\n  /**\r\n  Adds the given _text_ to the document, either by appending it to a preceding\r\n  `XmlText` node (if possible) or by creating a new `XmlText` node.\r\n\r\n  @param {string} text\r\n  */\r\n  addText(text) {\r\n    let { children } = this.currentNode;\r\n\r\n    if (children.length > 0) {\r\n      let prevNode = children[children.length - 1];\r\n\r\n      if (prevNode instanceof XmlText) {\r\n        // The previous node is a text node, so we can append to it and avoid\r\n        // creating another node.\r\n        prevNode.text += text;\r\n        return;\r\n      }\r\n    }\r\n\r\n    this.addNode(new XmlText(text));\r\n  }\r\n\r\n  /**\r\n  Consumes an `AttValue` (attribute value) if possible.\r\n\r\n  @returns {string|false}\r\n    Contents of the `AttValue` minus quotes, or `false` if nothing was consumed.\r\n    An empty string indicates that an `AttValue` was consumed but was empty.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue\r\n  */\r\n  consumeAttributeValue() {\r\n    let { scanner } = this;\r\n    let quote = scanner.peek();\r\n\r\n    if (quote !== '\"' && quote !== \"'\") {\r\n      return false;\r\n    }\r\n\r\n    scanner.advance();\r\n\r\n    let chars;\r\n    let isClosed = false;\r\n    let value = emptyString;\r\n    let regex = quote === '\"'\r\n      ? /[^\"&<]+/y\r\n      : /[^'&<]+/y;\r\n\r\n    matchLoop: while (!scanner.isEnd) {\r\n      chars = scanner.consumeMatch(regex);\r\n\r\n      if (chars) {\r\n        this.validateChars(chars);\r\n        value += chars.replace(/[\\t\\r\\n]/g, ' ');\r\n      }\r\n\r\n      let nextChar = scanner.peek();\r\n\r\n      switch (nextChar) {\r\n        case quote:\r\n          isClosed = true;\r\n          break matchLoop;\r\n\r\n        case '&':\r\n          value += this.consumeReference();\r\n          continue;\r\n\r\n        case '<':\r\n          this.error('Unescaped `<` is not allowed in an attribute value'); /* istanbul ignore next */\r\n          break;\r\n\r\n        case emptyString:\r\n          this.error('Unclosed attribute'); /* istanbul ignore next */\r\n          break;\r\n\r\n      }\r\n    }\r\n\r\n    if (!isClosed) {\r\n      this.error('Unclosed attribute');\r\n    }\r\n\r\n    scanner.advance();\r\n    return value;\r\n  }\r\n\r\n  /**\r\n  Consumes a CDATA section if possible.\r\n\r\n  @returns {boolean}\r\n    Whether a CDATA section was consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-cdata-sect\r\n  */\r\n  consumeCdataSection() {\r\n    let { scanner } = this;\r\n\r\n    if (!scanner.consumeStringFast('<![CDATA[')) {\r\n      return false;\r\n    }\r\n\r\n    let text = scanner.consumeUntilString(']]>');\r\n    this.validateChars(text);\r\n\r\n    if (!scanner.consumeStringFast(']]>')) {\r\n      this.error('Unclosed CDATA section');\r\n    }\r\n\r\n    if (this.options.preserveCdata) {\r\n      this.addNode(new XmlCdata(text));\r\n    } else {\r\n      this.addText(text);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  Consumes character data if possible.\r\n\r\n  @returns {boolean}\r\n    Whether character data was consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#dt-chardata\r\n  */\r\n  consumeCharData() {\r\n    let { scanner } = this;\r\n    let charData = scanner.consumeUntilMatch(/<|&|]]>/g);\r\n\r\n    if (!charData) {\r\n      return false;\r\n    }\r\n\r\n    this.validateChars(charData);\r\n\r\n    if (scanner.peek() === ']' && scanner.peek(3) === ']]>') {\r\n      this.error('Element content may not contain the CDATA section close delimiter `]]>`');\r\n    }\r\n\r\n    this.addText(charData);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  Consumes a comment if possible.\r\n\r\n  @returns {boolean}\r\n    Whether a comment was consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Comment\r\n  */\r\n  consumeComment() {\r\n    let { scanner } = this;\r\n\r\n    if (!scanner.consumeStringFast('<!--')) {\r\n      return false;\r\n    }\r\n\r\n    let content = scanner.consumeUntilString('--');\r\n    this.validateChars(content);\r\n\r\n    if (!scanner.consumeStringFast('-->')) {\r\n      if (scanner.peek(2) === '--') {\r\n        this.error(\"The string `--` isn't allowed inside a comment\");\r\n      } else {\r\n        this.error('Unclosed comment');\r\n      }\r\n    }\r\n\r\n    if (this.options.preserveComments) {\r\n      this.addNode(new XmlComment(content.trim()));\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  Consumes a reference in a content context if possible.\r\n\r\n  This differs from `consumeReference()` in that a consumed reference will be\r\n  added to the document as a text node instead of returned.\r\n\r\n  @returns {boolean}\r\n    Whether a reference was consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#entproc\r\n  */\r\n  consumeContentReference() {\r\n    let ref = this.consumeReference();\r\n\r\n    if (ref) {\r\n      this.addText(ref);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n  Consumes a doctype declaration if possible.\r\n\r\n  This is a loose implementation since doctype declarations are currently\r\n  discarded without further parsing.\r\n\r\n  @returns {boolean}\r\n    Whether a doctype declaration was consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#dtd\r\n  */\r\n  consumeDoctypeDeclaration() {\r\n    let { scanner } = this;\r\n\r\n    if (!scanner.consumeStringFast('<!DOCTYPE')\r\n        || !this.consumeWhitespace()) {\r\n\r\n      return false;\r\n    }\r\n\r\n    scanner.consumeMatch(/[^[>]+/y);\r\n\r\n    if (scanner.consumeMatch(/\\[[\\s\\S]+?\\][\\x20\\t\\r\\n]*>/y)) {\r\n      return true;\r\n    }\r\n\r\n    if (!scanner.consumeStringFast('>')) {\r\n      this.error('Unclosed doctype declaration');\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  Consumes an element if possible.\r\n\r\n  @returns {boolean}\r\n    Whether an element was consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-element\r\n  */\r\n  consumeElement() {\r\n    let { scanner } = this;\r\n    let mark = scanner.charIndex;\r\n\r\n    if (scanner.peek() !== '<') {\r\n      return false;\r\n    }\r\n\r\n    scanner.advance();\r\n    let name = this.consumeName();\r\n\r\n    if (!name) {\r\n      scanner.reset(mark);\r\n      return false;\r\n    }\r\n\r\n    let attributes = Object.create(null);\r\n\r\n    while (this.consumeWhitespace()) {\r\n      let attrName = this.consumeName();\r\n\r\n      if (!attrName) {\r\n        continue;\r\n      }\r\n\r\n      let attrValue = this.consumeEqual()\r\n        && this.consumeAttributeValue();\r\n\r\n      if (attrValue === false) {\r\n        this.error('Attribute value expected');\r\n      }\r\n\r\n      if (attrName in attributes) {\r\n        this.error(`Duplicate attribute: ${attrName}`);\r\n      }\r\n\r\n      if (attrName === 'xml:space'\r\n          && attrValue !== 'default'\r\n          && attrValue !== 'preserve') {\r\n\r\n        this.error('Value of the `xml:space` attribute must be \"default\" or \"preserve\"');\r\n      }\r\n\r\n      attributes[attrName] = attrValue;\r\n    }\r\n\r\n    if (this.options.sortAttributes) {\r\n      let attrNames = Object.keys(attributes).sort();\r\n      let sortedAttributes = Object.create(null);\r\n\r\n      for (let i = 0; i < attrNames.length; ++i) {\r\n        let attrName = attrNames[i];\r\n        sortedAttributes[attrName] = attributes[attrName];\r\n      }\r\n\r\n      attributes = sortedAttributes;\r\n    }\r\n\r\n    let isEmpty = Boolean(scanner.consumeStringFast('/>'));\r\n    let element = new XmlElement(name, attributes);\r\n\r\n    element.parent = this.currentNode;\r\n\r\n    if (!isEmpty) {\r\n      if (!scanner.consumeStringFast('>')) {\r\n        this.error(`Unclosed start tag for element \\`${name}\\``);\r\n      }\r\n\r\n      this.currentNode = element;\r\n      this.consumeCharData();\r\n\r\n      while (\r\n        this.consumeElement()\r\n          || this.consumeContentReference()\r\n          || this.consumeCdataSection()\r\n          || this.consumeProcessingInstruction()\r\n          || this.consumeComment()\r\n      ) {\r\n        this.consumeCharData();\r\n      }\r\n\r\n      let endTagMark = scanner.charIndex;\r\n      let endTagName;\r\n\r\n      if (!scanner.consumeStringFast('</')\r\n          || !(endTagName = this.consumeName())\r\n          || endTagName !== name) {\r\n\r\n        scanner.reset(endTagMark);\r\n        this.error(`Missing end tag for element ${name}`);\r\n      }\r\n\r\n      this.consumeWhitespace();\r\n\r\n      if (!scanner.consumeStringFast('>')) {\r\n        this.error(`Unclosed end tag for element ${name}`);\r\n      }\r\n\r\n      this.currentNode = element.parent;\r\n    }\r\n\r\n    this.addNode(element);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  Consumes an `Eq` production if possible.\r\n\r\n  @returns {boolean}\r\n    Whether an `Eq` production was consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Eq\r\n  */\r\n  consumeEqual() {\r\n    this.consumeWhitespace();\r\n\r\n    if (this.scanner.consumeStringFast('=')) {\r\n      this.consumeWhitespace();\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n  Consumes `Misc` content if possible.\r\n\r\n  @returns {boolean}\r\n    Whether anything was consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Misc\r\n  */\r\n  consumeMisc() {\r\n    return this.consumeComment()\r\n      || this.consumeProcessingInstruction()\r\n      || this.consumeWhitespace();\r\n  }\r\n\r\n  /**\r\n  Consumes one or more `Name` characters if possible.\r\n\r\n  @returns {string}\r\n    `Name` characters, or an empty string if none were consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Name\r\n  */\r\n  consumeName() {\r\n    return syntax.isNameStartChar(this.scanner.peek())\r\n      ? this.scanner.consumeMatchFn(syntax.isNameChar)\r\n      : emptyString;\r\n  }\r\n\r\n  /**\r\n  Consumes a processing instruction if possible.\r\n\r\n  @returns {boolean}\r\n    Whether a processing instruction was consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-pi\r\n  */\r\n  consumeProcessingInstruction() {\r\n    let { scanner } = this;\r\n    let mark = scanner.charIndex;\r\n\r\n    if (!scanner.consumeStringFast('<?')) {\r\n      return false;\r\n    }\r\n\r\n    let name = this.consumeName();\r\n\r\n    if (name) {\r\n      if (name.toLowerCase() === 'xml') {\r\n        scanner.reset(mark);\r\n        this.error(\"XML declaration isn't allowed here\");\r\n      }\r\n    } else {\r\n      this.error('Invalid processing instruction');\r\n    }\r\n\r\n    if (!this.consumeWhitespace()) {\r\n      if (scanner.consumeStringFast('?>')) {\r\n        this.addNode(new XmlProcessingInstruction(name));\r\n        return true;\r\n      }\r\n\r\n      this.error('Whitespace is required after a processing instruction name');\r\n    }\r\n\r\n    let content = scanner.consumeUntilString('?>');\r\n    this.validateChars(content);\r\n\r\n    if (!scanner.consumeStringFast('?>')) {\r\n      this.error('Unterminated processing instruction');\r\n    }\r\n\r\n    this.addNode(new XmlProcessingInstruction(name, content));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  Consumes a prolog if possible.\r\n\r\n  @returns {boolean}\r\n    Whether a prolog was consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-prolog-dtd\r\n  */\r\n  consumeProlog() {\r\n    let { scanner } = this;\r\n    let mark = scanner.charIndex;\r\n\r\n    this.consumeXmlDeclaration();\r\n\r\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\r\n\r\n    if (this.consumeDoctypeDeclaration()) {\r\n      while (this.consumeMisc()) {} // eslint-disable-line no-empty\r\n    }\r\n\r\n    return mark < scanner.charIndex;\r\n  }\r\n\r\n  /**\r\n  Consumes a reference if possible.\r\n\r\n  This differs from `consumeContentReference()` in that a consumed reference\r\n  will be returned rather than added to the document.\r\n\r\n  @returns {string|false}\r\n    Parsed reference value, or `false` if nothing was consumed (to distinguish\r\n    from a reference that resolves to an empty string).\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Reference\r\n  */\r\n  consumeReference() {\r\n    let { scanner } = this;\r\n\r\n    if (scanner.peek() !== '&') {\r\n      return false;\r\n    }\r\n\r\n    scanner.advance();\r\n\r\n    let ref = scanner.consumeMatchFn(syntax.isReferenceChar);\r\n\r\n    if (scanner.consume() !== ';') {\r\n      this.error('Unterminated reference (a reference must end with `;`)');\r\n    }\r\n\r\n    let parsedValue;\r\n\r\n    if (ref[0] === '#') {\r\n      // This is a character reference.\r\n      let codePoint = ref[1] === 'x'\r\n        ? parseInt(ref.slice(2), 16) // Hex codepoint.\r\n        : parseInt(ref.slice(1), 10); // Decimal codepoint.\r\n\r\n      if (isNaN(codePoint)) {\r\n        this.error('Invalid character reference');\r\n      }\r\n\r\n      parsedValue = String.fromCodePoint(codePoint);\r\n\r\n      if (!syntax.isXmlChar(parsedValue)) {\r\n        this.error('Character reference resolves to an invalid character');\r\n      }\r\n    } else {\r\n      // This is an entity reference.\r\n      parsedValue = syntax.predefinedEntities[ref];\r\n\r\n      if (parsedValue === undefined) {\r\n        let {\r\n          ignoreUndefinedEntities,\r\n          resolveUndefinedEntity\r\n        } = this.options;\r\n\r\n        let wrappedRef = `&${ref};`; // for backcompat with <= 2.x\r\n\r\n        if (resolveUndefinedEntity) {\r\n          let resolvedValue = resolveUndefinedEntity(wrappedRef);\r\n\r\n          if (resolvedValue !== null && resolvedValue !== undefined) {\r\n            let type = typeof resolvedValue;\r\n\r\n            if (type !== 'string') {\r\n              throw new TypeError(`\\`resolveUndefinedEntity()\\` must return a string, \\`null\\`, or \\`undefined\\`, but returned a value of type ${type}`);\r\n            }\r\n\r\n            return resolvedValue;\r\n          }\r\n        }\r\n\r\n        if (ignoreUndefinedEntities) {\r\n          return wrappedRef;\r\n        }\r\n\r\n        scanner.reset(-wrappedRef.length);\r\n        this.error(`Named entity isn't defined: ${wrappedRef}`);\r\n      }\r\n    }\r\n\r\n    return parsedValue;\r\n  }\r\n\r\n  /**\r\n  Consumes a `SystemLiteral` if possible.\r\n\r\n  A `SystemLiteral` is similar to an attribute value, but allows the characters\r\n  `<` and `&` and doesn't replace references.\r\n\r\n  @returns {string|false}\r\n    Value of the `SystemLiteral` minus quotes, or `false` if nothing was\r\n    consumed. An empty string indicates that a `SystemLiteral` was consumed but\r\n    was empty.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-SystemLiteral\r\n  */\r\n  consumeSystemLiteral() {\r\n    let { scanner } = this;\r\n    let quote = scanner.consumeStringFast('\"') || scanner.consumeStringFast(\"'\");\r\n\r\n    if (!quote) {\r\n      return false;\r\n    }\r\n\r\n    let value = scanner.consumeUntilString(quote);\r\n    this.validateChars(value);\r\n\r\n    if (!scanner.consumeStringFast(quote)) {\r\n      this.error('Missing end quote');\r\n    }\r\n\r\n    return value;\r\n  }\r\n\r\n  /**\r\n  Consumes one or more whitespace characters if possible.\r\n\r\n  @returns {boolean}\r\n    Whether any whitespace characters were consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#white\r\n  */\r\n  consumeWhitespace() {\r\n    return Boolean(this.scanner.consumeMatchFn(syntax.isWhitespace));\r\n  }\r\n\r\n  /**\r\n  Consumes an XML declaration if possible.\r\n\r\n  @returns {boolean}\r\n    Whether an XML declaration was consumed.\r\n\r\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-XMLDecl\r\n  */\r\n  consumeXmlDeclaration() {\r\n    let { scanner } = this;\r\n\r\n    if (!scanner.consumeStringFast('<?xml')) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.consumeWhitespace()) {\r\n      this.error('Invalid XML declaration');\r\n    }\r\n\r\n    let version = Boolean(scanner.consumeStringFast('version'))\r\n      && this.consumeEqual()\r\n      && this.consumeSystemLiteral();\r\n\r\n    if (version === false) {\r\n      this.error('XML version is missing or invalid');\r\n    } else if (!/^1\\.[0-9]+$/.test(version)) {\r\n      this.error('Invalid character in version number');\r\n    }\r\n\r\n    if (this.consumeWhitespace()) {\r\n      let encoding = Boolean(scanner.consumeStringFast('encoding'))\r\n        && this.consumeEqual()\r\n        && this.consumeSystemLiteral();\r\n\r\n      if (encoding) {\r\n        this.consumeWhitespace();\r\n      }\r\n\r\n      let standalone = Boolean(scanner.consumeStringFast('standalone'))\r\n        && this.consumeEqual()\r\n        && this.consumeSystemLiteral();\r\n\r\n      if (standalone) {\r\n        if (standalone !== 'yes' && standalone !== 'no') {\r\n          this.error('Only \"yes\" and \"no\" are permitted as values of `standalone`');\r\n        }\r\n\r\n        this.consumeWhitespace();\r\n      }\r\n    }\r\n\r\n    if (!scanner.consumeStringFast('?>')) {\r\n      this.error('Invalid or unclosed XML declaration');\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  Throws an error at the current scanner position.\r\n\r\n  @param {string} message\r\n  */\r\n  error(message) {\r\n    let { charIndex, string: xml } = this.scanner;\r\n    let column = 1;\r\n    let excerpt = '';\r\n    let line = 1;\r\n\r\n    // Find the line and column where the error occurred.\r\n    for (let i = 0; i < charIndex; ++i) {\r\n      let char = xml[i];\r\n\r\n      if (char === '\\n') {\r\n        column = 1;\r\n        excerpt = '';\r\n        line += 1;\r\n      } else {\r\n        column += 1;\r\n        excerpt += char;\r\n      }\r\n    }\r\n\r\n    let eol = xml.indexOf('\\n', charIndex);\r\n\r\n    excerpt += eol === -1\r\n      ? xml.slice(charIndex)\r\n      : xml.slice(charIndex, eol);\r\n\r\n    let excerptStart = 0;\r\n\r\n    // Keep the excerpt below 50 chars, but always keep the error position in\r\n    // view.\r\n    if (excerpt.length > 50) {\r\n      if (column < 40) {\r\n        excerpt = excerpt.slice(0, 50);\r\n      } else {\r\n        excerptStart = column - 20;\r\n        excerpt = excerpt.slice(excerptStart, column + 30);\r\n      }\r\n    }\r\n\r\n    let err = new Error(\r\n      `${message} (line ${line}, column ${column})\\n`\r\n        + `  ${excerpt}\\n`\r\n        + ' '.repeat(column - excerptStart + 1) + '^\\n'\r\n    );\r\n\r\n    Object.assign(err, {\r\n      column,\r\n      excerpt,\r\n      line,\r\n      pos: charIndex\r\n    });\r\n\r\n    throw err;\r\n  }\r\n\r\n  /**\r\n  Throws an invalid character error if any character in the given _string_ isn't\r\n  a valid XML character.\r\n\r\n  @param {string} string\r\n  */\r\n  validateChars(string) {\r\n    let charIndex = 0;\r\n\r\n    for (let char of string) {\r\n      if (syntax.isNotXmlChar(char)) {\r\n        this.scanner.reset(-([ ...string ].length - charIndex));\r\n        this.error('Invalid character');\r\n      }\r\n\r\n      charIndex += 1;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Parser;\r\n\r\n// -- Private Functions --------------------------------------------------------\r\n\r\n/**\r\nNormalizes the given XML string by stripping a byte order mark (if present) and\r\nreplacing CRLF sequences and lone CR characters with LF characters.\r\n\r\n@param {string} xml\r\n@returns {string}\r\n*/\r\nfunction normalizeXmlString(xml) {\r\n  if (xml[0] === '\\uFEFF') {\r\n    xml = xml.slice(1);\r\n  }\r\n\r\n  return xml.replace(/\\r\\n?/g, '\\n');\r\n}\r\n\r\n/** @typedef {import('./XmlNode')} XmlNode */\r\n"]},"metadata":{},"sourceType":"script"}