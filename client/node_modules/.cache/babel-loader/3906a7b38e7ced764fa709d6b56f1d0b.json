{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"C:/Users/bdgcy/Axis/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"C:/Users/bdgcy/Axis/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/bdgcy/Axis/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar emptyString = '';\n/**\r\n@private\r\n*/\n\nvar StringScanner = /*#__PURE__*/function () {\n  /**\r\n  @param {string} string\r\n  */\n  function StringScanner(string) {\n    _classCallCheck(this, StringScanner);\n\n    /** @type {string[]} */\n    this.chars = _toConsumableArray(string);\n    /** @type {number} */\n\n    this.charCount = this.chars.length;\n    /** @type {number} */\n\n    this.charIndex = 0;\n    /** @type {number[]} */\n\n    this.charsToBytes = new Array(this.charCount);\n    /** @type {boolean} */\n\n    this.multiByteMode = false;\n    /** @type {string} */\n\n    this.string = string;\n    var chars = this.chars,\n        charCount = this.charCount,\n        charsToBytes = this.charsToBytes;\n\n    if (charCount === string.length) {\n      // There are no multibyte characters in the input string, so char indexes\n      // and byte indexes are the same.\n      for (var i = 0; i < charCount; ++i) {\n        charsToBytes[i] = i;\n      }\n    } else {\n      // Create a mapping of character indexes to byte indexes. When the string\n      // contains multibyte characters, a byte index may not necessarily align\n      // with a character index.\n      for (var byteIndex = 0, charIndex = 0; charIndex < charCount; ++charIndex) {\n        charsToBytes[charIndex] = byteIndex;\n        byteIndex += chars[charIndex].length;\n      }\n\n      this.multiByteMode = true;\n    }\n  }\n  /**\r\n  Whether the current character index is at the end of the input string.\r\n    @type {boolean}\r\n  */\n\n\n  _createClass(StringScanner, [{\n    key: \"isEnd\",\n    get: function get() {\n      return this.charIndex >= this.charCount;\n    } // -- Protected Methods ------------------------------------------------------\n\n    /**\r\n    Returns the number of characters in the given _string_, which may differ from\r\n    the byte length if the string contains multibyte characters.\r\n      @param {string} string\r\n    @returns {number}\r\n    */\n\n  }, {\n    key: \"_charLength\",\n    value: function _charLength(string) {\n      var length = string.length;\n\n      if (length < 2 || !this.multiByteMode) {\n        return length;\n      } // We could get the char length with `[ ...string ].length`, but that's\n      // actually slower than this approach, which replaces surrogate pairs with\n      // single-byte characters.\n\n\n      return string.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '_').length;\n    } // -- Public Methods ---------------------------------------------------------\n\n    /**\r\n    Advances the scanner by the given number of characters, stopping if the end of\r\n    the string is reached.\r\n      @param {number} [count]\r\n    */\n\n  }, {\n    key: \"advance\",\n    value: function advance() {\n      var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      this.charIndex = Math.min(this.charCount, this.charIndex + count);\n    }\n    /**\r\n    Consumes and returns the given number of characters if possible, advancing the\r\n    scanner and stopping if the end of the string is reached.\r\n      If no characters could be consumed, an empty string will be returned.\r\n      @param {number} [count]\r\n    @returns {string}\r\n    */\n\n  }, {\n    key: \"consume\",\n    value: function consume() {\n      var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var chars = this.peek(count);\n      this.advance(count);\n      return chars;\n    }\n    /**\r\n    Consumes a match for the given sticky regex, advances the scanner, updates the\r\n    `lastIndex` property of the regex, and returns the matching string.\r\n      The regex must have a sticky flag (\"y\") so that its `lastIndex` prop can be\r\n    used to anchor the match at the current scanner position.\r\n      Returns the consumed string, or an empty string if nothing was consumed.\r\n      @param {RegExp} regex\r\n    @returns {string}\r\n    */\n\n  }, {\n    key: \"consumeMatch\",\n    value: function consumeMatch(regex) {\n      if (!regex.sticky) {\n        throw new Error('`regex` must have a sticky flag (\"y\")');\n      }\n\n      regex.lastIndex = this.charsToBytes[this.charIndex];\n      var result = regex.exec(this.string);\n\n      if (result === null) {\n        return emptyString;\n      }\n\n      var match = result[0];\n      this.advance(this._charLength(match));\n      return match;\n    }\n    /**\r\n    Consumes and returns all characters for which the given function returns a\r\n    truthy value, stopping on the first falsy return value or if the end of the\r\n    input is reached.\r\n      @param {(char: string) => boolean} fn\r\n    @returns {string}\r\n    */\n\n  }, {\n    key: \"consumeMatchFn\",\n    value: function consumeMatchFn(fn) {\n      var startIndex = this.charIndex;\n\n      while (!this.isEnd && fn(this.peek())) {\n        this.advance();\n      }\n\n      return this.charIndex > startIndex ? this.string.slice(this.charsToBytes[startIndex], this.charsToBytes[this.charIndex]) : emptyString;\n    }\n    /**\r\n    Consumes the given string if it exists at the current character index, and\r\n    advances the scanner.\r\n      If the given string doesn't exist at the current character index, an empty\r\n    string will be returned and the scanner will not be advanced.\r\n      @param {string} stringToConsume\r\n    @returns {string}\r\n    */\n\n  }, {\n    key: \"consumeString\",\n    value: function consumeString(stringToConsume) {\n      if (this.consumeStringFast(stringToConsume)) {\n        return stringToConsume;\n      }\n\n      if (!this.multiByteMode) {\n        return emptyString;\n      }\n\n      var length = stringToConsume.length;\n\n      var charLengthToMatch = this._charLength(stringToConsume);\n\n      if (charLengthToMatch !== length && stringToConsume === this.peek(charLengthToMatch)) {\n        this.advance(charLengthToMatch);\n        return stringToConsume;\n      }\n\n      return emptyString;\n    }\n    /**\r\n     * Does the same thing as `consumeString()`, but doesn't support consuming\r\n     * multibyte characters. This can be much faster if you only need to match\r\n     * single byte characters.\r\n     *\r\n     * @param {string} stringToConsume\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: \"consumeStringFast\",\n    value: function consumeStringFast(stringToConsume) {\n      if (this.peek() === stringToConsume[0]) {\n        var length = stringToConsume.length;\n\n        if (length === 1) {\n          this.advance();\n          return stringToConsume;\n        }\n\n        if (this.peek(length) === stringToConsume) {\n          this.advance(length);\n          return stringToConsume;\n        }\n      }\n\n      return emptyString;\n    }\n    /**\r\n    Consumes characters until the given global regex is matched, advancing the\r\n    scanner up to (but not beyond) the beginning of the match and updating the\r\n    `lastIndex` property of the regex.\r\n      The regex must have a global flag (\"g\") so that its `lastIndex` prop can be\r\n    used to begin the search at the current scanner position.\r\n      Returns the consumed string, or an empty string if nothing was consumed.\r\n      @param {RegExp} regex\r\n    @returns {string}\r\n    */\n\n  }, {\n    key: \"consumeUntilMatch\",\n    value: function consumeUntilMatch(regex) {\n      if (!regex.global) {\n        throw new Error('`regex` must have a global flag (\"g\")');\n      }\n\n      var byteIndex = this.charsToBytes[this.charIndex];\n      regex.lastIndex = byteIndex;\n      var match = regex.exec(this.string);\n\n      if (match === null || match.index === byteIndex) {\n        return emptyString;\n      }\n\n      var result = this.string.slice(byteIndex, match.index);\n      this.advance(this._charLength(result));\n      return result;\n    }\n    /**\r\n    Consumes characters until the given string is found, advancing the scanner up\r\n    to (but not beyond) that point.\r\n      Returns the consumed string, or an empty string if nothing was consumed.\r\n      @param {string} searchString\r\n    @returns {string}\r\n    */\n\n  }, {\n    key: \"consumeUntilString\",\n    value: function consumeUntilString(searchString) {\n      var charIndex = this.charIndex,\n          charsToBytes = this.charsToBytes,\n          string = this.string;\n      var byteIndex = charsToBytes[charIndex];\n      var matchByteIndex = string.indexOf(searchString, byteIndex);\n\n      if (matchByteIndex <= 0) {\n        return emptyString;\n      }\n\n      var result = string.slice(byteIndex, matchByteIndex);\n      this.advance(this._charLength(result));\n      return result;\n    }\n    /**\r\n    Returns the given number of characters starting at the current character\r\n    index, without advancing the scanner and without exceeding the end of the\r\n    input string.\r\n      @param {number} [count]\r\n    @returns {string}\r\n    */\n\n  }, {\n    key: \"peek\",\n    value: function peek() {\n      var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      // Inlining this comparison instead of checking `this.isEnd` improves perf\n      // slightly since `peek()` is called so frequently.\n      if (this.charIndex >= this.charCount) {\n        return emptyString;\n      }\n\n      if (count === 1) {\n        return this.chars[this.charIndex];\n      }\n\n      var charsToBytes = this.charsToBytes,\n          charIndex = this.charIndex;\n      return this.string.slice(charsToBytes[charIndex], charsToBytes[charIndex + count]);\n    }\n    /**\r\n    Resets the scanner position to the given character _index_, or to the start of\r\n    the input string if no index is given.\r\n      If _index_ is negative, the scanner position will be moved backward by that\r\n    many characters, stopping if the beginning of the string is reached.\r\n      @param {number} [index]\r\n    */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      this.charIndex = index >= 0 ? Math.min(this.charCount, index) : Math.max(0, this.charIndex + index);\n    }\n  }]);\n\n  return StringScanner;\n}();\n\nmodule.exports = StringScanner;","map":{"version":3,"sources":["C:/Users/bdgcy/Axis/client/node_modules/@rgrove/parse-xml/src/lib/StringScanner.js"],"names":["emptyString","StringScanner","string","chars","charCount","length","charIndex","charsToBytes","Array","multiByteMode","i","byteIndex","replace","count","Math","min","peek","advance","regex","sticky","Error","lastIndex","result","exec","match","_charLength","fn","startIndex","isEnd","slice","stringToConsume","consumeStringFast","charLengthToMatch","global","index","searchString","matchByteIndex","indexOf","max","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst emptyString = '';\r\n\r\n/**\r\n@private\r\n*/\r\nclass StringScanner {\r\n  /**\r\n  @param {string} string\r\n  */\r\n  constructor(string) {\r\n    /** @type {string[]} */\r\n    this.chars = [ ...string ];\r\n\r\n    /** @type {number} */\r\n    this.charCount = this.chars.length;\r\n\r\n    /** @type {number} */\r\n    this.charIndex = 0;\r\n\r\n    /** @type {number[]} */\r\n    this.charsToBytes = new Array(this.charCount);\r\n\r\n    /** @type {boolean} */\r\n    this.multiByteMode = false;\r\n\r\n    /** @type {string} */\r\n    this.string = string;\r\n\r\n    let { chars, charCount, charsToBytes } = this;\r\n\r\n    if (charCount === string.length) {\r\n      // There are no multibyte characters in the input string, so char indexes\r\n      // and byte indexes are the same.\r\n      for (let i = 0; i < charCount; ++i) {\r\n        charsToBytes[i] = i;\r\n      }\r\n    } else {\r\n      // Create a mapping of character indexes to byte indexes. When the string\r\n      // contains multibyte characters, a byte index may not necessarily align\r\n      // with a character index.\r\n      for (let byteIndex = 0, charIndex = 0; charIndex < charCount; ++charIndex) {\r\n        charsToBytes[charIndex] = byteIndex;\r\n        byteIndex += chars[charIndex].length;\r\n      }\r\n\r\n      this.multiByteMode = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n  Whether the current character index is at the end of the input string.\r\n\r\n  @type {boolean}\r\n  */\r\n  get isEnd() {\r\n    return this.charIndex >= this.charCount;\r\n  }\r\n\r\n  // -- Protected Methods ------------------------------------------------------\r\n\r\n  /**\r\n  Returns the number of characters in the given _string_, which may differ from\r\n  the byte length if the string contains multibyte characters.\r\n\r\n  @param {string} string\r\n  @returns {number}\r\n  */\r\n  _charLength(string) {\r\n    let { length } = string;\r\n\r\n    if (length < 2 || !this.multiByteMode) {\r\n      return length;\r\n    }\r\n\r\n    // We could get the char length with `[ ...string ].length`, but that's\r\n    // actually slower than this approach, which replaces surrogate pairs with\r\n    // single-byte characters.\r\n    return string.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '_').length;\r\n  }\r\n\r\n  // -- Public Methods ---------------------------------------------------------\r\n\r\n  /**\r\n  Advances the scanner by the given number of characters, stopping if the end of\r\n  the string is reached.\r\n\r\n  @param {number} [count]\r\n  */\r\n  advance(count = 1) {\r\n    this.charIndex = Math.min(this.charCount, this.charIndex + count);\r\n  }\r\n\r\n  /**\r\n  Consumes and returns the given number of characters if possible, advancing the\r\n  scanner and stopping if the end of the string is reached.\r\n\r\n  If no characters could be consumed, an empty string will be returned.\r\n\r\n  @param {number} [count]\r\n  @returns {string}\r\n  */\r\n  consume(count = 1) {\r\n    let chars = this.peek(count);\r\n    this.advance(count);\r\n    return chars;\r\n  }\r\n\r\n  /**\r\n  Consumes a match for the given sticky regex, advances the scanner, updates the\r\n  `lastIndex` property of the regex, and returns the matching string.\r\n\r\n  The regex must have a sticky flag (\"y\") so that its `lastIndex` prop can be\r\n  used to anchor the match at the current scanner position.\r\n\r\n  Returns the consumed string, or an empty string if nothing was consumed.\r\n\r\n  @param {RegExp} regex\r\n  @returns {string}\r\n  */\r\n  consumeMatch(regex) {\r\n    if (!regex.sticky) {\r\n      throw new Error('`regex` must have a sticky flag (\"y\")');\r\n    }\r\n\r\n    regex.lastIndex = this.charsToBytes[this.charIndex];\r\n\r\n    let result = regex.exec(this.string);\r\n\r\n    if (result === null) {\r\n      return emptyString;\r\n    }\r\n\r\n    let match = result[0];\r\n    this.advance(this._charLength(match));\r\n    return match;\r\n  }\r\n\r\n  /**\r\n  Consumes and returns all characters for which the given function returns a\r\n  truthy value, stopping on the first falsy return value or if the end of the\r\n  input is reached.\r\n\r\n  @param {(char: string) => boolean} fn\r\n  @returns {string}\r\n  */\r\n  consumeMatchFn(fn) {\r\n    let startIndex = this.charIndex;\r\n\r\n    while (!this.isEnd && fn(this.peek())) {\r\n      this.advance();\r\n    }\r\n\r\n    return this.charIndex > startIndex\r\n      ? this.string.slice(this.charsToBytes[startIndex], this.charsToBytes[this.charIndex])\r\n      : emptyString;\r\n  }\r\n\r\n  /**\r\n  Consumes the given string if it exists at the current character index, and\r\n  advances the scanner.\r\n\r\n  If the given string doesn't exist at the current character index, an empty\r\n  string will be returned and the scanner will not be advanced.\r\n\r\n  @param {string} stringToConsume\r\n  @returns {string}\r\n  */\r\n  consumeString(stringToConsume) {\r\n    if (this.consumeStringFast(stringToConsume)) {\r\n      return stringToConsume;\r\n    }\r\n\r\n    if (!this.multiByteMode) {\r\n      return emptyString;\r\n    }\r\n\r\n    let { length } = stringToConsume;\r\n    let charLengthToMatch = this._charLength(stringToConsume);\r\n\r\n    if (charLengthToMatch !== length\r\n        && stringToConsume === this.peek(charLengthToMatch)) {\r\n\r\n      this.advance(charLengthToMatch);\r\n      return stringToConsume;\r\n    }\r\n\r\n    return emptyString;\r\n  }\r\n\r\n  /**\r\n   * Does the same thing as `consumeString()`, but doesn't support consuming\r\n   * multibyte characters. This can be much faster if you only need to match\r\n   * single byte characters.\r\n   *\r\n   * @param {string} stringToConsume\r\n   * @returns {string}\r\n   */\r\n  consumeStringFast(stringToConsume) {\r\n    if (this.peek() === stringToConsume[0]) {\r\n      let { length } = stringToConsume;\r\n\r\n      if (length === 1) {\r\n        this.advance();\r\n        return stringToConsume;\r\n      }\r\n\r\n      if (this.peek(length) === stringToConsume) {\r\n        this.advance(length);\r\n        return stringToConsume;\r\n      }\r\n    }\r\n\r\n    return emptyString;\r\n  }\r\n\r\n  /**\r\n  Consumes characters until the given global regex is matched, advancing the\r\n  scanner up to (but not beyond) the beginning of the match and updating the\r\n  `lastIndex` property of the regex.\r\n\r\n  The regex must have a global flag (\"g\") so that its `lastIndex` prop can be\r\n  used to begin the search at the current scanner position.\r\n\r\n  Returns the consumed string, or an empty string if nothing was consumed.\r\n\r\n  @param {RegExp} regex\r\n  @returns {string}\r\n  */\r\n  consumeUntilMatch(regex) {\r\n    if (!regex.global) {\r\n      throw new Error('`regex` must have a global flag (\"g\")');\r\n    }\r\n\r\n    let byteIndex = this.charsToBytes[this.charIndex];\r\n    regex.lastIndex = byteIndex;\r\n\r\n    let match = regex.exec(this.string);\r\n\r\n    if (match === null || match.index === byteIndex) {\r\n      return emptyString;\r\n    }\r\n\r\n    let result = this.string.slice(byteIndex, match.index);\r\n    this.advance(this._charLength(result));\r\n    return result;\r\n  }\r\n\r\n  /**\r\n  Consumes characters until the given string is found, advancing the scanner up\r\n  to (but not beyond) that point.\r\n\r\n  Returns the consumed string, or an empty string if nothing was consumed.\r\n\r\n  @param {string} searchString\r\n  @returns {string}\r\n  */\r\n  consumeUntilString(searchString) {\r\n    let { charIndex, charsToBytes, string } = this;\r\n    let byteIndex = charsToBytes[charIndex];\r\n    let matchByteIndex = string.indexOf(searchString, byteIndex);\r\n\r\n    if (matchByteIndex <= 0) {\r\n      return emptyString;\r\n    }\r\n\r\n    let result = string.slice(byteIndex, matchByteIndex);\r\n    this.advance(this._charLength(result));\r\n    return result;\r\n  }\r\n\r\n  /**\r\n  Returns the given number of characters starting at the current character\r\n  index, without advancing the scanner and without exceeding the end of the\r\n  input string.\r\n\r\n  @param {number} [count]\r\n  @returns {string}\r\n  */\r\n  peek(count = 1) {\r\n    // Inlining this comparison instead of checking `this.isEnd` improves perf\r\n    // slightly since `peek()` is called so frequently.\r\n    if (this.charIndex >= this.charCount) {\r\n      return emptyString;\r\n    }\r\n\r\n    if (count === 1) {\r\n      return this.chars[this.charIndex];\r\n    }\r\n\r\n    let { charsToBytes, charIndex } = this;\r\n    return this.string.slice(charsToBytes[charIndex], charsToBytes[charIndex + count]);\r\n  }\r\n\r\n  /**\r\n  Resets the scanner position to the given character _index_, or to the start of\r\n  the input string if no index is given.\r\n\r\n  If _index_ is negative, the scanner position will be moved backward by that\r\n  many characters, stopping if the beginning of the string is reached.\r\n\r\n  @param {number} [index]\r\n  */\r\n  reset(index = 0) {\r\n    this.charIndex = index >= 0\r\n      ? Math.min(this.charCount, index)\r\n      : Math.max(0, this.charIndex + index);\r\n  }\r\n}\r\n\r\nmodule.exports = StringScanner;\r\n"]},"metadata":{},"sourceType":"script"}