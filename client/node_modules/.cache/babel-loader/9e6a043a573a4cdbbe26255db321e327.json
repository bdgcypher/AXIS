{"ast":null,"code":"'use strict';\n\nconst XmlNode = require('./XmlNode');\n/**\r\nElement in an XML document.\r\n\r\n@public\r\n*/\n\n\nclass XmlElement extends XmlNode {\n  /**\r\n  @param {string} name\r\n  @param {{[attrName: string]: string}} [attributes]\r\n  @param {Array<XmlCdata|XmlComment|XmlElement|XmlProcessingInstruction|XmlText>} [children]\r\n  */\n  constructor(name, attributes = Object.create(null), children = []) {\n    super();\n    /**\r\n    Name of this element.\r\n      @type {string}\r\n    @public\r\n    */\n\n    this.name = name;\n    /**\r\n    Attributes on this element.\r\n      @type {{[attrName: string]: string}}\r\n    @public\r\n    */\n\n    this.attributes = attributes;\n    /**\r\n    Child nodes of this element.\r\n      @type {Array<XmlCdata|XmlComment|XmlElement|XmlProcessingInstruction|XmlText>}\r\n    @public\r\n    */\n\n    this.children = children;\n  }\n  /**\r\n  Whether this node is empty (meaning it has no children).\r\n    @type {boolean}\r\n  @public\r\n  */\n\n\n  get isEmpty() {\n    return this.children.length === 0;\n  }\n  /** @type {boolean} */\n\n\n  get preserveWhitespace() {\n    /** @type {XmlNode?} */\n    let node = this;\n\n    while (node instanceof XmlElement) {\n      if ('xml:space' in node.attributes) {\n        return node.attributes['xml:space'] === 'preserve';\n      }\n\n      node = node.parent;\n    }\n\n    return false;\n  }\n  /**\r\n  Text content of this element and all its descendants.\r\n    @type {string}\r\n  @public\r\n  */\n\n\n  get text() {\n    return this.children.map(child => 'text' in child ? child.text : '').join('');\n  }\n\n  get type() {\n    return XmlNode.TYPE_ELEMENT;\n  }\n  /** @returns {{[key: string]: any}} */\n\n\n  toJSON() {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      name: this.name,\n      attributes: this.attributes,\n      children: this.children.map(child => child.toJSON())\n    });\n  }\n\n}\n\nmodule.exports = XmlElement;\n/** @typedef {import('./XmlCdata')} XmlCdata */\n\n/** @typedef {import('./XmlComment')} XmlComment */\n\n/** @typedef {import('./XmlProcessingInstruction')} XmlProcessingInstruction */\n\n/** @typedef {import('./XmlText')} XmlText */","map":{"version":3,"sources":["C:/Users/bdgcy/Axis/client/node_modules/@rgrove/parse-xml/src/lib/XmlElement.js"],"names":["XmlNode","require","XmlElement","constructor","name","attributes","Object","create","children","isEmpty","length","preserveWhitespace","node","parent","text","map","child","join","type","TYPE_ELEMENT","toJSON","assign","prototype","call","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,WAAD,CAAvB;AAEA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,UAAN,SAAyBF,OAAzB,CAAiC;AAC/B;AACF;AACA;AACA;AACA;AACEG,EAAAA,WAAW,CAACC,IAAD,EAAOC,UAAU,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAApB,EAAyCC,QAAQ,GAAG,EAApD,EAAwD;AACjE;AAEA;AACJ;AACA;AACA;AACA;;AAEI,SAAKJ,IAAL,GAAYA,IAAZ;AAEA;AACJ;AACA;AACA;AACA;;AAEI,SAAKC,UAAL,GAAkBA,UAAlB;AAEA;AACJ;AACA;AACA;AACA;;AAEI,SAAKG,QAAL,GAAgBA,QAAhB;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEa,MAAPC,OAAO,GAAG;AACZ,WAAO,KAAKD,QAAL,CAAcE,MAAd,KAAyB,CAAhC;AACD;AAED;;;AACsB,MAAlBC,kBAAkB,GAAG;AACvB;AACA,QAAIC,IAAI,GAAG,IAAX;;AAEA,WAAOA,IAAI,YAAYV,UAAvB,EAAmC;AACjC,UAAI,eAAeU,IAAI,CAACP,UAAxB,EAAoC;AAClC,eAAOO,IAAI,CAACP,UAAL,CAAgB,WAAhB,MAAiC,UAAxC;AACD;;AAEDO,MAAAA,IAAI,GAAGA,IAAI,CAACC,MAAZ;AACD;;AAED,WAAO,KAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AAEU,MAAJC,IAAI,GAAG;AACT,WAAO,KAAKN,QAAL,CACJO,GADI,CACAC,KAAK,IAAI,UAAUA,KAAV,GAAkBA,KAAK,CAACF,IAAxB,GAA+B,EADxC,EAEJG,IAFI,CAEC,EAFD,CAAP;AAGD;;AAEO,MAAJC,IAAI,GAAG;AACT,WAAOlB,OAAO,CAACmB,YAAf;AACD;AAED;;;AACAC,EAAAA,MAAM,GAAG;AACP,WAAOd,MAAM,CAACe,MAAP,CAAcrB,OAAO,CAACsB,SAAR,CAAkBF,MAAlB,CAAyBG,IAAzB,CAA8B,IAA9B,CAAd,EAAmD;AACxDnB,MAAAA,IAAI,EAAE,KAAKA,IAD6C;AAExDC,MAAAA,UAAU,EAAE,KAAKA,UAFuC;AAGxDG,MAAAA,QAAQ,EAAE,KAAKA,QAAL,CAAcO,GAAd,CAAkBC,KAAK,IAAIA,KAAK,CAACI,MAAN,EAA3B;AAH8C,KAAnD,CAAP;AAKD;;AAnF8B;;AAsFjCI,MAAM,CAACC,OAAP,GAAiBvB,UAAjB;AAEA;;AACA;;AACA;;AACA","sourcesContent":["'use strict';\r\n\r\nconst XmlNode = require('./XmlNode');\r\n\r\n/**\r\nElement in an XML document.\r\n\r\n@public\r\n*/\r\nclass XmlElement extends XmlNode {\r\n  /**\r\n  @param {string} name\r\n  @param {{[attrName: string]: string}} [attributes]\r\n  @param {Array<XmlCdata|XmlComment|XmlElement|XmlProcessingInstruction|XmlText>} [children]\r\n  */\r\n  constructor(name, attributes = Object.create(null), children = []) {\r\n    super();\r\n\r\n    /**\r\n    Name of this element.\r\n\r\n    @type {string}\r\n    @public\r\n    */\r\n    this.name = name;\r\n\r\n    /**\r\n    Attributes on this element.\r\n\r\n    @type {{[attrName: string]: string}}\r\n    @public\r\n    */\r\n    this.attributes = attributes;\r\n\r\n    /**\r\n    Child nodes of this element.\r\n\r\n    @type {Array<XmlCdata|XmlComment|XmlElement|XmlProcessingInstruction|XmlText>}\r\n    @public\r\n    */\r\n    this.children = children;\r\n  }\r\n\r\n  /**\r\n  Whether this node is empty (meaning it has no children).\r\n\r\n  @type {boolean}\r\n  @public\r\n  */\r\n  get isEmpty() {\r\n    return this.children.length === 0;\r\n  }\r\n\r\n  /** @type {boolean} */\r\n  get preserveWhitespace() {\r\n    /** @type {XmlNode?} */\r\n    let node = this;\r\n\r\n    while (node instanceof XmlElement) {\r\n      if ('xml:space' in node.attributes) {\r\n        return node.attributes['xml:space'] === 'preserve';\r\n      }\r\n\r\n      node = node.parent;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n  Text content of this element and all its descendants.\r\n\r\n  @type {string}\r\n  @public\r\n  */\r\n  get text() {\r\n    return this.children\r\n      .map(child => 'text' in child ? child.text : '')\r\n      .join('');\r\n  }\r\n\r\n  get type() {\r\n    return XmlNode.TYPE_ELEMENT;\r\n  }\r\n\r\n  /** @returns {{[key: string]: any}} */\r\n  toJSON() {\r\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\r\n      name: this.name,\r\n      attributes: this.attributes,\r\n      children: this.children.map(child => child.toJSON()),\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = XmlElement;\r\n\r\n/** @typedef {import('./XmlCdata')} XmlCdata */\r\n/** @typedef {import('./XmlComment')} XmlComment */\r\n/** @typedef {import('./XmlProcessingInstruction')} XmlProcessingInstruction */\r\n/** @typedef {import('./XmlText')} XmlText */\r\n"]},"metadata":{},"sourceType":"script"}