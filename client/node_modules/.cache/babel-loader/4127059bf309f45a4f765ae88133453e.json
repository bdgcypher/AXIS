{"ast":null,"code":"'use strict';\n\nvar Parser = require('./lib/Parser');\n\nvar XmlCdata = require('./lib/XmlCdata');\n\nvar XmlComment = require('./lib/XmlComment');\n\nvar XmlDocument = require('./lib/XmlDocument');\n\nvar XmlElement = require('./lib/XmlElement');\n\nvar XmlNode = require('./lib/XmlNode');\n\nvar XmlProcessingInstruction = require('./lib/XmlProcessingInstruction');\n\nvar XmlText = require('./lib/XmlText');\n/**\r\nParses the given XML string and returns an `XmlDocument` instance representing\r\nthe document tree.\r\n\r\n@example\r\n\r\n  const parseXml = require('@rgrove/parse-xml');\r\n  let doc = parseXml('<kittens fuzzy=\"yes\">I like fuzzy kittens.</kittens>');\r\n\r\n@param {string} xml\r\n  XML string to parse.\r\n\r\n@param {object} [options]\r\n  Parsing options.\r\n\r\n  @param {boolean} [options.ignoreUndefinedEntities=false]\r\n    When `true`, an undefined named entity (like \"&bogus;\") will be left in the\r\n    output as is instead of causing a parse error.\r\n\r\n  @param {boolean} [options.preserveCdata=false]\r\n    When `true`, CDATA sections will be preserved in the document as `XmlCdata`\r\n    nodes. Otherwise CDATA sections will be represented as `XmlText` nodes,\r\n    which keeps the node tree simpler and easier to work with.\r\n\r\n  @param {boolean} [options.preserveComments=false]\r\n    When `true`, comments will be preserved in the document as `XmlComment`\r\n    nodes. Otherwise comments will not be included in the node tree.\r\n\r\n  @param {(entity: string) => string?} [options.resolveUndefinedEntity]\r\n    When an undefined named entity is encountered, this function will be called\r\n    with the entity as its only argument. It should return a string value with\r\n    which to replace the entity, or `null` or `undefined` to treat the entity as\r\n    undefined (which may result in a parse error depending on the value of\r\n    `ignoreUndefinedEntities`).\r\n\r\n  @param {boolean} [options.sortAttributes=false]\r\n    When `true`, attributes in an element's `attributes` object will be sorted\r\n    in alphanumeric order by name. Otherwise they'll retain their original order\r\n    as found in the XML.\r\n\r\n@returns {XmlDocument}\r\n@public\r\n*/\n\n\nfunction parseXml(xml, options) {\n  return new Parser(xml, options).document;\n}\n\nparseXml.XmlCdata = XmlCdata;\nparseXml.XmlComment = XmlComment;\nparseXml.XmlDocument = XmlDocument;\nparseXml.XmlElement = XmlElement;\nparseXml.XmlNode = XmlNode;\nparseXml.XmlProcessingInstruction = XmlProcessingInstruction;\nparseXml.XmlText = XmlText;\nmodule.exports = parseXml;","map":{"version":3,"sources":["C:/Users/bdgcy/Axis/client/node_modules/@rgrove/parse-xml/src/index.js"],"names":["Parser","require","XmlCdata","XmlComment","XmlDocument","XmlElement","XmlNode","XmlProcessingInstruction","XmlText","parseXml","xml","options","document","module","exports"],"mappings":"AAAA;;AAEA,IAAMA,MAAM,GAAGC,OAAO,CAAC,cAAD,CAAtB;;AACA,IAAMC,QAAQ,GAAGD,OAAO,CAAC,gBAAD,CAAxB;;AACA,IAAME,UAAU,GAAGF,OAAO,CAAC,kBAAD,CAA1B;;AACA,IAAMG,WAAW,GAAGH,OAAO,CAAC,mBAAD,CAA3B;;AACA,IAAMI,UAAU,GAAGJ,OAAO,CAAC,kBAAD,CAA1B;;AACA,IAAMK,OAAO,GAAGL,OAAO,CAAC,eAAD,CAAvB;;AACA,IAAMM,wBAAwB,GAAGN,OAAO,CAAC,gCAAD,CAAxC;;AACA,IAAMO,OAAO,GAAGP,OAAO,CAAC,eAAD,CAAvB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASQ,QAAT,CAAkBC,GAAlB,EAAuBC,OAAvB,EAAgC;AAC9B,SAAQ,IAAIX,MAAJ,CAAWU,GAAX,EAAgBC,OAAhB,CAAD,CAA2BC,QAAlC;AACD;;AAEDH,QAAQ,CAACP,QAAT,GAAoBA,QAApB;AACAO,QAAQ,CAACN,UAAT,GAAsBA,UAAtB;AACAM,QAAQ,CAACL,WAAT,GAAuBA,WAAvB;AACAK,QAAQ,CAACJ,UAAT,GAAsBA,UAAtB;AACAI,QAAQ,CAACH,OAAT,GAAmBA,OAAnB;AACAG,QAAQ,CAACF,wBAAT,GAAoCA,wBAApC;AACAE,QAAQ,CAACD,OAAT,GAAmBA,OAAnB;AAEAK,MAAM,CAACC,OAAP,GAAiBL,QAAjB","sourcesContent":["'use strict';\r\n\r\nconst Parser = require('./lib/Parser');\r\nconst XmlCdata = require('./lib/XmlCdata');\r\nconst XmlComment = require('./lib/XmlComment');\r\nconst XmlDocument = require('./lib/XmlDocument');\r\nconst XmlElement = require('./lib/XmlElement');\r\nconst XmlNode = require('./lib/XmlNode');\r\nconst XmlProcessingInstruction = require('./lib/XmlProcessingInstruction');\r\nconst XmlText = require('./lib/XmlText');\r\n\r\n/**\r\nParses the given XML string and returns an `XmlDocument` instance representing\r\nthe document tree.\r\n\r\n@example\r\n\r\n  const parseXml = require('@rgrove/parse-xml');\r\n  let doc = parseXml('<kittens fuzzy=\"yes\">I like fuzzy kittens.</kittens>');\r\n\r\n@param {string} xml\r\n  XML string to parse.\r\n\r\n@param {object} [options]\r\n  Parsing options.\r\n\r\n  @param {boolean} [options.ignoreUndefinedEntities=false]\r\n    When `true`, an undefined named entity (like \"&bogus;\") will be left in the\r\n    output as is instead of causing a parse error.\r\n\r\n  @param {boolean} [options.preserveCdata=false]\r\n    When `true`, CDATA sections will be preserved in the document as `XmlCdata`\r\n    nodes. Otherwise CDATA sections will be represented as `XmlText` nodes,\r\n    which keeps the node tree simpler and easier to work with.\r\n\r\n  @param {boolean} [options.preserveComments=false]\r\n    When `true`, comments will be preserved in the document as `XmlComment`\r\n    nodes. Otherwise comments will not be included in the node tree.\r\n\r\n  @param {(entity: string) => string?} [options.resolveUndefinedEntity]\r\n    When an undefined named entity is encountered, this function will be called\r\n    with the entity as its only argument. It should return a string value with\r\n    which to replace the entity, or `null` or `undefined` to treat the entity as\r\n    undefined (which may result in a parse error depending on the value of\r\n    `ignoreUndefinedEntities`).\r\n\r\n  @param {boolean} [options.sortAttributes=false]\r\n    When `true`, attributes in an element's `attributes` object will be sorted\r\n    in alphanumeric order by name. Otherwise they'll retain their original order\r\n    as found in the XML.\r\n\r\n@returns {XmlDocument}\r\n@public\r\n*/\r\nfunction parseXml(xml, options) {\r\n  return (new Parser(xml, options)).document;\r\n}\r\n\r\nparseXml.XmlCdata = XmlCdata;\r\nparseXml.XmlComment = XmlComment;\r\nparseXml.XmlDocument = XmlDocument;\r\nparseXml.XmlElement = XmlElement;\r\nparseXml.XmlNode = XmlNode;\r\nparseXml.XmlProcessingInstruction = XmlProcessingInstruction;\r\nparseXml.XmlText = XmlText;\r\n\r\nmodule.exports = parseXml;\r\n"]},"metadata":{},"sourceType":"script"}